                        ;Z80 Membership Card Firmware with SD support, Version 1.5, July 23, 2017
                        ;File: ZMCv15.asm
                        ;
                        	MACRO 	VERSION_MSG
                        	DB	CR,LF,"Z80 MEMBERSHIP CARD MICRO-SD, v1.5beta July 23, 2017",CR,LF,EOS
                        	ENDM

                        ;	Table of Contents
                        ;	Preface_i	Acknowledgments, Revisions, notes
                        ;	Preface_ii	Description, Operation
                        ;	Preface_iii	Memory Mapping, I/O Mapping
                        ;	Chapter_1	Page 0 interrupt & restart locations
                        ;	Chapter_2	Startup Code
                        ;	Chapter_3	Main Loop, MENU selection
                        ;	Chapter_4	Menu operations. Loop back, Memory Enter/Dump/Execute, Port I/O
                        ;	Chapter_5	Supporting routines. GET_BYTE, GET_WORD, PUT_BYTE, PUT_HL, PRINT, DELAY, GET/PUT_REGISTER
                        ;	Chapter_6	Menu operations. ASCII HEXFILE TRANSFER
                        ;	Chapter_7	Menu operations. XMODEM FILE TRANSFER
                        ;	Chapter_8	Menu operations. RAM TEST
                        ;	Chapter_9	Menu operations. DISASSEMBLER - Deleted
                        ;	Chapter_10	BIOS.  PUT_CHAR (RS-232 & LED), GET_CHAR (RS-232), IN_KEY (Keyboard)
                        ;	Chapter_11	ISR.  RS-232 Receive, LED & Keyboard scanning, Timer tic counting
                        ;	Chapter_12	SD-CARD
                        ;	Chapter_13	FILE operations
                        ;	Chapter_14	FILE Support Routines
                        ;	Chapter_15	SD Memory Card Routines, Mid Level, Send/Recieve Data Sectors (Writes out Dirty Data)
                        ;	Chapter_16	General Support Routines, 32 Bit stuff and other math
                        ;	Chapter_17	High RAM routines
                        ;	Appendix_A	LED FONT
                        ;	Appendix_B	Future Use
                        ;	Appendix_C	RAM. System Ram allocation (LED_Buffer, KEY_Status, RX Buffer, etc)
                        ;	Appendix_D	HOOK LOCATIONS
                        ;	Appendix_E	Z80 Instruction Reference


                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;	Preface_i - Acknowledgments, Revisions, notes
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;
                        ;Assemble using ver 2.0 of the ASMX assembler by Bruce Tomlin
                        ;
                        ;Command to assemble:
                        ;
                        ;   asmx20 -l -o -e -C Z80 ZMCv12.asm
                        ;
                        ;
                        ;Z80 Membership Card hardware by Lee Hart.
                        ;
                        ;V1.x -Operation, Documentation and Consultation by Herb Johnson
                        ;
                        ;Firmware by Josh Bensadon. Date: Feb 10, 2014
                        ;
                        ;FP LED & Keyboard operation concepts adapted from the Heathkit H8 computer.
                        ;
                        ;Revision.
                        ;
                        ;
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;	Preface_ii - Description, Operation
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;
                        ;- - - HARDWARE - - -
                        ;
                        ;The Hardware is comprised of up to three boards, the CPU board, SIO board and Front Panel (FP) board.
                        ;
                        ;CPU Board:
                        ; Z80 CPU, 4Mhz Clock, 5V Regulator, 32K EPROM (w/firmware), 32K RAM, 8 bit input port, 8 bit output port
                        ;
                        ;SIO Board:
                        ; Additional RAM, up to 512K bytes to bank switch the lower 32K ROM on CPU Board
                        ; ACE 8250 UART with RS-232 or FTDI232 (5V TTL Level) connection
                        ; Micro SD Card Slot
                        ;
                        ;Front Panel Board:
                        ; Terminal for Power & RS-232 connection, Timer for 1mSec interrupt, LED Display Driver & Keyboard Matrix.
                        ;
                        ; LED Display: 7 x 7-Segment displays (d1 to d7) and 7 annunciator leds (x1 to x7) below the 7 digits.
                        ;
                        ;    d1   d2   d3   d4   d5   d6   d7
                        ;    _    _    _    _    _    _    _
                        ;   |_|  |_|  |_|  |_|  |_|  |_|  |_|
                        ;   |_|  |_|  |_|  |_|  |_|  |_|  |_|
                        ;    _   _      _   _     _   _     _
                        ;    x1  x2     x3  x4    x5  x6    x7
                        ;
                        ; Keyboard: 16 keys labeled "0" to "F" designated as a HEX keyboard
                        ; The "F" key is wired to a separate input line, so it can be used as a "Shift" key to produce an extended number of key codes.
                        ; The "F" and "0" keys are also wired directly to an AND gate, so that pressing both these keys produces a HARD reset.
                        ;
                        ;- - - FIRMWARE - - -
                        ;
                        ;The Firmware provides a means to control the system through two interfaces.
                        ;Control is reading/writing to memory, registers, I/O ports; having the Z80 execute programs in memory or halting execution.
                        ;The two interfaces are:
                        ; 1. The Keyboard and LED display
                        ; 2. A terminal (or PC) connected at 9600,N,8,1 to the RS-232 port.
                        ;
                        ;- - - The Keyboard and LED display interface - - -
                        ;
                        ;While entering commands or data, the annunciator LED's will light according to the state of the operation or system as follows:
                        ;
                        ; x1 = Enter Register
                        ; x2 = Enter Memory Location
                        ; x3 = Alter Memory/Register
                        ; x4 = Send Data to Output Port
                        ; x5 = Monitor Mode (Default Mode upon Power up)
                        ; x6 = Run Mode
                        ; x7 = Beeper (on key press)
                        ;
                        ;Keyboard Functions:
                        ;
                        ; "F" & "0" - Force a HARD reset to the Z80 and restarts the system.  See System Starting for additional details.
                        ;
                        ; "0" - Display a Register.  x1 lights and you have a few seconds to select which register to display.
                        ; "E" - Display Memory.  x2 lights and you have a few seconds to enter a memory location.
                        ; "5" - Display Input Port.  x2 lights and you have a few seconds to enter a port address.
                        ; "6" - Output Port. x2 lights and you have a few seconds to enter a port address,
                        ;	then x4 lights and you can enter data to output, new data may be sent while x4 remains lit.
                        ; "A" - Advance Display Element.  Advances to next Register, Memory address or Port address.
                        ; "B" - Backup Display Element.  Backs up to previous Register, Memory address or Port address.
                        ; "4" - Go. Preloads all the registers including the PC, thus causes execution at the current PC register.
                        ; "7" - Single Step.
                        ; "D" - Alter/Output.  Depending on the display, Selects a different Register, Memory Address, Port or Sends Port Output.
                        ;	Note, "D" will only send to that Output Port, to change port, reuse Command 6.
                        ; "F" & "E" - Does a SOFT reset when Running.
                        ;
                        ;
                        ;- - - The Terminal interface - - -
                        ;
                        ;Through a Terminal, there are more features you can use.  Entering a question mark (?) or another unrecognized command will display a list of available commands.
                        ;Most commands are easy to understand, given here are the few which could use a better explaination.
                        ;
                        ; C - Continous Dump.	Works like the D command but without pausing on the page boundaries.  This is to allow the text capturing of a dump.
                        ;			The captured file can then be later sent back to the system by simply sending the text file through an ASCII upload.
                        ; M - Multiple Input.	Allows the entering of data in a format that was previously sent & saved in an ASCII text file.
                        ; R - Register.		Entering R without specifiying the register will display all the registers.
                        ;			A specific register can be displayed or set if specified.  eg. R HL<CR>, R HL=1234<CR>
                        ; T - Test RAM		Specify the first and last page to test, eg T 80 8F will test RAM from 8000 to 8FFF.
                        ; X - Xmodem Transfers	Transfers a binary file through the XModem protocol.  Enter the command, then configure your PC to receive or send a file.
                        ;			eg. X U 8000<CR> will transfer a file from your PC to the RAM starting at 8000 for the length of the file (rounded up to the next 128 byte block).
                        ;			eg. X D 8000 0010 will transfer a file from RAM to your PC, starting at 8000 for 10 (16 decimal) blocks, hence file size = 2K.
                        ; : - ASCII HEX Upload	The ":" character is not entered manually, it is part of the Intel HEX file you can upload through ASCII upload.
                        ;			eg. While at the prompt, just instruct your terminal program to ASCII upload (or send text file) a .HEX file.
                        ;
                        ;
                        ;- - - System Starting - - -
                        ;When the Z80 starts execution of the firmware at 0000, all the registers are saved to memory for examination or modification.
                        ;There are many ways the Z80 can come to execute at 0000.  The firmware tries to deterimine the cause of the start up and will respond differently.
                        ;Regardless of why, the firmware first saves all the registers to RAM and saves the last Stack word *assuming* it was the PC.
                        ;A test is done to check if the FP board or SIO board is present.
                        ;-If there is no FP board, then the firmware will either RUN code in RAM @8002 (if there's a valid signature of 2F8 @8000) or HALT.
                        ;Next, 8 bytes of RAM is tested & set for/with a signature.
                        ;-If there isn't a signature, it is assumed the system is starting from a powered up condition (COLD Start), no further testing is done.
                        ;When the signature is good (WARM Start), more tests are done as follows:
                        ;Test Keyboard for "F"&"E" = Soft Reset from Keyboard
                        ;Test Keyboard for "F"|"0" = Hard Reset from Keyboard
                        ;Test Last instruction executed (assuming PC was on Stack) for RST 0 (C7) = Code Break
                        ;Test RS-232 Buffer for Ctrl-C (03) = Soft Reset from Terminal
                        ;If cause cannot be deterimined, it is assumed an external source asserted the RESET line.
                        ;
                        ;The Display will indicate the cause of reset as:
                        ;	"COLD 00"  (Power up detected by lack of RAM Signature)
                        ;	"SOFT ##"  (F-E keys pressed)
                        ;	"STEP ##"  (Single Step)
                        ;	"^C   ##"  (Ctrl-C)
                        ;	"HALT ##"  (HALT Instruction executed)
                        ;	"F-0  ##"  (F-0 Hard Reset)
                        ;	"RST0 ##"  (RST0 Instruction executed)
                        ;	"HARD ##"  (HARD Reset by other)
                        ;
                        ;Where the number after the reset shows the total number of resets.
                        ;
                        ;The PC will be changed to 8000 on Cold resets.
                        ;
                        ;
                        ;- - - Firmware BIOS - - -
                        ;
                        ;There are routines which can be called from your program to access the RS-232 Bit banging interface, Keyboard or Display inteface or Timer interrupt services.
                        ;
                        ;Label		Addr.	Description
                        ;Put_Char	xxxx	Sends the ASCII character in A to the RS-232 port or LED Display (no registers, including A, are affected)
                        ;Put_HEX	xxxx	Converts the low nibble of A to an ASCII character 0 to F and sends to RS-232 or LED Display
                        ;Put_Byte	xxxx	Converts/sends both high and low nibbles of A (sends 2 ASCII Character) to RS-232 or LED Display

                        ;Warning: FCB's must never cross page boundaries.



                        ; Z80 - Registers
                        ;
                        ; A F   A' F'
                        ; B C   B' C'
                        ; D E   D' E'
                        ; H L   H' L'
                        ;    I R
                        ;    IX
                        ;    IY
                        ;    SP
                        ;    PC


                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;	Preface_iii- Memory Mapping, I/O Mapping
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

                        ;String equates
      = 000D            CR		equ	0x0D
      = 000A            LF		equ	0x0A
      = 0000            EOS		equ	0x00


                        ;Memory Mapping
                        ;
                        ;0x0000 - 0x7FFF	EPROM or RAM (BANK SWITCHED)
                        ;0x8000 - 0xFFFF	RAM

                        ; Notes on Z80MC CPU board.
                        ; Memory Mapping
                        ; Holding /ROM high will inhibit the ROM from being enabled on the Data bus.
                        ; Holding /RAM high will inhibit the RAM from being enabled on the Data bus.
                        ; /ROM is loosely pulled low on Memrq & A15 low (ie, ROM 0000-7FFF)
                        ; /RAM is loosely pulled low on Memrq & A15 high (ie, RAM 8000-FFFF)
                        ;
                        ;
                        ; Notes on Z80 SRS board.
                        ; Memory (SDC-RAM)
                        ; The RAM on the SD card and the /ROM signal for the CPU board are both generated by U4.
                        ; The Y output is the value of the addressed Data input pin or Low if strobe (G) is high.
                        ; The W output is always the inverted value of Y.
                        ; Y goes to /ROM and W goes to RAM /CE.
                        ; Therefore, when Y is high /ROM is inhibited and RAM /CE is low
                        ; When Y is low /ROM is unhindered (and ROM is allowed to be accessed on A15=0)
                        ;
                        ; When NOT requesting any Memory operation, /MREQ=1, Y is LOW.  This is irrelevant to
                        ; the CPU ROM and RAM, but it ensures that the SDC-RAM is NOT enabled.
                        ; With A15=0:
                        ;  >Reading, Y is controled by Q1 (0=ROM, 1=RAM)
                        ;  >Writing, Y is high, thus SDC-RAM is enabled to accept the write
                        ;
                        ; With A15=1:
                        ;  >Reading or Writing, Y is low, thus SDC-RAM is disabled and CPU-RAM is enabled


                        ; Notes on Z80MC CPU board.
                        ; I/O Mapping
                        ; /OUT is loosely pulled low on A7 low, A6 high, A5 low and /WR low  (ie, 40-5F)
                        ; /IN  is loosely pulled low on A7 low, A6 high, A5 low and /RD low  (ie, 40-5F)
                        ;I/O
                        ;0x40	Input/Output
                        ;	Output bits	*Any write to output will clear /INT AND advance the Scan/Column Counter U2A.
                        ;	0 = Segment D OR LED7       --4--
                        ;	1 = Segment E OR LED6      2|   |3
                        ;	2 = Segment F OR LED5       |   |
                        ;	3 = Segment B OR LED4       --5--
                        ;	4 = Segment A OR LED3      1|   |6
                        ;	5 = Segment G OR LED2       |   |
                        ;	6 = Segment C OR LED1       --0--
                        ;	7 = RS-232 TXD (Bit Banged) = 1 when line idle, 0=start BIT
                        ;
                        ;	Input Bits
                        ;	0 = Column Counter BIT 0 (Display AND Keyboard)
                        ;	1 = Column Counter BIT 1 (Display AND Keyboard)
                        ;	2 = Column Counter BIT 2 (Display AND Keyboard)
                        ;	3 = 0 when Keys 0-7 are pressed (otherwise = 1), Row 0
                        ;	4 = 0 when Keys 8-E are pressed (otherwise = 1), Row 1
                        ;	5 = 1 when Key F is pressed (otherwise = 0), Key F is separate so it may be used as A Shift Key
                        ;	6 = 1 when U2B causes an interrupt, Timer Interrupt (Send Output to reset)
                        ;	7 = RS-232 RXD (Bit Banged) = 1 when not connected OR line idle, 0=first start BIT
                        ;
                        ;	Bit 5 allows Key F to be read separately to act as A "Shift" key when needed.
                        ;	Bits 0-2 can be read to ascertain the Display Column currently being driven.
                        ;
                        ; Notes on Z80 SIO board.
                        ; I/O
                        ; C0-C8, write single bit (D0) to BIT LATCH U5.
                        ; C0=Q0 SPI_CLK
                        ; C1=Q1 BANK 0=ROM, 1=RAM
                        ; C2=Q2
                        ; C3=Q3
                        ; C4=Q4 SD /CS
                        ; C5=Q5 SD MOSI
                        ; C6=Q6
                        ; C7=Q7 ACE MASTER RESET (1=RESET UART)
                        ;
                        ; Q0  SPI_CLK
                        ; 0   HIGH (Always)
                        ; 1   LOW and PULSED HIGH BY I/O 88  (NO NEED TO I/O TWICE HIGH/LOW FOR A PULSE)
                        ;
                        ;
                        ; IN C0 = SD Clock Pulse
                        ;
                        ; 	LD	A,1
                        ; 	OUT	(0xC0),A	;ENABLE CLK LOW
                        ; 	
                        ; 				;SINGLE I/O TO PULSE SPI_CLK
                        ; 	IN	A,(0xC0)	;PULSE SPI_CLK HIGH WITH A SINGLE I/O
                        ;
                        ;
                        ; C8-CF, write/read bytes to 8250 UART
                        ; C8 TXBUFFER/RXBUFFER
                        ; C9 Interrupt enable reg
                        ; CA Interrupt ID reg
                        ; CB Line  Control Reg (LCR) word len, stop bits, parity
                        ; CC Modem Control Reg (MCR) 0, 0, 0, Loop, OUT2, OUT1, RTS, DTR
                        ; CD Line Status Reg (LSR) TX/RX Buffer Empty
                        ; CE Modem Status Reg (MSR) DCD, RI, DSR, CTS, DDCD, TERI, DDSR, DCTS
                        ; CF Scratch Register (SCR) General read/write
                        ;
                        ; Outputs in Modem Control Reg B (MCR) control the High 4 address bits of the
                        ; extended RAM. These 4 bits are inverted and on a MR, the outputs all go high.
                        ; CC.0  /DTR  B15
                        ; CC.1  /RTS  B16
                        ; CC.2  /OUT1 B17
                        ; CC.3  /OUT2 B18
                        ;
                        ; Inputs from Modem Status Reg
                        ; CE.7  /DCD  MISO (Inverted Data from SD Card)
                        ;
                        ; Inputs from Line Status Register indicate UART condition
                        ; CD.0  Data Read 1=RX Data ready to read
                        ; CD.5  Data TX Holding Register Empty 1=Empty (ie ok to send next byte) Mask 0x20
                        ;

      = 0040            Port40		equ	0x40	;LED DISPLAY, RS-232 TXD/RXD AND KEYBOARD

                        				;U5 - 74LS259 Bit Addressable Latch
      = 00C0            SDCLK		equ	0xC0	;SD Clk and Clk Pulse
      = 00C1            RAMROM		equ	0xC1	;RAM /ROM selection
      = 00C2            BITS_Q2		equ	0xC2	;PIN 6
      = 00C3            BITS_Q3		equ	0xC3	;PIN 7
      = 00C4            SDCS		equ	0xC4	;SD Card /CS
      = 00C5            SDTX		equ	0xC5	;SD Card TX Data
      = 00C6            GREEN_LED	equ	0xC6	;GREEN_LED, PIN 11
      = 00C7            ACE_RESET	equ	0xC7	;ACE Reset

      = 00C8            ACE_DATA	equ	0xC8	;ACE TX and RX register
      = 00C8            ACE_BAUD0	equ	0xC8	;ACE Baudrate Low
      = 00C9            ACE_BAUD1	equ	0xC9	;ACE Baudrate High
      = 00CB            ACE_LCR		equ	0xCB	;ACE Word len/bit setup
      = 00CC            ACE_OUT		equ	0xCC	;ACE RAM Bank Selection.  Lower 4 bits map to Bank Select.
      = 00CD            ACE_STATUS	equ	0xCD	;ACE RX/TX status
      = 00CE            ACE_MSR		equ	0xCE	;ACE Modem Status Register
      = 00CF            ACE_SCRATCH	equ	0xCF	;ACE Scratch Register (not used, because not available on all UARTs)

                        ;	Chapter_1	Page 0 interrupt & restart locations
                        ;
                        ;                        *******    *******    *******    *******
                        ;                       *********  *********  *********  *********
                        ;                       **     **  **     **  **     **  **     **
                        ;                       **     **  **     **  **     **  **     **
                        ;---------------------  **     **  **     **  **     **  **     **  ---------------------
                        ;---------------------  **     **  **     **  **     **  **     **  ---------------------
                        ;                       **     **  **     **  **     **  **     **
                        ;                       **     **  **     **  **     **  **     **
                        ;                       *********  *********  *********  *********
                        ;                        *******    *******    *******    *******


0000                    		org	0x0000
                        					; Z80 CPU LDRTS HERE
0000  F3                		DI			; Disable Interrupts
0001  C3 0001           		JP	RESETLDRT

0008                    		org	0x0008		; RST	0x08
0008  C9                		RET

0010                    		org	0x0010		; RST	0x10
0010  C9                		RET
                        		
0018                    		org	0x0018		; RST	0x18
0018  C9                		RET
                        		
0020                    		org	0x0020		; RST	0x20
0020  C9                		RET

0028                    		org	0x0028		; RST	0x28
0028  C9                		RET

0030                    		org	0x0030		; RST	0x30
0030  C9                		RET

                        ;Interrupts:
                        ;The Serial bit banger uses an interrupt on the fall of the start bit, therefore we must count
                        ;clock cycles to the data bits.  Interrupts can happen in the middle of any instruction.
                        ;With most common instructions being between 4 and 16 tc, the count starts at 10 tc
                        ;An Interrupt is really a RST 38 instruction (with 2 extra wait cycles)
                        		;Previous Instruction	;10
                        		;RST	0x38		;13  (11 + 2 wait cycles)
0038                    		org	0x0038
0038  08                		EX	AF,AF'		;4
0039  D9                		EXX			;4
003A  2A CEFF           		LD	HL,(INT_VEC)	;16 Typical Calls are to ISR_DISPATCH
003D  E9                		JP	(HL)		;4

      = 0006            RST38_LEN	EQU	$-0x0038

                        ;What the stack looks like on Interrupts...
                        ;
                        ;OLD-STACK    ISR-STACK
                        ;   PC	
                        ;		HL
                        ;		AF
                        ;SP		PC	(Call to ISR_DISPATCH from High Ram Dispatch)
                        ;		PC	(Call to GET_REGISTER from ISR)

0066                    		org	0x0066		; NMI Service Routine
0066  E5                		PUSH	HL
0067  2A DCFF           		LD	HL,(NMI_VEC)
006A  E9                		JP	(HL)
                        ;NMI_VEC:	RETN			;



                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_2	Startup Code
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;

0100                    		ORG	0x0100
                        ;-------------------------------------------------------------------------------- RESET LDRTUP CODE
0100                    RESETLDRT:
                        ;Save Registers & SET sp
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0100  ED56              		IM	1		; Interrupts cause RST 0x38

                        					;No need to select ROM, we are already here.
0102  22 9EFF           		LD	(RSHL),HL

0105  E1                		POP	HL		;Fetch PC
0106  22 A0FF           		LD	(RPC),HL	;Save the PC
0109  ED73 96FF         		LD	(RSSP),SP	;Save the SP

010D  31 9EFF           		LD	SP,RSDE+2	;Set Stack to save registers DE,BC,AF
0110  D5                		PUSH	DE
0111  C5                		PUSH	BC
0112  F5                		PUSH	AF

0113  3E 01             		LD	A,1
0115  D3 C7             		OUT	(ACE_RESET),A	;RESET ACE

0117  08                		EX	AF,AF'		;Save Alternate register set
0118  D9                		EXX			;Save Alternate register set
0119  31 B0FF           		LD	SP,RSHL2+2	;Set Stack to save registers HL',DE',BC',AF'
011C  E5                		PUSH	HL
011D  D5                		PUSH	DE
011E  C5                		PUSH	BC
011F  F5                		PUSH	AF
0120  08                		EX	AF,AF'
0121  D9                		EXX

0122  ED57              		LD	A,I		;Fetch IR
0124  47                		LD	B,A
0125  ED5F              		LD	A,R
0127  4F                		LD	C,A
0128  C5                		PUSH	BC		;Save IR

0129  FDE5              		PUSH	IY
012B  DDE5              		PUSH	IX

012D  31 FEFA           		LD	SP, StackTop	; Stack = 0xFF80 (Next Stack Push Location = 0xFF7F,0xFF7E)


                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Save Input State, Set default Output state
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

0130  0E 40             		LD	C,Port40	;Select I/O Port
0132  1E 80             		LD	E,0x80		;Advance Column		
0134  06 08             		LD	B,8		; 8 Tries to get to Column 0
0136  ED59              RSIS_LP		OUT	(C),E		; Clear LED Display & Set RS-232 TXD to inactive state
0138  ED78              		IN	A,(C)		;Fetch Column
013A  57                		LD	D,A		;Save IN D (For RESET Test)
013B  E6 07             		AND	7		;Mask Column only
013D  28 02             		JR   Z,	RSIS_OK		;When 0, exit Test Loop
013F  10 F5             		DJNZ	RSIS_LP
0141                    RSIS_OK					;Input State upon reset saved IN Register D


0141  21 00FF           		LD	HL,BIT_TABLE	;BIT_TABLE = 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80
0144  3E 01             		LD	A,1
0146  77                FILL_BT		LD	(HL),A
0147  23                		INC	HL
0148  07                		RLCA
0149  30 FB             		JR  NC,	FILL_BT

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Test Hardware - FP Board Present?
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

                        					;Verify FP board is present
014B  01 0018           		LD	BC,0x1800	; Several Loops through Column 0 proves FP board is working
014E  1E 0A             		LD	E,10		; 10 Retries if not expected Column

0150  DB 40             RTHW_LP		IN	A,(Port40)	;Fetch Column
0152  E6 07             		AND	7
0154  B9                		CP	C
0155  CA 5D01           		JP  Z,	RTHW_OK		;Jump if Column = expected value

0158  1D                		DEC	E		;If not expected, count the errors.
0159  28 0C             		JR  Z,	RTHW_EXIT	;If error chances down to zero, there's no FP
015B  18 03             		JR	RTHW_ADV

015D  0C                RTHW_OK		INC	C		; Advance expected value
015E  CB99              		RES	3,C		; Limit expected value to 0-7
0160  3E 80             RTHW_ADV	LD	A,0x80		;Advance Column
0162  D3 40             		OUT	(Port40),A	; Clear LED Display & Set RS-232 TXD to inactive state
0164  10 EA             		DJNZ	RTHW_LP
0166  5F                		LD	E,A
0167                    RTHW_EXIT				;E=80 FP present, (D still holding input state)
                        					;E=00 NO FP


                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Test Hardware - SIO Board Present?
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

0167  AF                		XOR	A
0168  D3 C7             		OUT	(ACE_RESET),A	;Cancel RESET of ACE
                        		
016A  06 00             		LD	B,0		;Count 256 times	
016C  3E 80             		LD	A,0x80		;Set baud rate
016E  D3 CB             		OUT	(ACE_LCR),A

0170  78                RTHW_SIOT_LP	LD	A,B		;Use the counter to test for the presence
0171  D3 C8             		OUT	(ACE_BAUD0),A	;of the ACE SCRATCH Register
0173  DB C8             		IN	A,(ACE_BAUD0)
0175  B8                		CP	B
0176  20 06             		JR NZ,	RTHW_SIO_EXIT
0178  10 F6             		DJNZ	RTHW_SIOT_LP
017A  1C                		INC	E		;All tests OK, Advance E so the LSD is 1
017B  CD 7826           		CALL	SD_DESELECT	;DISABLE SD CARD, LED's OFF
017E  7B                RTHW_SIO_EXIT	LD	A,E
017F  07                		RLCA
0180  32 95FF           		LD	(HW_LIST),A	;Save HW List
                        					;00 NO Boards
                        					;01 FP only
                        					;02 SIO only
                        					;03 FP & SIO


0183  18 0F             		JR 	CHK_RESET	;Ignore EXEC_RAM_2F8

                        ;		OR	A
                        ;		JR NZ,	CHK_RESET	;Jump if any board is present


                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Execute RAM program if NO FP Board Present
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        					;If scan counter not running, then either Execute RAM OR HALT
0185  2A 0080           EXEC_RAM_2F8	LD	HL,(0x8000)	;Address of RAM Valid Signature
0188  01 F802           		LD	BC,0x2F8	;(FP board probably not present)
018B  AF                		XOR	A		;Verify RAM valid with 2F8 signature at 0x8000
018C  ED42              		SBC	HL,BC
018E  CA 0280           		JP	Z,0x8002	;Execute RAM
0191  C3 9101           		JP	$		;Or HALT

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Determine Reason for RESET ie entering Monitor Mode (D=Key Input from save state section)
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        					;Determine why the CPU is executing A RESET.
                        					;  -Power on (RAM signature will be wrong)
                        					;  -F-0 Reset Switch (one of the switches will still be pressed)
                        					;  -RST 0 (look for C7 at previous location given by stack)
                        					;  -External /RESET OR User program branches to 0000
                        					;
                        					;RC_TYPE
                        					;0	COLD RESET (NO RAM SIGNATURE)
                        					;1	F-E Soft Reset (SOFT_RST_FLAG = FE)
                        					;2	Single Step (SOFT_RST_FLAG = D1)
                        					;3	<Ctrl>-C (SOFT_RST_FLAG = CC)
                        					;4	HALT (SOFT_RST_FLAG = 76)
                        					;5	F-0 (F or 0 key on FP still down)
                        					;6	RST0 ( M(PC-1) = C7)
                        					;7	HARD RESET (Default if SOFT_RST_FLAG not set)

                        					;Test RAM Signature for Cold Start Entry
0194  21 78FF           CHK_RESET	LD	HL,RAMSIGNATURE		
0197  3E F0             		LD	A,0xF0		;First signature byte expected
0199  06 08             		LD	B,8		;#bytes in signature (loop)
019B  BE                RAMSIG_LP	CP	(HL)
019C  20 07             		JR  NZ,	COLD_START
019E  2C                		INC	L
019F  D6 0F             		SUB	0xF
01A1  10 F8             		DJNZ	RAMSIG_LP
01A3  18 2A             		JR	WARM_START

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
01A5  21 80FF           COLD_START	LD	HL,RC_TYPE
01A8  06 0F             		LD	B,CS_CLR_LEN
01AA  CD 100C           		CALL	CLEAR_BLOCK

                        		;DB	0		;(RC_TYPE)
                        		;DB	0		;(RC_SOFT)
                        		;DB	0		;(RC_STEP)
                        		;DB	0		;(RC_CC)
                        		;DB	0		;(RC_HALT)
                        		;DB	0		;(RC_F0)
                        		;DB	0		;(RC_RST0)
                        		;DB	0		;(RC_HARD)
                        		;DB	0		;(RegPtr)
                        		;DW	0		;(ABUSS)
                        		;DB	0		;(IoPtr)
                        		;DB	0		;(RX_ERR_LDRT)
                        		;DB	0		;(RX_ERR_STOP)
                        		;DB	0		;(RX_ERR_OVR)
                        		
01AD  3E 0C             		LD	A,12
01AF  32 8FFF           		LD	(ACE_BAUD),A

01B2  21 FB17           		LD	HL,UiVec_RET
01B5  22 B0FF           		LD	(UiVec),HL

01B8  3A 95FF           		LD	A,(HW_LIST)	;Fetch HW List
01BB  E6 03             		AND	3		;00 NO FP
01BD  4F                		LD	C,A		;01 FP only
01BE  CD 8213           		CALL	SET_IO		;02 SIO only
                        					;03 SIO & FP
                        		
01C1  21 FCFA           		LD	HL,StackTop-2
01C4  22 96FF           		LD	(RSSP),HL
01C7  21 0080           		LD	HL,RAM_LDRT
01CA  22 A0FF           		LD	(RPC),HL
01CD  18 41             		JR	INIT_SYSTEM

                        					;Determine Warm Start condition
                        					;Input: Various tests
                        					;(D=Key Input from save state section)
                        					;Output: HL=Pointer to Reset Codes (RC_????)
01CF  21 81FF           WARM_START	LD	HL,RC_SOFT	;HL=RC_SOFT
01D2  3A DFFF           		LD	A,(SOFT_RST_FLAG)
01D5  FE FE             		CP	0xFE		;'FE' is the keyboard code for holding F & E
01D7  28 2B             		JR  Z,	WS_SET
01D9  2C                		INC	L		;HL=RC_STEP
01DA  FE D1             		CP	0xD1		;'D1' is the code for Do One step
01DC  28 26             		JR  Z,	WS_SET
01DE  2C                		INC	L		;HL=RC_CC
01DF  FE CC             		CP	0xCC		;'CC' is the code for <Ctrl>-C
01E1  28 21             		JR  Z,	WS_SET
01E3  2C                		INC	L		;HL=RC_HALT
01E4  FE 76             		CP	0x76		;'76' is the code and opcode for HALT
01E6  28 1C             		JR  Z,	WS_SET
01E8  2C                		INC	L		;HL=RC_F0
                        		
01E9  3A 95FF           		LD	A,(HW_LIST)
01EC  1F                		RRA
01ED  30 09             		JR  NC,	WS_NOFP
                        		
01EF  7A                		LD	A,D		;Fetch Input of Column 0
01F0  CB6F              		BIT	5,A		;
01F2  20 10             		JR NZ,	WS_SET		;Jump if F switch pressed
01F4  CB5F              		BIT	3,A		;
01F6  28 0C             		JR  Z,	WS_SET		;Jump if 0 switch pressed
                        		
01F8  2C                WS_NOFP		INC	L		;HL=RC_RST0
01F9  ED5B A0FF         		LD	DE,(RPC)
01FD  1B                		DEC	DE
01FE  1A                		LD	A,(DE)
01FF  FE C7             		CP	0xC7		;Did we get here by a RESTART 0 instruction?
0201  28 01             		JR  Z,	WS_SET		;Jump if RST 0 Instruction
0203  2C                		INC	L		;HL=RC_HARD

0204  7D                WS_SET		LD	A,L		;Low address of Pointer & 7 = Reset code type
0205  32 DFFF           		LD	(SOFT_RST_FLAG),A ;Nuke flag until next time
0208  E6 07             		AND	7
020A  32 80FF           		LD	(RC_TYPE),A
020D  CD 260E           		CALL	TINC		;Advance the reset counter

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Init all System RAM, enable interrupts
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0210  21 00FE           INIT_SYSTEM	LD	HL,RXBUFFER
0213  06 00             		LD	B,0
0215  CD 100C           		CALL	CLEAR_BLOCK

0218  21 D4FF           		LD	HL,CLEARED_SPACE
021B  06 2C             		LD	B,CLEARED_LEN
021D  CD 100C           		CALL	CLEAR_BLOCK

0220  2A BCFF           		LD	HL,(DISPMODE)
0223  22 D4FF           		LD	(SDISPMODE),HL

0226  CD 1D0C           		CALL	WRITE_BLOCK
0229  B2FF              		DW	BEEP_TO		;Where to write
022B  2200              		DW	34		;Bytes to write
022D  01                		DB	1		;(BEEP_TO)
022E  84                		DB	0x84		;(ANBAR_DEF) = MON MODE
022F  710C              		DW	GET_REG_MON	;(GET_REG)
0231  860C              		DW	PUT_REG_MON	;(PUT_REG)
0233  AE17              		DW	CTRL_C_RET	;(CTRL_C_CHK)
0235  DF17              		DW	IDISP_RET	;(LDISPMODE)
0237  DF17              		DW	IDISP_RET	;(DISPMODE)
0239  3E18              		DW	IMON_CMD	;(KEY_EVENT) Initialize to Command Mode
023B  01                		DB	1		;(IK_TIMER)
023C  90                		DB	0x90		;(KEYBFMODE) HEX Keyboard Mode (F on release)
023D  01                		DB	1		;(DISPLABEL)
023E  FF                		DB	-1		;(IK_HEXST)
023F  E0FF              		DW	LED_DISPLAY	;(HEX_CURSOR) @d1
0241  1C19              		DW	HEX2ABUSS	;(HEX_READY)
0243  E0FF              		DW	LED_DISPLAY	;(LED_CURSOR)
0245  00FE              		DW	RXBUFFER	;(RXBHEAD)
0247  00FE              		DW	RXBUFFER	;(RXBTAIL)
0249  2AFB              		DW	ISR_DISPATCH	;(INT_VEC)
024B  E0FF              		DW	LED_DISPLAY	;(SCAN_PTR)
024D  E816              		DW	DO_HALT_TEST	;(HALT_TEST)

024F  3E 80             		LD	A,0x80		;Advance Column / Clear Counter for Interrupt
0251  D3 40             		OUT	(Port40),A	; Clear LED Display & Set RS-232 TXD to inactive state
0253  CD 2A0E           		CALL	DELAY_100mS

0256  21 7C02           		LD	HL,LED_SPLASH_TBL
0259  3A 80FF           		LD	A,(RC_TYPE)
025C  07                		RLCA
025D  07                		RLCA
025E  07                		RLCA
025F  CD 450E           		CALL	ADD_HL_A
0262  CD 741C           		CALL	LED_PRINT

0265  3A 80FF           		LD	A,(RC_TYPE)
0268  B7                		OR	A
0269  28 0D             		JR  Z,	LSPLASH_CNT
026B  21 80FF           		LD	HL, RC_TYPE	;Print count of reset type
026E  CD 450E           		CALL	ADD_HL_A
0271  7E                		LD	A,(HL)
0272  21 E5FF           		LD	HL,LED_DISPLAY+5
0275  CD 461C           		CALL	LED_PUT_BYTE_HL
0278  36 80             LSPLASH_CNT	LD	(HL),0x80	;Annunciator LED's OFF

027A  18 40             		JR	SKIP_TABLE1

027C  2D44454C 41592D00 LED_SPLASH_TBL	DB	"-DELAY-",EOS
0284  536F6674 20202000 		DB	"Soft   ",EOS
028C  53744570 20202000 		DB	"StEp   ",EOS
0294  5E432020 20202000 		DB	"^C     ",EOS
029C  48414C74 20202000 		DB	"HALt   ",EOS
02A4  462D3020 20202000 		DB	"F-0    ",EOS
02AC  52737430 20202000 		DB	"Rst0   ",EOS
02B4  48415244 20202000 		DB	"HARD   ",EOS

02BC                    SKIP_TABLE1	
                        		
02BC  CD 7108           		CALL	SET_BANK	;Bank 0
                        		
02BF  CD 1C28           		CALL	LOAD_HIGH_RAM	;Copy subroutines to HIGH RAM

02C2  CD F214           		CALL	ACE_SET_BAUD	;Set Baud & Word to saved setting (might have been changed from 9600)

02C5  FB                		EI			;************** Interrupts ON!!!!

                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_3	Main Loop, RS-232 MONITOR, MENU selection
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;

02C6  3E 80             		LD	A,0x80		;
02C8  32 F5FF           		LD	(SCAN_LED),A
02CB  D3 40             		OUT	(Port40),A	;Reset Timer interrupt

02CD  3A 80FF           		LD	A,(RC_TYPE)
                        		;CALL	PRINTI
                        		;DB	CR,LF,"RT_TYPE=",EOS		
                        		;CALL	PUT_BYTE
02D0  B7                		OR	A
02D1  20 1E             		JR NZ,	NOT_COLD

02D3  0E 14             		LD	C,20		;2 Seconds
02D5  CD 2C0E           		CALL	DELAY_C		;Delay in 100mSEC

02D8  CD 861C           		CALL	LED_HOME_PRINTI
02DB  434F4C44 20303000 		DB	"COLD 00",EOS
                        		
02E3  21 78FF           		LD	HL,RAMSIGNATURE
02E6  3E F0             		LD	A,0xF0		;First signature byte expected
02E8  06 08             		LD	B,8		;#bytes in signature (loop)
02EA  77                RAMSIGN_LP	LD	(HL),A		;Save Signature
02EB  2C                		INC	L
02EC  D6 0F             		SUB	0xF
02EE  10 FA             		DJNZ	RAMSIGN_LP
02F0  AF                		XOR	A
                        		
02F1  07                NOT_COLD	RLCA
02F2  21 1603           		LD	HL,RS232_SPLASH
02F5  CD 450E           		CALL	ADD_HL_A
02F8  CD 4A0E           		CALL	LD_HL_HL
02FB  CD 1F0E           		CALL	PUT_NEW_LINE		
02FE  CD BD0D           		CALL	PRINT
0301  3A 80FF           		LD	A,(RC_TYPE)
0304  B7                		OR	A
0305  28 6D             		JR   Z,	SPLASH_VERSION
0307  21 80FF           		LD	HL, RC_TYPE	;Print count of reset type
030A  CD 450E           		CALL	ADD_HL_A
030D  7E                		LD	A,(HL)
030E  CD F30D           		CALL	SPACE_PUT_BYTE
0311  CD 1F09           		CALL	REG_DISP_ALL
0314  18 61             		JR	SKIP_TABLE2

0316  2603              RS232_SPLASH	DW	R_COLD
0318  3303              		DW	R_SOFT
031A  4003              		DW	R_STEP
031C  4503              		DW	R_CC
031E  4E03              		DW	R_HALT
0320  5703              		DW	R_F0
0322  6103              		DW	R_RST0
0324  6903              		DW	R_HARD

0326  436F6C64 20537461 R_COLD		DB	"Cold Start",CR,LF,EOS
032E  72740D0A 00
0333  536F6674 20526573 R_SOFT		DB	"Soft Restart",EOS
033B  74617274 00
0340  53746570 00       R_STEP		DB	"Step",EOS
0345  3C437472 6C3E2D43 R_CC		DB	"<Ctrl>-C",EOS
034D  00
034E  43505520 48414C54 R_HALT		DB	"CPU HALT",EOS
0356  00
0357  462D3020 52657365 R_F0		DB	"F-0 Reset",EOS
035F  7400
0361  3C427265 616B3E00 R_RST0		DB	"<Break>",EOS
0369  48617264 20526573 R_HARD		DB	"Hard Reset",EOS
0371  657400

0374  CD 9B08           SPLASH_VERSION	CALL 	PUT_VERSION

0377  3A 80FF           SKIP_TABLE2	LD	A,(RC_TYPE)
037A  FE 02             		CP	2		;If returning from Single Step, restore Monitor Display
037C  20 09             		JR NZ,	WB_NOT_STEP
037E  2A D4FF           		LD	HL,(SDISPMODE)
0381  22 BAFF           		LD	(LDISPMODE),HL
0384  22 BCFF           		LD	(DISPMODE),HL
0387                    WB_NOT_STEP	


                        ;                 ******       *****      *****    *********
                        ;                 *******     *******    *******   *********
                        ;                 **    **   ***   ***  ***   ***     ***
                        ;                 **    **   **     **  **     **     ***
                        ;                 *******    **     **  **     **     ***
                        ;                 *******    **     **  **     **     ***
                        ;                 **    **   **     **  **     **     ***
                        ;                 **    **   ***   ***  ***   ***     ***
                        ;                 *******     *******    *******      ***
                        ;                 ******       *****      *****       ***




0387  3A 80FF           		LD	A,(RC_TYPE)	;Auto boot option for cold start or RESET only
038A  B7                		OR	A
038B  28 04             		JR Z,	AUTO_BOOT_MENU
038D  FE 07             		CP	7
038F  20 51             		JR NZ,	MAIN_MENU

                        	;HW_LIST: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP

0391  3A 95FF           AUTO_BOOT_MENU	LD	A,(HW_LIST)	;Auto boot if no card or SD card
0394  B7                		OR	A
0395  28 04             		JR   Z,	AUTO_BOOT_DO
0397  E6 02             		AND	2
0399  28 47             		JR   Z,	MAIN_MENU	;No Option to boot from SD Card
                        		
039B  CD CA0D           AUTO_BOOT_DO	CALL	PRINTI		;Monitor Start, Display Welcome Message
039E  0D0A5072 65737320 		DB	CR,LF,"Press M for Monitor",EOS
03A6  4D20666F 72204D6F
03AE  6E69746F 7200
                        		
03B4  06 1E             		LD	B,30
03B6  CD 2E14           AUTO_BOOT_LP	CALL	DOT_GETCHAR	;C=1 if dots timed out or <TAB>, or C=0 and A=char
03B9  38 06             		JR  C,	AUTO_BOOT_GO
03BB  FE 4D             		CP	'M'
03BD  28 23             		JR  Z,	MAIN_MENU	;M? Go Monitor
03BF  18 F5             		JR	AUTO_BOOT_LP
                        		
03C1  21 80FF           AUTO_BOOT_GO	LD	HL,RC_TYPE	;Flag auto boot
03C4  CBFE              		SET	7,(HL)		
03C6  3A 95FF           		LD	A,(HW_LIST)	;Auto boot to BASIC if no board
03C9  B7                		OR	A
03CA  CA 002A           		JP   Z,	GO_BASIC
03CD  CD 1D0C           		CALL	WRITE_BLOCK
03D0  43FF              		DW	FILENAME	;Where to write
03D2  0B00              		DW	11		;Bytes to write
03D4  5A38304D 435F474F 		DB	'Z80MC_GOHEX'
03DC  484558
03DF  CD 8F1C           		CALL	GO_SD_CARD	;Do a CALL, let any returns go to Monitor
                        		
                        		
                        		

                        ;************************************************************************************
                        ;************************************************************************************
                        ;************************************************************************************
                        ;************************************************************************************
                        ;
                        ;
                        ;                 ***        ***    *********    **       **     **       **
                        ;                 ****      ****    *********    ***      **     **       **
                        ;                 ** **    ** **    **           ****     **     **       **
                        ;                 **  **  **  **    **           ** **    **     **       **
                        ;                 **   ****   **    *******      **  **   **     **       **
                        ;                 **    **    **    *******      **   **  **     **       **
                        ;                 **          **    **           **    ** **     **       **
                        ;                 **          **    **           **     ****     ***     ***
                        ;                 **          **    *********    **      ***      *********
                        ;                 **          **    *********    **       **        *****


                        ;Monitor
                        ;Functions:
                        ; -Dump, Edit & Execute Memory.
                        ; -Input Port and Output Port.
                        ; -RAM Test
                        ; -ASCII Upload intel HEX file
                        ; -XMODEM up/down load to Memory
                        ;
                        ; D XXXX YYYY	Dump memory from XXXX to YYYY
                        ; E XXXX	Edit memory starting at XXXX (type an X and press enter to exit entry)
                        ; G XXXX	GO starting at address XXXX (Monitor program address left on stack)
                        ; I XX		Input from I/O port XX and display as hex
                        ; O XX YY	Output to I/O port XX byte YY
                        ; L		Loop back test
                        ; X U XXXX	XMODEM Upload to memory at XXXX (CRC or CHECKSUM)
                        ; X D XXXX CCCC	XMODEM Download from memory at XXXX for CCCC number of 128 byte blocks
                        ; :ssHHLLttDDDDDD...CS   -ASCII UPLOAD Intel HEX file to Memory.  Monitor auto downloads with the reception of a colon.
                        ; R XX YY	RAM TEST from pages XX to YY
                        ; V		Report Version


                        ;----------------------------------------------------------------------------------------------------; MAIN MENU
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;----------------------------------------------------------------------------------------------------; MAIN MENU

03E2  31 FEFA           MAIN_MENU:	LD	SP, StackTop	; Reset Stack = 0xFF80
03E5  AF                		XOR	A
                        			
03E6  32 43FF           		LD	(FILENAME),A	;Nuke any Auto Run
03E9  21 E203           		LD	HL, MAIN_MENU	;Push Mainmenu onto stack as default return address
03EC  E5                		PUSH	HL
                        		
03ED  CD 2614           		CALL	PURGE
                        		
03F0  CD CA0D           		CALL	PRINTI		;Monitor Start, Display Welcome Message
03F3  0D0A4D61 696E204D 		DB	CR,LF,"Main Menu >",EOS
03FB  656E7520 3E00
                        		
0401  3E FF             		LD	A,0xFF
0403  CD D027           		CALL	SET_ECHO	;Echo on

0406  CD DC13           		CALL 	GET_CHAR	;get char

0409  FE 31             		CP 	'1'
040B  CA A407           		JP Z,	SW2_BIT
040E  FE 32             		CP 	'2'
0410  CA AC07           		JP Z,	SW2_ACE
0413  FE 33             		CP 	'3'
0415  CA B407           		JP Z,	SW2_BOTH		

0418  E6 5F             		AND 	0x5F		;to upper case
041A  FE 42             		CP 	'B'		;
041C  CA 002A           		JP Z, 	GO_BASIC	; B = GO BASIC
041F  FE 43             		CP 	'C'		;
0421  CA 5F0A           		JP Z, 	MEM_DUMP	; C = Memory Dump (Continuous)
0424  FE 44             		CP 	'D'		;
0426  CA 7E0A           		JP Z, 	MEM_DUMP_PAGED	; D = Memory Dump
0429  FE 45             		CP 	'E'
042B  CA 1D0B           		JP Z, 	MEM_EDIT	; E = Edit Memory
042E  FE 47             		CP 	'G'
0430  CA 430B           		JP Z, 	MEM_EXEC	; G = Go (Execute at)
0433  FE 48             		CP	'H'
0435  CA 4F0E           		JP Z,	GETHEXFILE	; H = START HEX FILE LOAD
0438  FE 49             		CP 	'I'
043A  CA FC0B           		JP Z, 	PORT_INP	; I = Input from Port
043D  FE 4C             		CP 	'L'
043F  CA B709           		JP Z,	LOOP_BACK_TEST	; L = Loop Back Test
0442  FE 4D             		CP 	'M'
0444  CA 150A           		JP Z,	MEM_ENTER	; M = ENTER INTO MEMORY
0447  FE 4F             		CP 	'O'
0449  CA 060C           		JP Z, 	PORT_OUT	; O = Output to port
044C  FE 50             		CP 	'P'
044E  CA 0B08           		JP Z,	PORT_SPEED	; P = Port Speed for ACE
0451  FE 52             		CP 	'R'
0453  CA 1509           		JP Z,	REG_MENU	; R = REGISTER OPERATIONS
0456  FE 53             		CP 	'S'		;
0458  CA 8F1C           		JP Z, 	GO_SD_CARD	; S = BOOT SD CARD
045B  FE 54             		CP 	'T'
045D  CA 0011           		JP Z,	RAM_TEST	; T = RAM TEST
0460  FE 55             		CP 	'U'
0462  CA 3108           		JP Z,	USE_RAM		; U = USE RAM/ROM
0465  FE 56             		CP 	'V'
0467  CA 9B08           		JP Z,	PUT_VERSION	; V = Version
046A  FE 57             		CP 	'W'
046C  CA 3C1A           		JP Z, 	GO_SINGLE	; W = Single Step
046F  FE 58             		CP 	'X'
0471  CA EE0E           		JP Z, 	XMODEM		; X = XMODEM
0474  FE 59             		CP 	'Y'
0476  CA DA07           		JP Z,	WHICH_PORT	; Y = Display Which port

0479  CD CA0D           PRINT_MENU	CALL 	PRINTI		;Display Help when input is invalid
047C  0D0A4845 4C50     		DB	CR,LF,"HELP"		
0482  0D0A4420 58585858 		DB	CR,LF,"D XXXX YYYY    Dump memory from XXXX to YYYY"
048A  20595959 59202020
0492  2044756D 70206D65
049A  6D6F7279 2066726F
04A2  6D205858 58582074
04AA  6F205959 5959
04B0  0D0A4320 58585858 		DB	CR,LF,"C XXXX YYYY    Continous Dump (no pause)"
04B8  20595959 59202020
04C0  20436F6E 74696E6F
04C8  75732044 756D7020
04D0  286E6F20 70617573
04D8  6529
04DA  0D0A4520 58585858 		DB	CR,LF,"E XXXX         Edit memory starting at XXXX"
04E2  20202020 20202020
04EA  20456469 74206D65
04F2  6D6F7279 20737461
04FA  7274696E 67206174
0502  20585858 58
0507  0D0A4D20 58585858 		DB	CR,LF,"M XXXX YY..YY  Enter many bytes into memory at XXXX"
050F  2059592E 2E595920
0517  20456E74 6572206D
051F  616E7920 62797465
0527  7320696E 746F206D
052F  656D6F72 79206174
0537  20585858 58
053C  0D0A4720 5B585858 		DB	CR,LF,"G [XXXX]       GO (PC Optional)"
0544  585D2020 20202020
054C  20474F20 28504320
0554  4F707469 6F6E616C
055C  29
055D  0D0A5720 20202020 		DB	CR,LF,"W              Single Step"
0565  20202020 20202020
056D  2053696E 676C6520
0575  53746570
0579  0D0A4920 58582020 		DB	CR,LF,"I XX           Input from I/O"
0581  20202020 20202020
0589  20496E70 75742066
0591  726F6D20 492F4F
0598  0D0A4F20 58582059 		DB	CR,LF,"O XX YY        Output to I/O"
05A0  59202020 20202020
05A8  204F7574 70757420
05B0  746F2049 2F4F
05B6  0D0A5220 7272205B 		DB	CR,LF,"R rr [=xx]     Register"
05BE  3D78785D 20202020
05C6  20526567 69737465
05CE  72
05CF  0D0A4C20 20202020 		DB	CR,LF,"L              Loop back test"
05D7  20202020 20202020
05DF  204C6F6F 70206261
05E7  636B2074 657374
05EE  0D0A5420 58582059 		DB	CR,LF,"T XX YY        RAM TEST from pages XX to YY"
05F6  59202020 20202020
05FE  2052414D 20544553
0606  54206672 6F6D2070
060E  61676573 20585820
0616  746F2059 59
061B  0D0A5620 20202020 		DB	CR,LF,"V              Version"
0623  20202020 20202020
062B  20566572 73696F6E
0633  0D0A4820 20202020 		DB	CR,LF,"H              UPLOAD Intel HEX file"
063B  20202020 20202020
0643  2055504C 4F414420
064B  496E7465 6C204845
0653  58206669 6C65
0659  0D0A5820 55205858 		DB	CR,LF,"X U XXXX       XMODEM Upload to memory at XXXX"
0661  58582020 20202020
0669  20584D4F 44454D20
0671  55706C6F 61642074
0679  6F206D65 6D6F7279
0681  20617420 58585858
0689  0D0A5820 44205858 		DB	CR,LF,"X D XXXX CCCC  XMODEM Download from XXXX for CCCC #of 128 byte blocks"
0691  58582043 43434320
0699  20584D4F 44454D20
06A1  446F776E 6C6F6164
06A9  2066726F 6D205858
06B1  58582066 6F722043
06B9  43434320 236F6620
06C1  31323820 62797465
06C9  20626C6F 636B73
06D0  0D0A5020 20202020 		DB	CR,LF,"P              Port Speed (ACE Only)"
06D8  20202020 20202020
06E0  20506F72 74205370
06E8  65656420 28414345
06F0  204F6E6C 7929
06F6  0D0A312C 322C3320 		DB	CR,LF,"1,2,3          Switch Console Input"
06FE  20202020 20202020
0706  20537769 74636820
070E  436F6E73 6F6C6520
0716  496E7075 74
071B  0D0A5920 20202020 		DB	CR,LF,"Y              Identify Port"
0723  20202020 20202020
072B  20496465 6E746966
0733  7920506F 7274
0739  0D0A5520 20202020 		DB	CR,LF,"U              Use ROM or RAM BANK"
0741  20202020 20202020
0749  20557365 20524F4D
0751  206F7220 52414D20
0759  42414E4B
075D  0D0A5320 20202020 		DB	CR,LF,"S              SD CARD BOOT"
0765  20202020 20202020
076D  20534420 43415244
0775  20424F4F 54
077A  0D0A4220 20202020 		DB	CR,LF,"B              BASIC - DAVE DUNFIELD"
0782  20202020 20202020
078A  20424153 4943202D
0792  20444156 45204455
079A  4E464945 4C44
07A0  0D0A00            		DB	CR,LF,EOS
07A3  C9                		RET


                        ;1,2,3          Switch Console Input"

                        ;A
                        ;B BASIC
                        ;C Continous Dump (no pause)
                        ;D Dump memory
                        ;E Edit memory
                        ;F
                        ;G GO (PC Optional)
                        ;H UPLOAD Intel HEX file
                        ;I Input from I/O
                        ;J
                        ;K
                        ;L Loop back test
                        ;M Enter many bytes
                        ;N
                        ;O Output to I/O
                        ;P Port Speed
                        ;Q
                        ;R Register
                        ;S SD CARD BOOT
                        ;T RAM TEST
                        ;U Use ROM or RAM BANK
                        ;V Version
                        ;W Single Step
                        ;X XMODEM
                        ;Y Identify Port
                        ;Z



07A4  0E 01             SW2_BIT		LD	C,1
07A6  CD 8213           		CALL	SET_IO
07A9  D8                		RET  C
07AA  18 0E             		JR	PUT_IOMSG

07AC  0E 02             SW2_ACE		LD	C,2
07AE  CD 8213           		CALL	SET_IO
07B1  D8                		RET  C
07B2  18 06             		JR	PUT_IOMSG

07B4  0E 03             SW2_BOTH	LD	C,3
07B6  CD 8213           		CALL	SET_IO
07B9  D8                		RET  C

07BA  CD 1F0E           PUT_IOMSG	CALL	PUT_NEW_LINE
07BD  3A 94FF           		LD	A,(HW_SETIO)
07C0  3D                		DEC	A
07C1  07                		RLCA
07C2  07                		RLCA
07C3  21 CD07           		LD	HL,IO_MSG
07C6  CD 450E           		CALL	ADD_HL_A
07C9  CD BD0D           		CALL	PRINT
07CC  C9                		RET

07CD  42495400          IO_MSG		DB	"BIT",EOS
07D1  41434500          		DB	"ACE",EOS
07D5  424F5448 00       		DB	"BOTH",EOS


07DA  CD 861C           WHICH_PORT	CALL	LED_HOME_PRINTI		
07DD  4C454420 00       		DB	"LED ",EOS
07E2  3A 94FF           		LD	A,(HW_SETIO)
07E5  47                		LD	B,A
07E6  0E 01             		LD	C,1
07E8  CD 8213           		CALL	SET_IO
07EB  38 09             		JR C,	WP_NOBIT
07ED  CD CA0D           		CALL	PRINTI		
07F0  0D0A4249 5400     		DB	CR,LF,"BIT",EOS
07F6  0E 02             WP_NOBIT	LD	C,2
07F8  CD 8213           		CALL	SET_IO
07FB  38 09             		JR C,	WP_NOACE
07FD  CD CA0D           		CALL	PRINTI		
0800  0D0A4143 4500     		DB	CR,LF,"ACE",EOS		
0806  48                WP_NOACE	LD	C,B
0807  CD 8213           		CALL	SET_IO
080A  C9                		RET

080B  CD CA0D           PORT_SPEED	CALL	PRINTI		
080E  0D0A2830 433D3936 		DB	CR,LF,"(0C=9600) BAUD:",EOS
0816  30302920 42415544
081E  3A00
0820  3A 8FFF           		LD	A,(ACE_BAUD)
0823  CD F60D           		CALL	PUT_BYTE
0826  CD 490D           		CALL	SPACE_GET_BYTE
0829  D8                		RET  C
082A  32 8FFF           		LD	(ACE_BAUD),A
082D  CD F214           		CALL	ACE_SET_BAUD
0830  C9                		RET

0831  CD CA0D           USE_RAM		CALL	PRINTI		
0834  0D0A4375 7272656E 		DB	CR,LF,"Currently using:",EOS
083C  746C7920 7573696E
0844  673A00
0847  CD 7A08           		CALL	DISP_RRBANK
084A  CD CA0D           		CALL	PRINTI		
084D  0D0A456E 74657220 		DB	CR,LF,"Enter 0-F,R ",EOS
0855  302D462C 522000
085C  CD 950D           		CALL	GET_HEX
085F  38 04             		JR   C,	UR_NOTRAM
0861  07                		RLCA
0862  3C                		INC	A
0863  18 06             		JR	UR_RET
0865  E6 5F             UR_NOTRAM	AND	0x5F		;To upper case
0867  D6 52             		SUB	'R'		;If ='R', Use ROM (A=0)
0869  20 03             		JR  NZ,	UR_RET1		
086B  32 DBFF           UR_RET		LD	(READ_RAMROM),A
086E  CD 7A08           UR_RET1		CALL	DISP_RRBANK
0871  3A DBFF           SET_BANK	LD	A,(READ_RAMROM)
0874  1F                		RRA
0875  E6 0F             		AND	0xF
0877  D3 CC             		OUT	(ACE_OUT),A	;SET Bank
0879  C9                		RET
                        				
087A  3A DBFF           DISP_RRBANK	LD	A,(READ_RAMROM)
087D  1F                		RRA
087E  30 12             		JR  NC,	DRR_ROM
0880  CD CA0D           		CALL	PRINTI
0883  2052414D 2042414E 		DB	" RAM BANK:",EOS		
088B  4B3A00
088E  CD 090E           		CALL	PUT_HEX
0891  C9                		RET
0892  CD CA0D           DRR_ROM		CALL	PRINTI
0895  20524F4D 00       		DB	" ROM",EOS
089A  C9                		RET
                        		



                        		

                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_4	Menu operations
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;

                        ;=============================================================================
                        ;Display Version
                        ;-----------------------------------------------------------------------------
089B  CD CA0D           PUT_VERSION	CALL	PRINTI
089E                    		VERSION_MSG
08D7  CD CA0D           		CALL	PRINTI		
08DA  48617264 77617265 		DB	"Hardware: ",EOS	
08E2  3A2000
08E5  3A 95FF           		LD	A,(HW_LIST)	;00 NO FP
08E8  CD F60D           		CALL	PUT_BYTE	;01 FP only
08EB  B7                		OR	A		;02 SIO only
08EC  20 0A             		JR NZ,	PVH_0		;03 FP & SIO
08EE  CD CA0D           		CALL	PRINTI		
08F1  204E6F6E 6500     		DB	" None",EOS
08F7  C9                		RET
                        		
08F8  0F                PVH_0		RRCA
08F9  0E 20             		LD	C,' '
08FB  30 09             		JR NC,	PVH_1
08FD  0E 2C             		LD	C,','
08FF  CD CA0D           		CALL	PRINTI		
0902  20465000          		DB	" FP",EOS
0906  0F                PVH_1		RRCA
0907  D0                		RET NC
0908  79                		LD	A,C
0909  CD E813           		CALL	PUT_CHAR
090C  CD CA0D           		CALL	PRINTI		
090F  2053494F 00       		DB	" SIO",EOS
0914  C9                		RET			
                        					
                        				

                        ;=============================================================================
                        ;Register Display/Set
                        ;-----------------------------------------------------------------------------
0915  CD 190E           REG_MENU	CALL	PUT_SPACE
0918  CD DC13           		CALL	GET_CHAR
091B  FE 0D             		CP	CR
091D  20 30             		JR  NZ,	RM_NOTALL

                        ;12345678901234567890123456789012345678901234567890123456789012345678901234567890  80 COLUMNS
                        ;AF=xxxx  BC=xxxx  DE=xxxx  HL=xxxx  AF'=xxxx  BC'=xxxx  DE'=xxxx  HL'=xxxx
                        ;IX=xxxx  IY=xxxx  IR=xxxx  PC=xxxx  SP=xxxx

091F                    REG_DISP_ALL				;Dump ALL registers
091F  06 0D             		LD	B,13		;13 Registers to dump
0921  21 4209           RM_LP		LD	HL,REGORDER
0924  78                		LD	A,B
0925  3D                		DEC	A
0926  CD 450E           		CALL	ADD_HL_A
0929  7E                		LD	A,(HL)
092A  B7                		OR	A
092B  FC 1F0E           		CALL M,	PUT_NEW_LINE
092E  E6 0F             		AND	0xF
0930  CD 2E0C           		CALL	GET_REGNAME
0933  CD BD0D           		CALL	PRINT
0936  CD AB09           		CALL	RM_DUMP_REG
0939  CD CA0D           		CALL	PRINTI
093C  202000            		DB	'  ',EOS
093F  10 E0             		DJNZ	RM_LP
0941  C9                		RET

0942  00                REGORDER	DB	0		;Registers to dump (Numbers shifted left)
0943  05                		DB	5		;LSB will indicate a NEW LINE
0944  08                		DB	8
0945  07                		DB	7
0946  86                		DB	6 + 0x80
0947  0C                		DB	12
0948  0B                		DB	11
0949  0A                		DB	10
094A  89                		DB	9 + 0x80
094B  04                		DB	4
094C  03                		DB	3
094D  02                		DB	2
094E  81                		DB	1 + 0x80	;First Register to Dump

094F  CD AD27           RM_NOTALL	CALL	TO_UPPER
0952  CD B627           		CALL	IS_LETTER	;A contains first letter of register
0955  38 2F             		JR  C,	RM_ERR		;abort if not a letter
0957  5F                		LD	E,A		;E=first letter of register
0958  CD DC13           		CALL	GET_CHAR	;input 2nd letter of register
095B  CD AD27           		CALL	TO_UPPER
095E  CD B627           		CALL	IS_LETTER	;
0961  38 23             		JR  C,	RM_ERR		;Abort if 2nd char is not a letter
0963  57                		LD	D,A		;D=2nd letter

0964  2E 00             		LD	L,0
0966  CD DC13           RM_2		CALL	GET_CHAR	;Get the 3rd char command
0969  FE 27             		CP	0x27		;Apostrophe Char
096B  20 04             		JR  NZ,	RM_3		;if 3rd char is apostrophe,
096D  2E 01             		LD	L,1		;L=1 if Alternate Register
096F  18 F5             		JR	RM_2		;and loop back for a 4th char command
                        		
0971  CB1D              RM_3		RR	L		;Put Alternate flag into CARRY
0973  F5                		PUSH	AF		;Save last key input before proceeding to Search for Register

0974  06 0D             		LD	B,13		;Loop through all 13 registers
0976  78                RM_4		LD	A,B
0977  3D                		DEC	A		;adjust to base 0
0978  CD 2E0C           		CALL	GET_REGNAME	;HL=PTR TO NAME
097B  CD 4A0E           		CALL	LD_HL_HL	;HL = ASCII name of Register
097E  B7                		OR	A		;CLEAR CARRY
097F  ED52              		SBC	HL,DE		;Test if DE=HL
0981  28 09             		JR  Z,	RM_5		;Jump if NAME FOUND
0983  10 F1             		DJNZ	RM_4

0985  F1                		POP	AF
0986  3E 3F             RM_ERR		LD	A,'?'		;Register Name not found
0988  CD E813           		CALL	PUT_CHAR
098B  C9                		RET
                        		
098C  48                RM_5		LD	C,B		;C=Register Ptr
098D  0D                		DEC	C
098E  F1                		POP	AF		;Restore saved command (and alternate register selection)
098F  57                		LD	D,A		;D=Command
0990  38 08             		JR  C,	RM_6		;Jump if Alternate (Selection would be correct)
0992  79                		LD	A,C
0993  FE 09             		CP	9
0995  38 03             		JR  C,	RM_6		;Jump if NOT Registers AF,BC,DE or HL
0997  D6 08             		SUB	8		;Subtract 8 to convert AF' to AF, etc
0999  4F                		LD	C,A
099A  7A                RM_6		LD	A,D		;RESUME Decoding command line
099B  FE 0D             		CP	CR		;if CR, dump Register
099D  28 0B             		JR  Z,	RM_DUMP_REG_C
099F  FE 3D             		CP	'='		;if '=', then Assign new value to Register
09A1  20 E3             		JR  NZ,	RM_ERR

09A3  CD 790D           		CALL	GET_WORD	;DE = Word from Command
09A6  79                		LD	A,C
09A7  CD 820C           		CALL	PUT_REGISTER

09AA  79                RM_DUMP_REG_C	LD	A,C
09AB  CD CA0D           RM_DUMP_REG	CALL	PRINTI
09AE  3D00              		DB	'=',0
09B0  CD 6D0C           		CALL	GET_REGISTER
09B3  CD EA0D           		CALL	PUT_HL
09B6  C9                		RET


                        ;=============================================================================
                        ;Loop back test
                        ;-----------------------------------------------------------------------------
09B7  3E 00             LOOP_BACK_TEST	LD	A,0		;Turn off LED update & enable key entry
09B9  CD D427           		CALL	LED_UPDATE

09BC  CD CA0D           		CALL	PRINTI
09BF  0D0A              		DB	CR,LF
09C1  4C4F4F50 20424143 		DB	'LOOP BACK, <Esc>-EXIT',CR,LF,0
09C9  4B2C203C 4573633E
09D1  2D455849 540D0A00
09D9  CD 861C           		CALL	LED_HOME_PRINTI
09DC  4C4F4F50 42414300 		DB	'LOOPBAC',0
09E4  CD 7314           		CALL	LED_HOME
                        		
                        		
09E7  CD 1D14           LOOP_BACK_LP	CALL	IN_CHAR	;Test for any RS-232 input
09EA  38 06             		JR   C,	LB_0	;Jump if no input
09EC  FE 1B             		CP	27	;<Esc> to quit
09EE  28 1F             		JR   Z,	LB_RET
09F0  18 14             		JR	LB_OUT	;Display
                        		
09F2  CD B614           LB_0		CALL 	IC_KEY		;Test regular HEX input
09F5  CA E709           		JP   Z,	LOOP_BACK_LP	;

09F8  CB67              LB_1		BIT	4,A
09FA  28 07             		JR   Z,	LB_2	;Jump if NOT shifted
09FC  F5                		PUSH	AF		;If Shifted, then output a carret before the key
09FD  3E 5E             		LD	A,'^'
09FF  CD E813           		CALL	Put_Char
0A02  F1                		POP	AF

0A03  CD 0F0E           LB_2		CALL	HEX2ASC	;Convert Keypad input to ASCII

0A06  CD E813           LB_OUT		CALL	PUT_CHAR
0A09  4F                		LD	C,A
0A0A  CD 8614           		CALL	PC_LED
0A0D  18 D8             		JR	LOOP_BACK_LP

0A0F  3E 01             LB_RET		LD	A,1
0A11  CD D427           		CALL	LED_UPDATE
0A14  C9                		RET


                        ;=============================================================================
                        ;MEMORY ENTER.  M XXXX YY..YY,  ENTERS AS MANY BYTES AS THERE ARE ON THE LINE.
                        ;-----------------------------------------------------------------------------
0A15  01 0000           MEM_ENTER	LD	BC,0		;Clear count
0A18  CD 790D           MEM_ENTER_NEXTL	CALL	GET_WORD	;DE = Word from console, A=non-hex character following word (space)
0A1B  FE 20             		CP	' '	;Test delimiting character, must be a space
0A1D  C0                		RET 	NZ		;Main Menu
0A1E  EB                		EX	DE,HL		;HL = Start
0A1F  CD 4C0D           MEN_LP		CALL	GET_BYTE	;A = Byte or A=non-hex character (Carry Set)
0A22  38 0B             		JR C,	MEN_CHK		;Jump if non-hex input
0A24  77                		LD	(HL),A		;else, save the byte
0A25  23                		INC	HL		;advance memory pointer
0A26  03                		INC	BC		;count bytes
0A27  18 F6             		JR	MEN_LP		;repeat for next byte input

0A29  CD D613           MEN_RET		CALL	GET_CHAR_NE	;ignore rest of line before returning to main menu
0A2C  CD E813           		CALL	PUT_CHAR
0A2F  FE 0D             MEN_CHK		CP	0x0D		;wait until we get the <CR>
0A31  28 04             		JR Z,	MEN_1
0A33  FE 0A             		CP	0x0A		;wait until we get the <LF>
0A35  20 F2             		JR NZ,	MEN_RET
0A37  3E 04             MEN_1		LD	A,4		;Wait up to 2 seconds for another M command or return to main menu
0A39  CD 4714           		CALL	TIMED_GETCHAR	;
0A3C  CD E813           		CALL	PUT_CHAR
0A3F  FE 4D             		CP	'M'		;If another M command comes in, process it
0A41  28 D5             		JR Z,	MEM_ENTER_NEXTL
0A43  FE 0A             		CP	0x0A		;Skip LF
0A45  28 F0             		JR Z,	MEN_1
0A47  CD CA0D           		CALL	PRINTI
0A4A  0D0A4259 54455320 		DB	CR,LF,"BYTES ENTERED=",EOS
0A52  454E5445 5245443D
0A5A  00
0A5B  CD D80D           		CALL	PUT_BC
0A5E  C9                		RET			;If not, return to main menu prompt


                        ;=============================================================================
                        ;MEMORY DUMP - Continous
                        ;-----------------------------------------------------------------------------
0A5F  06 FF             MEM_DUMP:	LD	B,0xFF		;Continuous Dump, No pausing
0A61  CD 760D           MEM_DUMP_0	CALL	SPACE_GET_WORD	;Input start address
0A64  EB                		EX	DE,HL			;HL = Start
0A65  CD 760D           		CALL	SPACE_GET_WORD	;Input end address (DE = end)

0A68  CD 1F0E           MEM_DUMP_LP:	CALL	PUT_NEW_LINE
0A6B  CD AA0A           		CALL	DUMP_LINE	;Dump 16 byte lines (advances HL)
0A6E  C8                		RET Z			;RETURN WHEN HL=DE
0A6F  CD 1D14           		CALL	IN_CHAR		;Exit on <Esc>
0A72  FE 1B             		CP	27
0A74  C8                		RET	Z
0A75  7D                		LD	A,L
0A76  B0                		OR	B
0A77  20 EF             		JR  NZ,	MEM_DUMP_LP	;Dump 1 Page, then prompt for continue
0A79  CD 820A           		CALL	GET_CONTINUE
0A7C  18 EA             		JR	MEM_DUMP_LP
                        ;=============================================================================
                        ;MEMORY DUMP - Paged
                        ;-----------------------------------------------------------------------------
0A7E  06 00             MEM_DUMP_PAGED	LD	B,0		;Paused Dump
0A80  18 DF             		JR	MEM_DUMP_0

                        ;-----------------------------------------------------------------------------
0A82  CD 1F0E           GET_CONTINUE	CALL	PUT_NEW_LINE
0A85  CD CA0D           		CALL	PRINTI
0A88  50726573 7320616E 		DB	"Press any key to continue",EOS
0A90  79206B65 7920746F
0A98  20636F6E 74696E75
0AA0  6500
0AA2  CD DC13           		CALL	GET_CHAR
0AA5  FE 1B             		CP	27
0AA7  C0                		RET NZ
0AA8  E1                		POP	HL		;Scrap return address
0AA9  C9                		RET


                        ;-----------------------------------------------------------------------------
                        ;DUMP_LINE -- Dumps a line
                        ;xxx0:  <pre spaces> XX XX XX XX XX After spaces | ....ASCII....
                        ;-----------------------------------------------------------------------------
0AAA  C5                DUMP_LINE:	PUSH	BC		;+1
0AAB  E5                		PUSH	HL		;+2 Save H for 2nd part of display
0AAC  E5                		PUSH	HL		;+3 Start line with xxx0 address
0AAD  3E 4D             		LD	A,'M'
0AAF  CD E813           		CALL	Put_Char
0AB2  CD EA0D           		CALL	PUT_HL		;Print Address
0AB5  CD 190E           		CALL	PUT_SPACE
0AB8  E1                		POP	HL		;-3
0AB9  7D                		LD	A,L
0ABA  E6 0F             		AND	0x0F		;Fetch how many prespaces to print
0ABC  4F                		LD	C,A
0ABD  47                		LD	B,A		;Save count of prespaces for part 2 of display
0ABE  CD 110B           		CALL	PUT_3C_SPACES

0AC1  CD 45FB           DL_P1L		CALL	GET_MEM
0AC4  CD F30D           		CALL	SPACE_PUT_BYTE
0AC7  CD 0B0B           		CALL	CP_HL_DE
0ACA  28 08             		JR Z,	DL_P1E
0ACC  23                		INC	HL
0ACD  7D                		LD	A,L
0ACE  E6 0F             		AND	0x0F
0AD0  20 EF             		JR  NZ,	DL_P1L
0AD2  18 08             		JR	DL_P2

0AD4  7D                DL_P1E		LD	A,L
0AD5  2F                		CPL
0AD6  E6 0F             		AND	0x0F
0AD8  4F                		LD	C,A
0AD9  CD 110B           		CALL	PUT_3C_SPACES

0ADC  CD CA0D           DL_P2		CALL	PRINTI		;Print Seperator between part 1 and part 2
0ADF  203B2000          		DB	" ; ",EOS

0AE3  78                DL_PSL2		LD	A,B		;Print prespaces for part 2
0AE4  B7                		OR	A
0AE5  28 06             		JR Z,	DL_PSE2
0AE7  CD 190E           		CALL	PUT_SPACE
0AEA  05                		DEC	B
0AEB  18 F6             		JR	DL_PSL2
0AED                    DL_PSE2
0AED  E1                		POP	HL		;-2
0AEE  C1                		POP	BC		;-1
0AEF  CD 45FB           DL_P2L		CALL	GET_MEM
0AF2  FE 20             		CP	' '		;A - 20h	Test for Valid ASCII characters
0AF4  30 02             		JR NC,	DL_P2K1
0AF6  3E 2E             		LD	A,'.'				;Replace with . if not ASCII
0AF8  FE 7F             DL_P2K1		CP	0x7F		;A - 07Fh
0AFA  38 02             		JR C,	DL_P2K2
0AFC  3E 2E             		LD	A,'.'
0AFE  CD E813           DL_P2K2		CALL	Put_Char

0B01  CD 0B0B           		CALL	CP_HL_DE
0B04  C8                		RET Z
0B05  23                		INC	HL
0B06  7D                		LD	A,L
0B07  E6 0F             		AND	0x0F
0B09  20 E4             		JR  NZ,	DL_P2L

                        ;-----------------------------------------------------------------------------
                        ;Compare HL with DE
                        ;Exit:		Z=1 if HL=DE
                        ;		M=1 if DE > HL
0B0B  7C                CP_HL_DE	LD	A,H
0B0C  BA                		CP	D		;H-D
0B0D  C0                		RET NZ			;M flag set if D > H
0B0E  7D                		LD	A,L
0B0F  BB                		CP	E		;L-E
0B10  C9                		RET


0B11  0C                PUT_3C_SPACES	INC	C		;Print 3C Spaces
0B12  0D                PUT_3C_SPACES_L	DEC	C		;Count down Prespaces
0B13  C8                		RET Z
0B14  CD CA0D           		CALL	PRINTI		;Print pre spaces
0B17  20202000          		DB "   ",EOS
0B1B  18 F5             		JR	PUT_3C_SPACES_L


                        ;-----------------------------------------------------------------------------
                        ;EDIT MEMORY
                        ;Edit memory from a starting address until X is pressed.
                        ;Display mem loc, contents, and results of write.
                        ;-----------------------------------------------------------------------------
0B1D  CD 760D           MEM_EDIT:	CALL	SPACE_GET_WORD	;Input Address
0B20  EB                		EX	DE,HL			;HL = Address to edit
0B21  CD 1F0E           ME_LP		CALL	PUT_NEW_LINE
0B24  CD EA0D           		CALL	PUT_HL		;Print current contents of memory
0B27  CD 190E           		CALL	PUT_SPACE
0B2A  3E 3A             		LD	A, ':'
0B2C  CD E813           		CALL	Put_Char
0B2F  CD 45FB           		CALL	GET_MEM
0B32  CD F30D           		CALL	SPACE_PUT_BYTE
0B35  CD 490D           		CALL	SPACE_GET_BYTE	;Input new value or Exit if invalid
0B38  D8                		RET C			;Exit to Command Loop
0B39  77                		LD	(HL), A		;or Save new value
0B3A  CD 45FB           		CALL	GET_MEM
0B3D  CD F30D           		CALL	SPACE_PUT_BYTE
0B40  23                		INC	HL		;Advance to next location
0B41  18 DE             		JR	ME_LP		;repeat input


                        ;=============================================================================
                        ;	MEM_EXEC - Execute at
                        ;	Get an address and jump to it
                        ;-----------------------------------------------------------------------------
0B43  CD 760D           MEM_EXEC:	CALL	SPACE_GET_WORD	;Input address
0B46  D2 5D0B           		JP NC,	ME_1		;Jump if no hex input
0B49  FE 1B             		CP	27
0B4B  C8                		RET Z			;Exit if <ESC> pressed
0B4C  ED53 A0FF         		LD	(RPC),DE

0B50  CD CA0D           		CALL	PRINTI
0B53  2050433D 00       		DB	' PC=',EOS
0B58  CD E10D           		CALL	PUT_DE
0B5B  18 03             		JR	GO_EXEC_T

0B5D  FE 0D             ME_1		CP	13		;No hex input (user just typed G and something not HEX)
0B5F  C0                		RET NZ			;Exit if NOT <CR> pressed
                        		
0B60  2A 96FF           GO_EXEC_T	LD	HL,(RSSP)	;20 Fetch SP
0B63  2B                		DEC	HL
0B64  2B                		DEC	HL
0B65  3E AA             		LD	A,0xAA
0B67  77                		LD	(HL),A
0B68  BE                		CP	(HL)
0B69  20 70             		JR NZ,	GE_STACKFAIL
0B6B  2F                		CPL
0B6C  77                		LD	(HL),A
0B6D  BE                		CP	(HL)
0B6E  20 6B             		JR NZ,	GE_STACKFAIL

0B70  F3                		DI			;
0B71  3E 82             GO_EXEC		LD	A,0x82		;7  (ANBAR_DEF) = RUN MODE
0B73  32 B3FF           		LD	(ANBAR_DEF),A	;13
0B76  21 7C0C           		LD	HL,GET_REG_RUN	;10
0B79  22 B4FF           		LD	(GET_REG),HL	;16
0B7C  21 910C           		LD	HL,PUT_REG_RUN	;10
0B7F  22 B6FF           		LD	(PUT_REG),HL	;16
0B82  21 1318           		LD	HL,CTRL_C_TEST	;10
0B85  22 B8FF           		LD	(CTRL_C_CHK),HL	;16
                        		
0B88  3A B3FF           		LD	A,(ANBAR_DEF)	;13 Refresh Display
0B8B  32 E7FF           		LD	(LED_ANBAR),A	;13
                        					;\\\ 124

0B8E  08                		EX	AF,AF'		;4  Fetch Alternate register set
0B8F  31 A8FF           		LD	SP,RSAF2	;10 Set Stack to get register AF'
0B92  F1                		POP	AF		;10
0B93  08                		EX	AF,AF'		;4
0B94  D9                		EXX			;4  Fetch Alternate register set
0B95  ED4B AAFF         		LD	BC,(RSBC2)	;20
0B99  ED5B ACFF         		LD	DE,(RSDE2)	;20
0B9D  2A AEFF           		LD	HL,(RSHL2)	;20
0BA0  D9                		EXX			;4

0BA1  ED4B A6FF         		LD	BC,(RSIR)	;20 Fetch IR
0BA5  79                		LD	A,C		;4
0BA6  ED4F              		LD	R,A		;9
0BA8  78                		LD	A,B		;4
0BA9  ED47              		LD	I,A		;9
                        					;\\\ 142
                        					
0BAB  3E C3             		LD	A,0xC3		;7  Set Jump instruction
0BAD  32 53FB           		LD	(HR_EXE_GO),A	;13
0BB0  2A A0FF           		LD	HL,(RPC)	;16 Fetch PC
0BB3  22 54FB           		LD	(HR_EXE_GO+1),HL;16

0BB6  31 98FF           		LD	SP,RSAF		;10 Set Stack to Fetch register AF
0BB9  F1                		POP	AF		;10

0BBA  ED7B 96FF         		LD	SP,(RSSP)	;20 Fetch SP
0BBE  33                		INC	SP		;6
0BBF  33                		INC	SP		;6
0BC0  21 0000           		LD	HL,0		;10 Set Default return address as 0000 (Restart/Save Registers)
0BC3  E5                		PUSH	HL		;11   & Put on stack
                        					;\\\ 125
                        		
0BC4  ED4B 9AFF         		LD	BC,(RSBC)	;20
0BC8  ED5B 9CFF         		LD	DE,(RSDE)	;20
0BCC  2A 9EFF           		LD	HL,(RSHL)	;20
0BCF  DD2A A2FF         		LD	IX,(RSIX)	;20
0BD3  FD2A A4FF         		LD	IY,(RSIY)	;20

0BD7  FB                		EI			;4
0BD8  C3 53FB           		JP	HR_EXE_GO	;10 PC=(STACK)
                        		
                        ;HR_EXE_GO	JP	(RSPC)		;10 Final jump to code
                        					;\\\ 124
                        					;Total = 515

0BDB  CD CA0D           GE_STACKFAIL	CALL	PRINTI
0BDE  20535441 434B204E 		DB	' STACK NOT IN RAM',EOS
0BE6  4F542049 4E205241
0BEE  4D00
0BF0  CD 861C           		CALL	LED_HOME_PRINTI
0BF3  53502045 52522000 		DB	'SP ERR ',EOS
0BFB  C9                		RET
                        		

                        ;===============================================
                        ;Input from port, print contents
0BFC  CD 490D           PORT_INP:	CALL	SPACE_GET_BYTE
0BFF  4F                		LD	C, A
0C00  ED78              		IN	A,(C)
0C02  CD F30D           		CALL	SPACE_PUT_BYTE
0C05  C9                		RET

                        ;Get a port address, write byte out
0C06  CD 490D           PORT_OUT:	CALL	SPACE_GET_BYTE
0C09  4F                		LD	C, A
0C0A  CD 490D           		CALL	SPACE_GET_BYTE
0C0D  ED79              		OUT	(C),A
0C0F  C9                		RET



                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_5	Supporting routines. GET_BYTE, GET_WORD, PUT_BYTE, PUT_WORD
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;


0C10  36 00             CLEAR_BLOCK	LD	(HL),0
0C12  23                		INC	HL
0C13  10 FB             		DJNZ	CLEAR_BLOCK
0C15  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
                        ;	FILL_BLOCK, Fills a block of RAM with value in A
                        ;	Input:	A = value
                        ;		HL = Start Address
                        ;		B = Length of Fill (MAX = 0 = 256 bytes)
                        ;-----------------------------------------------------------------------------------------------------
0C16  E5                FILL_BLOCK	PUSH	HL
0C17  77                FB_LP		LD	(HL),A
0C18  23                		INC	HL
0C19  10 FC             		DJNZ	FB_LP
0C1B  E1                		POP	HL
0C1C  C9                		RET
                        					;Critical Timing in effect for GO_EXEC
0C1D  E3                WRITE_BLOCK	EX	(SP),HL		;19 HL=PC Total = 137 + 21 * BC
0C1E  D5                		PUSH	DE		;11
0C1F  C5                		PUSH	BC		;11
0C20  5E                		LD	E,(HL)		;7
0C21  23                		INC	HL		;6
0C22  56                		LD	D,(HL)		;7
0C23  23                		INC	HL		;6
0C24  4E                		LD	C,(HL)		;7
0C25  23                		INC	HL		;6
0C26  46                		LD	B,(HL)		;7
0C27  23                		INC	HL		;6
0C28  EDB0              		LDIR			;21/16  21*BC-5
0C2A  C1                		POP	BC		;10
0C2B  D1                		POP	DE		;10
0C2C  E3                		EX	(SP),HL		;19 PC=HL
0C2D  C9                		RET			;10
                        		
0C2E  F5                GET_REGNAME	PUSH	AF
0C2F  07                		RLCA
0C30  07                		RLCA
0C31  21 390C           		LD	HL,REGNAMES
0C34  CD 450E           		CALL	ADD_HL_A
0C37  F1                		POP	AF
0C38  C9                		RET

0C39  53502000          REGNAMES	DB	'SP ',0		;0
0C3D  41462000          		DB	'AF ',0		;1
0C41  42432000          		DB	'BC ',0		;2
0C45  44452000          		DB	'DE ',0		;3
0C49  484C2000          		DB	'HL ',0		;4
0C4D  50432000          		DB	'PC ',0		;5
0C51  49582000          		DB	'IX ',0		;6
0C55  49592000          		DB	'IY ',0		;7
0C59  49522000          		DB	'IR ',0		;8
0C5D  41462700          		DB	'AF',0x27,0	;9
0C61  42432700          		DB	'BC',0x27,0	;10
0C65  44452700          		DB	'DE',0x27,0	;11
0C69  484C2700          		DB	'HL',0x27,0	;12

0C6D  2A B4FF           GET_REGISTER	LD	HL,(GET_REG)	;16
0C70  E9                		JP	(HL)		;4

0C71  21 96FF           GET_REG_MON	LD	HL,RSSP		;
0C74  07                		RLCA
0C75  CD 450E           		CALL	ADD_HL_A	;17+18 HL=Where to find Register
0C78  CD 4A0E           		CALL	LD_HL_HL	;HL=(HL)
0C7B  C9                		RET

0C7C  21 A10C           GET_REG_RUN	LD	HL,GRR_TBL	;10
0C7F  C3 940C           		JP	SHORTNWAY	;10

0C82  2A B6FF           PUT_REGISTER	LD	HL,(PUT_REG)
0C85  E9                		JP	(HL)

0C86  21 96FF           PUT_REG_MON	LD	HL,RSSP
0C89  07                		RLCA
0C8A  CD 450E           		CALL	ADD_HL_A	;HL=Where to find Register
0C8D  73                PURRS_RET	LD	(HL),E
0C8E  23                		INC	HL
0C8F  72                		LD	(HL),D
0C90  C9                		RET

0C91  21 B10C           PUT_REG_RUN	LD	HL,PURR_TBL
                        					;40 to get here
0C94  E6 0F             SHORTNWAY	AND	0xF		;7
0C96  CD 450E           		CALL	ADD_HL_A	;14+18
0C99  7E                		LD	A,(HL)		;7
0C9A  21 C10C           		LD	HL,GRR_SUB	;10
0C9D  CD 450E           		CALL	ADD_HL_A	;17+18
0CA0  E9                VCALL_HL	JP	(HL)		;4  st=138

0CA1  00                GRR_TBL		DB	0
0CA2  06                		DB	GRR_SUB_AF - GRR_SUB
0CA3  0E                		DB	GRR_SUB_BC - GRR_SUB
0CA4  11                		DB	GRR_SUB_DE - GRR_SUB
0CA5  14                		DB	GRR_SUB_HL - GRR_SUB
0CA6  1C                		DB	GRR_SUB_PC - GRR_SUB
0CA7  23                		DB	GRR_SUB_IX - GRR_SUB
0CA8  27                		DB	GRR_SUB_IY - GRR_SUB
0CA9  2B                		DB	GRR_SUB_IR - GRR_SUB
0CAA  32                		DB	GRR_SUB_AFA - GRR_SUB
0CAB  37                		DB	GRR_SUB_BCA - GRR_SUB
0CAC  3C                		DB	GRR_SUB_DEA - GRR_SUB
0CAD  41                		DB	GRR_SUB_HLA - GRR_SUB
0CAE  00                		DB	0
0CAF  00                		DB	0
0CB0  00                		DB	0

0CB1  46                PURR_TBL	DB	PURR_SUB_SP - GRR_SUB
0CB2  47                		DB	PURR_SUB_AF - GRR_SUB
0CB3  4E                		DB	PURR_SUB_BC - GRR_SUB
0CB4  51                		DB	PURR_SUB_DE - GRR_SUB
0CB5  58                		DB	PURR_SUB_HL - GRR_SUB
0CB6  5F                		DB	PURR_SUB_PC - GRR_SUB
0CB7  65                		DB	PURR_SUB_IX - GRR_SUB
0CB8  69                		DB	PURR_SUB_IY - GRR_SUB
0CB9  6D                		DB	PURR_SUB_IR - GRR_SUB
0CBA  74                		DB	PURR_SUB_AFA - GRR_SUB
0CBB  79                		DB	PURR_SUB_BCA - GRR_SUB
0CBC  7E                		DB	PURR_SUB_DEA - GRR_SUB
0CBD  83                		DB	PURR_SUB_HLA - GRR_SUB
0CBE  00                		DB	0
0CBF  00                		DB	0
0CC0  00                		DB	0

                        		;Stack holds:
                        		;SP	RETURN TO ISR	(CALL PUT_REG)
                        		;SP+2	RETURN TO VECTOR DISPATCH (CALL VCALL_HL)
                        		;SP+4	AF
                        		;SP+6	HL
                        		;
                        		;PREVIOUS STACK SAVED AT SP_ISR_SAVE
                        		;	RETURN TO MAIN CODE (PC)
                        		;
                        		
0CC1  2A 28FB           GRR_SUB		LD	HL,(SP_ISR_SAVE)	;Get SP;True value of SP (prior to ISR)
0CC4  23                		INC	HL
0CC5  23                		INC	HL
0CC6  C9                		RET
0CC7  21 0400           GRR_SUB_AF	LD	HL,4		;Get AF
0CCA  39                		ADD	HL,SP
0CCB  CD 4A0E           		CALL	LD_HL_HL	;HL=(HL)
0CCE  C9                		RET
0CCF  C5                GRR_SUB_BC	PUSH	BC
0CD0  E1                		POP	HL
0CD1  C9                		RET
0CD2  D5                GRR_SUB_DE	PUSH	DE
0CD3  E1                		POP	HL
0CD4  C9                		RET
0CD5  21 0600           GRR_SUB_HL	LD	HL,6		;Get HL
0CD8  39                		ADD	HL,SP
0CD9  CD 4A0E           		CALL	LD_HL_HL	;HL=(HL)
0CDC  C9                		RET
0CDD  2A 28FB           GRR_SUB_PC	LD	HL,(SP_ISR_SAVE) ;Get PC
0CE0  CD 4A0E           		CALL	LD_HL_HL	;HL=(HL)
0CE3  C9                		RET
0CE4  DDE5              GRR_SUB_IX	PUSH	IX
0CE6  E1                		POP	HL
0CE7  C9                		RET
0CE8  FDE5              GRR_SUB_IY	PUSH	IY
0CEA  E1                		POP	HL
0CEB  C9                		RET
0CEC  ED57              GRR_SUB_IR	LD	A,I
0CEE  67                		LD	H,A
0CEF  ED5F              		LD	A,R
0CF1  6F                		LD	L,A
0CF2  C9                		RET
0CF3  08                GRR_SUB_AFA	EX	AF,AF'
0CF4  F5                		PUSH	AF
0CF5  08                		EX	AF,AF'
0CF6  E1                		POP	HL
0CF7  C9                		RET
0CF8  D9                GRR_SUB_BCA	EXX
0CF9  C5                		PUSH	BC
0CFA  D9                		EXX
0CFB  E1                		POP	HL
0CFC  C9                		RET
0CFD  D9                GRR_SUB_DEA	EXX
0CFE  D5                		PUSH	DE
0CFF  D9                		EXX
0D00  E1                		POP	HL
0D01  C9                		RET
0D02  D9                GRR_SUB_HLA	EXX
0D03  E5                		PUSH	HL
0D04  D9                		EXX
0D05  E1                		POP	HL
0D06  C9                		RET


                        		;SP	RETURN TO ISR
                        		;SP+2	DE
                        		;SP+4	RETURN TO VECTOR DISPATCH (CALL VCALL_HL)
                        		;SP+6	RRSTATE
                        		;SP+8	AF
                        		;SP+10	HL
                        		;PREVIOUS STACK SAVED AT SP_ISR_SAVE
                        		;	RETURN TO MAIN CODE (PC)

0D07  C9                PURR_SUB_SP	RET		;Do we really want to change the SP during RUN mode??? Suicide!
0D08  21 0800           PURR_SUB_AF	LD	HL,8		;Get DE
0D0B  39                		ADD	HL,SP
0D0C  C3 8D0C           		JP	PURRS_RET
0D0F  D5                PURR_SUB_BC	PUSH	DE
0D10  C1                		POP	BC
0D11  C9                		RET
0D12  21 0200           PURR_SUB_DE	LD	HL,2		;10 Get DE
0D15  39                		ADD	HL,SP		;11
0D16  C3 8D0C           		JP	PURRS_RET	;10  st=31
0D19  21 0A00           PURR_SUB_HL	LD	HL,10		;Get HL
0D1C  39                		ADD	HL,SP
0D1D  C3 8D0C           		JP	PURRS_RET
0D20  2A 28FB           PURR_SUB_PC	LD	HL,(SP_ISR_SAVE) ;Get PC
0D23  C3 8D0C           		JP	PURRS_RET
0D26  D5                PURR_SUB_IX	PUSH	DE
0D27  DDE1              		POP	IX
0D29  C9                		RET
0D2A  D5                PURR_SUB_IY	PUSH	DE
0D2B  FDE1              		POP	IY
0D2D  C9                		RET
0D2E  7A                PURR_SUB_IR	LD	A,D
0D2F  ED47              		LD	I,A
0D31  7B                		LD	A,E
0D32  ED4F              		LD	R,A
0D34  C9                		RET
0D35  D5                PURR_SUB_AFA	PUSH	DE
0D36  08                		EX	AF,AF'
0D37  F1                		POP	AF
0D38  08                		EX	AF,AF'
0D39  C9                		RET
0D3A  D5                PURR_SUB_BCA	PUSH	DE
0D3B  D9                		EXX
0D3C  C1                		POP	BC
0D3D  D9                		EXX
0D3E  C9                		RET
0D3F  D5                PURR_SUB_DEA	PUSH	DE
0D40  D9                		EXX
0D41  D1                		POP	DE
0D42  D9                		EXX
0D43  C9                		RET
0D44  D5                PURR_SUB_HLA	PUSH	DE
0D45  D9                		EXX
0D46  E1                		POP	HL
0D47  D9                		EXX
0D48  C9                		RET


                        ;=============================================================================
0D49  CD 190E           SPACE_GET_BYTE	CALL	PUT_SPACE

                        ;=============================================================================
                        ;GET_BYTE -- Get byte from console as hex
                        ;
                        ;in:	Nothing
                        ;out:	A = Byte (if CY=0)  (last 2 hex characters)  Exit if Space Entered
                        ;	A = non-hex char input (if CY=1)
                        ;-----------------------------------------------------------------------------
0D4C  CD 950D           GET_BYTE:	CALL	GET_HEX	;Get 1st HEX CHAR
0D4F  30 06             		JR  NC,	GB_1
0D51  FE 20             		CP	' '		;Exit if not HEX CHAR (ignoring SPACE)
0D53  28 F7             		JR Z,	GET_BYTE	;Loop back if first char is a SPACE
0D55  37                		SCF			;Set Carry
0D56  C9                		RET			;or EXIT with delimiting char
0D57  D5                GB_1		PUSH	DE		;Process 1st HEX CHAR
0D58  07                		RLCA
0D59  07                		RLCA
0D5A  07                		RLCA
0D5B  07                		RLCA
0D5C  E6 F0             		AND	0xF0
0D5E  57                		LD	D,A
0D5F  CD 950D           		CALL	GET_HEX
0D62  30 07             		JR  NC,	GB_2		;If 2nd char is HEX CHAR
0D64  FE 20             		CP	' '
0D66  28 06             		JR Z,	GB_RET1
0D68  37                		SCF			;Set Carry
0D69  D1                		POP	DE
0D6A  C9                		RET			;or EXIT with delimiting char
0D6B  B2                GB_2		OR	D
0D6C  D1                		POP	DE
0D6D  C9                		RET
0D6E  7A                GB_RET1		LD	A,D
0D6F  0F                		RRCA
0D70  0F                		RRCA
0D71  0F                		RRCA
0D72  0F                		RRCA
0D73  B7                GB_RET		OR	A
0D74  D1                		POP	DE
0D75  C9                		RET


                        ;=============================================================================
0D76  CD 190E           SPACE_GET_WORD	CALL	PUT_SPACE

                        ;=============================================================================
                        ;GET_WORD -- Get word from console as hex (ignores initial spaces)
                        ;
                        ;in:	Nothing
                        ;out:	c=1	A = non-hex char input (Typically Space, CR or ESC)
                        ;		DE = Word
                        ;out:	c=0	A = non-hex char input (No Word in DE)
                        ;-----------------------------------------------------------------------------
0D79  11 0000           GET_WORD:	LD	DE,0
0D7C  CD 950D           		CALL	GET_HEX	;Get 1st HEX CHAR ;out:	A = Value of HEX Char when CY=0
                        							;	A = Received (non-hex) char when CY=1
0D7F  30 06             		JR  NC,	GW_LP
0D81  FE 20             		CP	' '		;Exit if not HEX CHAR (ignoring SPACE)
0D83  28 F4             		JR Z,	GET_WORD	;Loop back if first char is a SPACE
0D85  B7                		OR	A		;Clear Carry
0D86  C9                		RET			;or EXIT with delimiting char
0D87  5F                GW_LP		LD	E,A		;Save first/combined char in E
0D88  CD 950D           		CALL	GET_HEX	;Get next char
0D8B  D8                		RET C			;EXIT when a delimiting char is entered
0D8C  EB                		EX	DE,HL		;Else, shift new HEX Char Value into DE
0D8D  29                		ADD	HL,HL		;Shift DE up 1 nibble
0D8E  29                		ADD	HL,HL
0D8F  29                		ADD	HL,HL
0D90  29                		ADD	HL,HL
0D91  EB                		EX	DE,HL
0D92  B3                		OR	E		;Combine new char with E
0D93  18 F2             		JR	GW_LP



                        ;===============================================
                        ;Get HEX CHAR
                        ;in:	Nothing
                        ;out:	A = Value of HEX Char when CY=0
                        ;	A = Received (non-hex) char when CY=1
                        ;-----------------------------------------------
0D95  CD DC13           GET_HEX:	CALL	GET_CHAR
                        		
                        ;in:	A = CHAR
                        ;out:	A = Value of HEX Char when CY=0
                        ;	A = Received (non-hex) char when CY=1
0D98  FE 30             ASC2HEX		CP	'0'
0D9A  FA B60D           		JP M,	GHC_NOT_RET
0D9D  FE 3A             		CP	'9'+1
0D9F  FA BA0D           		JP M,	GHC_NRET
0DA2  FE 41             		CP	'A'
0DA4  FA B60D           		JP M,	GHC_NOT_RET
0DA7  FE 47             		CP	'F'+1
0DA9  FA B80D           		JP M,	GHC_ARET
0DAC  FE 61             		CP	'a'
0DAE  FA B60D           		JP M,	GHC_NOT_RET
0DB1  FE 67             		CP	'f'+1
0DB3  FA B80D           		JP M,	GHC_ARET
0DB6  37                GHC_NOT_RET	SCF
0DB7  C9                		RET
0DB8  D6 07             GHC_ARET	SUB	07h
0DBA  E6 0F             GHC_NRET	AND	0Fh
0DBC  C9                		RET
                        		

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;PRINT -- Print A null-terminated string @(HL)
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0DBD  F5                PRINT:		PUSH	AF
0DBE  7E                PRINT_LP	LD	A, (HL)
0DBF  23                		INC	HL
0DC0  B7                		OR	A
0DC1  28 05             		JR Z,	PRINT_RET
0DC3  CD E813           		CALL	Put_Char
0DC6  18 F6             		JR	PRINT_LP
0DC8  F1                PRINT_RET	POP	AF
0DC9  C9                		RET

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;PRINT IMMEDIATE
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0DCA  E3                PRINTI:		EX	(SP),HL	;HL = Top of Stack
0DCB  CD BD0D           		CALL	PRINT
0DCE  E3                		EX	(SP),HL	;Move updated return address back to stack
0DCF  C9                		RET

                        ;===============================================
                        ;PRINT B-LENGTH
                        ;-----------------------------------------------
0DD0  7E                PRINTB:		LD	A, (HL)
0DD1  CD E813           		CALL	PUT_CHAR
0DD4  23                		INC	HL
0DD5  10 F9             		DJNZ	PRINTB
0DD7  C9                		RET

                        ;===============================================
                        ;PUT_BC Prints BC Word
                        ;-----------------------------------------------
0DD8  78                PUT_BC:		LD	A, B
0DD9  CD F60D           		CALL	PUT_BYTE
0DDC  79                		LD	A, C
0DDD  CD F60D           		CALL	PUT_BYTE
0DE0  C9                		RET

                        ;===============================================
                        ;PUT_DE Prints DE Word
                        ;-----------------------------------------------
0DE1  7A                PUT_DE:		LD	A, D
0DE2  CD F60D           		CALL	PUT_BYTE
0DE5  7B                		LD	A, E
0DE6  CD F60D           		CALL	PUT_BYTE
0DE9  C9                		RET

                        ;===============================================
                        ;PUT_HL Prints HL Word
                        ;-----------------------------------------------
0DEA  7C                PUT_HL:		LD	A, H
0DEB  CD F60D           		CALL	PUT_BYTE
0DEE  7D                		LD	A, L
0DEF  CD F60D           		CALL	PUT_BYTE
0DF2  C9                		RET


                        ;===============================================
                        ;SPACE_PUT_BYTE -- Output (SPACE) & byte to console as hex
                        ;
                        ;pre:	A register contains byte to be output
                        ;post:	Destroys A
                        ;-----------------------------------------------
0DF3  CD 190E           SPACE_PUT_BYTE	CALL	PUT_SPACE
                        		
                        ;===============================================
                        ;PUT_BYTE -- Output byte to console as hex
                        ;
                        ;pre:	A register contains byte to be output
                        ;-----------------------------------------------
0DF6  F5                PUT_BYTE:	PUSH	AF
0DF7  F5                		PUSH	AF
0DF8  0F                		RRCA
0DF9  0F                		RRCA
0DFA  0F                		RRCA
0DFB  0F                		RRCA
0DFC  E6 0F             		AND	0x0F
0DFE  CD 090E           		CALL	PUT_HEX
0E01  F1                		POP	AF
0E02  E6 0F             		AND	0x0F
0E04  CD 090E           		CALL	PUT_HEX
0E07  F1                		POP	AF
0E08  C9                		RET

                        ;===============================================
                        ;PUT_HEX -- Convert nibble to ASCII char
                        ;-----------------------------------------------
0E09  CD 0F0E           PUT_HEX:	CALL	HEX2ASC
0E0C  C3 E813           		JP	Put_Char

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;HEX2ASC - Convert nibble to ASCII char
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0E0F  E6 0F             HEX2ASC:	AND	0xF
0E11  C6 30             		ADD	A,0x30
0E13  FE 3A             		CP	0x3A
0E15  D8                		RET C
0E16  C6 07             		ADD	A,0x7
0E18  C9                		RET


                        ;===============================================
                        ;PUT_SPACE -- Print a space to the console
                        ;
                        ;pre: none
                        ;post: 0x20 printed to console
                        ;-----------------------------------------------
0E19  CD CA0D           PUT_SPACE:	CALL	PRINTI
0E1C  2000              		DB	' ',EOS
0E1E  C9                		RET

                        ;===============================================
                        ;PUT_NEW_LINE -- Start a new line on the console
                        ;
                        ;pre: none
                        ;post:
                        ;-----------------------------------------------
0E1F  CD CA0D           PUT_NEW_LINE:	CALL	PRINTI
0E22  0D0A00            		DB	CR,LF,EOS
0E25  C9                		RET

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Terminal Increment byte at (HL).  Do not pass 0xFF
0E26  34                TINC:		INC	(HL)
0E27  C0                		RET	NZ
0E28  35                		DEC	(HL)
0E29  C9                		RET

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0E2A  0E 01             DELAY_100mS	LD	C,1
0E2C  C5                DELAY_C		PUSH	BC
0E2D  06 00             		LD	B,0
0E2F  C5                DELAY_LP	PUSH	BC
0E30  10 FE             		DJNZ	$		;13   * 256 / 4 = 832uSec
0E32  C1                		POP	BC
0E33  10 FA             		DJNZ	DELAY_LP	;~100mSEC
0E35  0D                		DEC	C
0E36  20 F7             		JR  NZ,	DELAY_LP	;*4 ~= 7mSec
0E38  C1                		POP	BC
0E39  C9                		RET

                        ;============================================================================
                        ;	Subroutine	Delay_A
                        ;
                        ;	Entry:	A = Millisecond count
                        ;============================================================================
0E3A  E5                DELAY_A:	PUSH	HL			; Save count
0E3B  21 F0FF           		LD	HL,TicCounter
0E3E  86                		ADD	A,(HL)			; A = cycle count
0E3F  BE                DlyLp		CP	(HL)			; Wait required TicCounter times
0E40  C2 3F0E           		JP	NZ,DlyLp		;  loop if not done
0E43  E1                		POP	HL
0E44  C9                		RET


                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0E45  85                ADD_HL_A	ADD	A,L		;4
0E46  6F                		LD	L,A		;4
0E47  D0                		RET NC			;10
0E48  24                		INC	H
0E49  C9                		RET

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0E4A  7E                LD_HL_HL	LD      A,(HL)		;7
0E4B  23                		INC     HL		;6
0E4C  66                		LD      H,(HL)		;7
0E4D  6F                		LD      L,A		;4
0E4E  C9                		RET			;10




                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_6	Menu operations. ASCII HEXFILE TRANSFER
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;----------------------------------------------------------------------------------------------------; ASCII HEXFILE TRANSFER
0E4F  CD CA0D           GETHEXFILE	CALL	PRINTI
0E52  0D0A5741 4954494E 		DB	CR,LF,"WAITING FOR HEX TRANSFER",EOS
0E5A  4720464F 52204845
0E62  58205452 414E5346
0E6A  455200

0E6D  21 C30E           		LD	HL,READ_SERIAL	;Set Serial Port as the source for the hex file
0E70  22 5BFF           		LD	(HEX_SOURCE),HL
0E73  21 0CFF           		LD	HL,VIEW_FLAGS	;Clear BIT .0= No View HEX Load
0E76  CB86              		RES	0,(HL)
0E78  CD EF1E           		CALL	READ_HEX_FILE	;CY=1 ERROR encountered,  Z=0 Time Out
0E7B  20 2B             		JR  NZ,	GHENDTO
0E7D  D8                		RET	C		;If Error, exit without displaying "Complete" message
                        		
0E7E  CD CA0D           		CALL	PRINTI
0E81  0D0A4845 58205452 		DB	CR,LF,"HEX TRANSFER COMPLETE, LINES=",EOS
0E89  414E5346 45522043
0E91  4F4D504C 4554452C
0E99  204C494E 45533D00
0EA1  2A 8AFA           		LD	HL,(RHF_LINES)
0EA4  CD EA0D           		CALL	PUT_HL
0EA7  C9                		RET

0EA8  CD CA0D           GHENDTO		CALL	PRINTI
0EAB  0D0A4845 58205452 		DB	CR,LF,"HEX TRANSFER TIMEOUT",EOS
0EB3  414E5346 45522054
0EBB  494D454F 555400
0EC2  C9                		RET

                        		;FILL LINE_BUFF WITH A SINGLE LINE FROM SERIAL PORT
                        		;RETURN Z=0 IF TIMED OUT (RET NZ)		
0EC3  CD B51E           READ_SERIAL	CALL	CLEAR_LINE_BUFF

0EC6  21 00FA           		LD	HL, LINE_BUFF	;Data desination @HL
0EC9  06 02             RS_CLP		LD	B,2		;Enable ':' search for 1st char
                        		
0ECB  3E 75             RS_LP		LD	A,117		;20 Second Timeout for Get char
0ECD  CD 4714           		CALL	TIMED_GETCHAR
0ED0  38 19             		JR  C, 	RS_TIMEOUT
0ED2  FE 1B             		CP	27
0ED4  28 15             		JR  Z,	RS_TIMEOUT

0ED6  FE 3A             		CP	':'
0ED8  28 02             		JR  Z,	RS_COK
0EDA  10 ED             		DJNZ	RS_CLP
                        		
0EDC  06 01             RS_COK		LD	B,1		;Disable ':' search
0EDE  77                		LD	(HL),A
0EDF  FE 0D             		CP	CR		;Test for CR
0EE1  C8                		RET	Z			
0EE2  FE 0A             		CP	LF		;Test if LF
0EE4  C8                		RET	Z

0EE5  23                		INC	HL		
0EE6  7D                		LD	A,L
0EE7  FE 80             		CP	LOW LINE_BUFFEND
0EE9  20 E0             		JR  NZ,	RS_LP
                        		
0EEB  AF                RS_TIMEOUT	XOR	A	;C=0,Z=1
0EEC  3D                		DEC	A	;Z=0
0EED  C9                		RET





                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_7	Menu operations. XMODEM FILE TRANSFER
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;----------------------------------------------------------------------------------------------------; XMODEM ROUTINES

      = 0001            SOH	equ	1	;Start of Header
      = 0004            EOT	equ	4	;End of Transmission
      = 0006            ACK	equ	6
      = 0010            DLE	equ	16
      = 0011            DC1	equ	17	; (X-ON)
      = 0013            DC3	equ	19	; (X-OFF)
      = 0015            NAK	equ	21
                        ;SYN	equ	22
      = 0018            CAN	equ	24	;(Cancel)

                        ;---------------------------------------------------------------------------------
                        ;XMODEM MENU
                        ;ENTRY:	TOP OF LDCK HOLDS RETURN ADDRESS (EXIT MECHANDSM IF XMODEM IS CANCELLED)
                        ;---------------------------------------------------------------------------------
0EEE  CD 190E           XMODEM		CALL	PUT_SPACE
0EF1  CD DC13           		CALL	GET_CHAR	;get char
0EF4  E6 5F             		AND	0x5F		;to upper case
0EF6  FE 44             		CP	'D'
0EF8  28 0A             		JR Z,	XMDN		; D = DOWNLOAD (from memory to serial port)
0EFA  FE 55             		CP	'U'
0EFC  28 21             		JR Z,	XMUP		; U = UPLOAD (to memory from serial port)
0EFE  CD CA0D           		CALL 	PRINTI
0F01  3F00              		DB	"?",EOS
0F03  C9                		RET

                        ;---------------------------------------------------------------------------------
                        ;XMDN - XMODEM DOWNLOAD (send file from IMSAI to Terminal)
                        ;INPUT STARTING ADDRESS AND COUNT OF BLOCKS (WORD)
                        ;WAIT FOR 'C' OR NAK FROM HOST TO START CRC/CS TRANSFER
                        ;---------------------------------------------------------------------------------
0F04  CD 760D           XMDN		CALL	SPACE_GET_WORD	;Input Address
0F07  EB                		EX	DE,HL		;HL = Address to SAVE DATA
0F08  CD 760D           		CALL	SPACE_GET_WORD	;Input #Blocks to Send
                        					;DE = Count of Blocks

0F0B  7A                		LD	A,D
0F0C  B3                		OR	E
0F0D  C8                		RET Z			;Exit if Block Count = 0

                        	;HL = Address of data to send from the IMSAI 8080
                        	;DE = Count of Blocks to send.

0F0E  CD 2E0F           		CALL	XMS_INIT	;Starts the Seq, Sets the CS/CRC format
                        					;Cancelled Transfers will cause a RET

0F11  CD 520F           XMDN_LP		CALL	XMS_SEND	;Sends the packet @HL, Resends if NAK
                        					;Cancelled Transfers will cause a RET
0F14  1B                		DEC	DE
0F15  7A                		LD	A,D
0F16  B3                		OR	E
0F17  20 F8             		JR  NZ,	XMDN_LP

0F19  CD A60F           		CALL	XMS_EOT		;Send End of Transmission
0F1C  C3 2614           		JP	PURGE


                        ;---------------------------------------------------------------------------------
                        ;XMUP - XMODEM UPLOAD (receive file from Terminal to IMSAI 8080)
                        ;INPUT STARTING ADDRESS
                        ;SEND 'C' OR NAK TO HOST TO START CRC/CS TRANSFER
                        ;---------------------------------------------------------------------------------
0F1F  CD 760D           XMUP		CALL	SPACE_GET_WORD	;Input Address
0F22  EB                		EX	DE,HL		;HL = Address to SAVE DATA

                        	;HL = Address of data to send from the IMSAI 8080

0F23  CD FC0F           		CALL	XMR_INIT	;Starts the transfer & Receives first PACKET
                        					;Cancelled Transfers will cause a RET

0F26  CD 3110           XMUP_LP		CALL	XMR_RECV	;Receives the next packet @HL, Resends if NAK
                        					;Cancelled Transfers will cause a RET
0F29  38 FB             		JR C,	XMUP_LP		;Jump until EOT Received
0F2B  C3 2614           		JP	PURGE



                        ;---------------------------------------------------------------------------------
                        ;INIT FOR SENDING XMODEM PROTOCOL, GET NAK OR 'C', SAVE THE XMTYPE
                        ;---------------------------------------------------------------------------------
0F2E  3E 01             XMS_INIT	LD	A,1		;First SEQ number
0F30  32 F3FF           		LD	(XMSEQ),A

0F33  06 21             		LD	B,33		;33 retries for initiating the transfer
0F35  3E 0A             XMS_INIT_LP	LD	A,10		;GET CHAR, 5 SECONDS TIMEOUT (EXPECT C OR NAK)
0F37  CD 4714           		CALL	TIMED_GETCHAR
0F3A  DA 450F           		JP C,	XMS_INIT_RT	;Cancel if Host Timed out

0F3D  FE 15             		CP	NAK		;If NAK, Start Checksum Download
0F3F  28 09             		JR Z,	XMS_DO
0F41  FE 43             		CP	'C'		;If C, Start CRC Download
0F43  28 05             		JR Z,	XMS_DO
0F45  10 EE             XMS_INIT_RT	DJNZ	XMS_INIT_LP	;Count down Retries
0F47  C3 D80F           		JP	XM_CANCEL	;Cancel XModem if all retries exhausted

0F4A  32 F4FF           XMS_DO		LD	(XMTYPE),A
0F4D  C9                		RET

                        ;---------------------------------------------------------------------------------
                        ;SEND A PACKET (RESEND UPON NAK)
                        ;---------------------------------------------------------------------------------
0F4E  01 80FF           XMS_RESEND	LD	BC,0xFF80
0F51  09                		ADD	HL,BC
0F52  D5                XMS_SEND	PUSH	DE
0F53  3E 01             		LD	A,SOH		;SEND THE HEADER FOR CRC OR CHECKSUM
0F55  CD E813           		CALL	Put_Char
0F58  3A F3FF           		LD	A,(XMSEQ)
0F5B  CD E813           		CALL	Put_Char
0F5E  2F                		CPL
0F5F  CD E813           		CALL	Put_Char
0F62  11 0000           		LD	DE,0x0000	;Init DE=0000 (CRC Accumulator)
0F65  0E 00             		LD	C,0		;Init C=00 (CS Accumulator)
0F67  06 80             		LD	B,128		;Count 128 bytes per block
0F69  CD 45FB           XMS_BLP		CALL	GET_MEM		;Fetch bytes to send  -------------------\
0F6C  F5                		PUSH	AF
0F6D  CD E813           		CALL	Put_Char	;Send them
0F70  CD D210           		CALL	CRC_UPDATE	;Update the CRC
0F73  F1                		POP	AF
0F74  81                		ADD	A,C		;Update the CS
0F75  4F                		LD	C,A
0F76  23                		INC	HL		;Advance to next byte in block
0F77  05                		DEC	B		;Count down bytes sent
0F78  20 EF             		JR NZ,	XMS_BLP		;Loop back until 128 bytes are sent -----^
0F7A  3A F4FF           		LD	A,(XMTYPE)
0F7D  FE 15             		CP	NAK		;If NAK, send Checksum
0F7F  28 05             		JR Z,	XMS_CS		;----------------------v
0F81  7A                		LD	A,D		;else, Send the CRC next
0F82  CD E813           		CALL	Put_Char
0F85  4B                		LD	C,E
0F86  79                XMS_CS		LD	A,C		;----------------------/
0F87  CD E813           		CALL	Put_Char
                        					;Packet Sent, get Ack/Nak Response
0F8A  3E 78             		LD	A,120		;GET CHAR, 60 SECONDS TIMEOUT (EXPECT C OR NAK)
0F8C  CD 4714           		CALL	TIMED_GETCHAR
0F8F  D1                		POP	DE
0F90  38 46             		JR C,	XM_CANCEL	;Cancel download if no response within 45 seconds
0F92  FE 15             		CP	NAK
0F94  28 B8             		JR Z,	XMS_RESEND	;Loop back to resend packet
0F96  FE 18             		CP	CAN
0F98  28 3E             		JR Z,	XM_CANCEL
0F9A  FE 06             		CP	ACK
0F9C  20 3A             		JR NZ,	XM_CANCEL

0F9E  3A F3FF           		LD	A,(XMSEQ)
0FA1  3C                		INC	A		;NEXT SEQ
0FA2  32 F3FF           		LD	(XMSEQ),A
0FA5  C9                		RET


                        ;---------------------------------------------------------------------------------
                        ;XMDN - DOWNLOAD XMODEM PACKET
                        ;---------------------------------------------------------------------------------
0FA6  3E 04             XMS_EOT		LD	A,EOT		;HANDLE THE END OF TRANSFER FOR CRC OR CHECKSUM
0FA8  CD E813           		CALL	Put_Char
0FAB  3E 78             		LD	A,120		;GET CHAR, 60 SECONDS TIMEOUT (EXPECT C OR NAK)
0FAD  CD 4714           		CALL	TIMED_GETCHAR
0FB0  38 26             		JR C,	XM_CANCEL
0FB2  FE 15             		CP	NAK
0FB4  28 F0             		JR Z,	XMS_EOT
0FB6  FE 06             		CP	ACK
0FB8  20 1E             		JR NZ,	XM_CANCEL

0FBA  CD 2614           XM_DONE		CALL	PURGE
0FBD  CD CA0D           		CALL	PRINTI
0FC0  0D0A5452 414E5346 		DB	CR,LF,"TRANSFER COMPLETE\r\n",EOS
0FC8  45522043 4F4D504C
0FD0  4554450D 0A00
0FD6  AF                		XOR	A		;CLEAR A, CY
0FD7  C9                		RET

                        ;FINISHING CODE PRIOR TO LEAVING XMODEM
0FD8  3E 18             XM_CANCEL	LD	A,CAN
0FDA  CD E813           		CALL	Put_Char
0FDD  CD E813           		CALL	Put_Char
0FE0  CD 2614           		CALL	PURGE
0FE3  CD CA0D           		CALL	PRINTI
0FE6  5452414E 53464552 		DB	"TRANSFER CANCELED\r\n",EOS
0FEE  2043414E 43454C45
0FF6  440D0A00
0FFA  C1                		POP	BC		;SCRAP CALLING ROUTINE AND HEAD TO PARENT
0FFB  C9                		RET






                        ;---------------------------------------------------------------------------------
                        ;START XMODEM RECEIVING and RECEIVE FIRST PACKET
                        ;---------------------------------------------------------------------------------
0FFC  1E 14             XMR_INIT	LD	E,20		;20 ATTEMPTS TO INITIATE XMODEM CRC TRANSFER
0FFE  3E 01             		LD	A,1		;EXPECTED SEQ NUMBER starts at 1
1000  32 F3FF           		LD	(XMSEQ),A
1003  CD 2614           XMR_CRC		CALL	PURGE
1006  3E 43             		LD	A,'C'		;Send C
1008  32 F4FF           		LD	(XMTYPE),A	;Save as XM Type (CRC or CS)
100B  CD E813           		CALL	Put_Char
100E  CD AF10           		CALL	XMGET_HDR	;Await a packet
1011  30 38             		JR NC,	XMR_TSEQ	;Jump if first packet received
1013  20 C3             		JR NZ,	XM_CANCEL	;Cancel if there was a response that was not a header
1015  1D                		DEC	E		;Otherwise, if no response, retry a few times
1016  20 EB             		JR NZ,	XMR_CRC

1018  1E 14             		LD	E,20		;20 ATTEMPTS TO INITIATE XMODEM CHECKSUM TRANSFER
101A  CD 2614           XMR_CS		CALL	PURGE
101D  3E 15             		LD	A,NAK		;Send NAK
101F  32 F4FF           		LD	(XMTYPE),A	;Save as XM Type (CRC or CS)
1022  CD E813           		CALL	Put_Char
1025  CD AF10           		CALL	XMGET_HDR	;Await a packet
1028  30 21             		JR NC,	XMR_TSEQ	;Jump if first packet received
102A  20 AC             		JR NZ,	XM_CANCEL	;Cancel if there was a response that was not a header
102C  1D                		DEC	E		;Otherwise, if no response, retry a few times
102D  20 EB             		JR NZ,	XMR_CS
102F  18 A7             		JR	XM_CANCEL	;Abort


                        ;--------------------- XMODEM RECEIVE
                        ;Entry:	XMR_TSEQ in the middle of the routine
                        ;Pre:	C=1 (expected first block as received when negogiating CRC or Checksum)
                        ;	HL=Memory to dump the file to
                        ;Uses:	B to count the 128 bytes per block
                        ;	C to track Block Number expected
                        ;	DE as CRC (Within Loop) (D is destroyed when Getting Header)
                        ;------------------------------------
1031  3E 06             XMR_RECV	LD	A,ACK		;Send Ack to start Receiving next packet
1033  CD E813           		CALL	Put_Char
1036  CD AF10           XMR_LP		CALL	XMGET_HDR
1039  30 10             		JR NC,	XMR_TSEQ
103B  E5                		PUSH	HL
103C  28 65             		JR Z,	XMR_NAK		;NACK IF TIMED OUT
103E  E1                		POP	HL
103F  FE 04             		CP	EOT
1041  20 95             		JR NZ,	XM_CANCEL	;CANCEL IF CAN RECEIVED (OR JUST NOT EOT)
1043  3E 06             		LD	A,ACK
1045  CD E813           		CALL	Put_Char
1048  C3 BA0F           		JP	XM_DONE

104B  4F                XMR_TSEQ	LD	C,A
104C  3A F3FF           		LD	A,(XMSEQ)
104F  B9                		CP	C		;CHECK IF THIS SEQ IS EXPECTED
1050  28 0D             		JR Z,	XMR_SEQ_OK	;Jump if CORRECT SEQ
1052  3D                		DEC	A		;Else test if Previous SEQ
1053  32 F3FF           		LD	(XMSEQ),A
1056  B9                		CP	C
1057  C2 D80F           		JP NZ,	XM_CANCEL	;CANCEL IF SEQUENCE ISN'T PREVIOUS BLOCK
105A  CD 2614           		CALL	PURGE		;ELSE, PURGE AND SEND ACK (ASSUMING PREVIOUS ACK WAS NOT RECEIVED)
105D  18 3A             		JR	XMR_ACK

105F  06 80             XMR_SEQ_OK	LD	B,128		;128 BYTES PER BLOCK
1061  0E 00             		LD	C,0		;Clear Checksum
1063  11 0000           		LD	DE,0x0000	;CLEAR CRC
1066  E5                		PUSH	HL		;Save HL where block is to go
1067  CD 4514           XMR_BLK_LP	CALL	TIMED1_GETCHAR
106A  38 37             		JR C,	XMR_NAK
106C  77                		LD	(HL),A		;SAVE DATA BYTE
106D  CD D210           		CALL	CRC_UPDATE
1070  7E                		LD	A,(HL)		;Update checksum
1071  81                		ADD	A,C
1072  4F                		LD	C,A
1073  23                		INC	HL		;ADVANCE
1074  05                		DEC	B
1075  20 F0             		JR NZ,	XMR_BLK_LP
                        					;After 128 byte packet, verify error checking byte(s)
1077  3A F4FF           		LD	A,(XMTYPE)	;Determine if we are using CRC or Checksum
107A  FE 15             		CP	NAK		;If NAK, then use Checksum
107C  28 12             		JR Z,	XMR_CCS
107E  CD 4514           		CALL	TIMED1_GETCHAR
1081  38 20             		JR C,	XMR_NAK
1083  BA                		CP	D
1084  20 1D             		JR NZ,	XMR_NAK
1086  CD 4514           		CALL	TIMED1_GETCHAR
1089  38 18             		JR C,	XMR_NAK
108B  BB                		CP	E
108C  20 15             		JR NZ,	XMR_NAK
108E  18 09             		JR	XMR_ACK

1090  CD 4514           XMR_CCS		CALL	TIMED1_GETCHAR
1093  DA A310           		JP C,	XMR_NAK
1096  B9                		CP	C
1097  20 0A             		JR NZ,	XMR_NAK

                        		;If we were transfering to a FILE, this is where we would write the
                        		;sector and reset HL to the same 128 byte sector buffer.
                        		;CALL	WRITE_SECTOR

1099                    XMR_ACK		;LD	A,ACK		;The sending of the Ack is done by
                        		;CALL	Put_Char	;the calling routine, to allow writes to disk
1099  3A F3FF           		LD	A,(XMSEQ)
109C  3C                		INC	A		;Advance to next SEQ BLOCK
109D  32 F3FF           		LD	(XMSEQ),A
10A0  C1                		POP	BC
10A1  37                		SCF			;Carry set when NOT last packet
10A2  C9                		RET

10A3  E1                XMR_NAK		POP	HL		;Return HL to start of block
10A4  CD 2614           		CALL	PURGE
10A7  3E 15             		LD	A,NAK
10A9  CD E813           		CALL	Put_Char
10AC  C3 3610           		JP	XMR_LP


                        ;--------------------- XMODEM - GET HEADER
                        ;
                        ;pre:	Nothing
                        ;post:	Carry Set: A=0, (Zero set) if Timeout
                        ;	Carry Set: A=CAN (Not Zero) if Cancel received
                        ;	Carry Set: A=EOT (Not Zero) if End of Tranmission received
                        ;	Carry Clear and A = B = Seq if Header found and is good
                        ;------------------------------------------
10AF  3E 06             XMGET_HDR	LD	A,6		;GET CHAR, 3 SECONDS TIMEOUT (EXPECT SOH)
10B1  CD 4714           		CALL	TIMED_GETCHAR
10B4  D8                		RET C			;Return if Timed out
10B5  FE 01             		CP	SOH		;TEST IF START OF HEADER
10B7  28 0B             		JR Z,	GS_SEQ		;IF SOH RECEIVED, GET SEQ NEXT
10B9  FE 04             		CP	EOT		;TEST IF END OF TRANSMISSION
10BB  28 04             		JR Z,	GS_ESC		;IF EOT RECEIVED, TERMINATE XMODEM
10BD  FE 18             		CP	CAN		;TEST IF CANCEL
10BF  20 EE             		JR NZ,	XMGET_HDR
10C1  B7                GS_ESC		OR	A		;Clear Z flag (because A<>0)
10C2  37                		SCF
10C3  C9                		RET
10C4  CD 4514           GS_SEQ		CALL	TIMED1_GETCHAR	;GET SEQ CHAR
10C7  D8                		RET C			;Return if Timed out
10C8  47                		LD	B,A		;SAVE SEQ
10C9  CD 4514           		CALL	TIMED1_GETCHAR	;GET SEQ COMPLEMENT
10CC  D8                		RET C			;Return if Timed out
10CD  2F                		CPL
10CE  B8                		CP	B		;TEST IF SEQ VALID
10CF  20 DE             		JR NZ,	XMGET_HDR	;LOOP BACK AND TRY AGAIN IF HEADER INCORRECT (SYNC FRAME)
10D1  C9                		RET

                        ;------------------------------------------ CRC_UPDATE
                        ;HANDLE THE CRC CALCULATION FOR UP/DOWNLOADING
                        ;Total Time=775 cycles = 388uSec
                        ;In:	A  = New char to roll into CRC accumulator
                        ;	DE = 16bit CRC accumulator
                        ;Out:	DE = 16bit CRC accumulator
                        ;------------------------------------------
                        ;CRC_UPDATE	XOR	D		;4
                        ;		LD	D,A		;5
                        ;		PUSH	BC		;11
                        ;		LD	B,8		;7	PRELOOP=27
                        ;CRCU_LP	OR	A		;4	CLEAR CARRY
                        ;		LD	A,E		;5
                        ;		RLA			;4
                        ;		LD	E,A		;5
                        ;		LD	A,D		;5
                        ;		RLA			;4
                        ;		LD	D,A		;5
                        ;		JP NC,	CRCU_NX		;10
                        ;		LD	A,D		;5
                        ;		XOR	0x10		;7
                        ;		LD	D,A		;5
                        ;		LD	A,E		;5
                        ;		XOR	0x21		;7
                        ;		LD	E,A		;5
                        ;CRCU_NX	DEC	B		;5
                        ;		JP NZ,	CRCU_LP		;10	LOOP=91*8 (WORSE CASE)
                        ;		POP	BC		;10	POSTLOOP=20
                        ;		RET			;10


                        ;------------------------------------------ CRC_UPDATE
                        ;HANDLE THE CRC CALCULATION FOR UP/DOWNLOADING
                        ;Total Time=604 cycles = 302uSec MAX
                        ;In:	A  = New char to roll into CRC accumulator
                        ;	DE = 16bit CRC accumulator
                        ;Out:	DE = 16bit CRC accumulator
                        ;------------------------------------------
10D2  EB                CRC_UPDATE	EX	DE,HL			;4
10D3  AC                		XOR	H		;4
10D4  67                		LD	H,A		;5
10D5  29                		ADD	HL,HL		;10	Shift HL Left 1
10D6  DC F710           		CALL C,	CRC_UPC		;17 (10/61)
10D9  29                		ADD	HL,HL		;10	Shift HL Left 2
10DA  DC F710           		CALL C,	CRC_UPC		;17
10DD  29                		ADD	HL,HL		;10	Shift HL Left 3
10DE  DC F710           		CALL C,	CRC_UPC		;17
10E1  29                		ADD	HL,HL		;10	Shift HL Left 4
10E2  DC F710           		CALL C,	CRC_UPC		;17
10E5  29                		ADD	HL,HL		;10	Shift HL Left 5
10E6  DC F710           		CALL C,	CRC_UPC		;17
10E9  29                		ADD	HL,HL		;10	Shift HL Left 6
10EA  DC F710           		CALL C,	CRC_UPC		;17
10ED  29                		ADD	HL,HL		;10	Shift HL Left 7
10EE  DC F710           		CALL C,	CRC_UPC		;17
10F1  29                		ADD	HL,HL		;10	Shift HL Left 8
10F2  DC F710           		CALL C,	CRC_UPC		;17
10F5  EB                		EX	DE,HL			;4
10F6  C9                		RET			;10

10F7  7C                CRC_UPC		LD	A,H		;5
10F8  EE 10             		XOR	0x10		;7
10FA  67                		LD	H,A		;5
10FB  7D                		LD	A,L		;5
10FC  EE 21             		XOR	0x21		;7
10FE  6F                		LD	L,A		;5
10FF  C9                		RET			;10


                        ;XModem implementation on 8080 Monitor (CP/M-80)
                        ;
                        ;Terminal uploads to 8080 system:
                        ;-Terminal user enters command "XU aaaa"
                        ;-8080 "drives" the protocol since it's the receiver
                        ;-8080 sends <Nak> every 10 seconds until the transmitter sends a packet
                        ;-if transmitter does not begin within 10 trys (100 seconds), 8080 aborts XMODEM
                        ;-a packet is:
                        ; <SOH> [seq] [NOT seq] [128 bytes of data] [checksum or CRC]
                        ;
                        ;<SOH> = 1 (Start of Header)
                        ;<EOT> = 4 (End of Transmission)
                        ;<ACK> = 6
                        ;<DLE> = 16
                        ;<DC1> = 17 (X-ON)
                        ;<DC3> = 19 (X-OFF)
                        ;<NAK> = 21
                        ;<SYN> = 22
                        ;<CAN> = 24 (Cancel)
                        ;
                        ;Checksum is the ModuLOW 256 sum of all 128 data bytes
                        ;
                        ;                                     <<<<<          [NAK]
                        ;       [SOH][001][255][...][csum]    >>>>>
                        ;                                     <<<<<          [ACK]
                        ;       [SOH][002][254][...][csum]    >>>>>
                        ;                                     <<<<<          [ACK]
                        ;       [SOH][003][253][...][csum]    >>>>>
                        ;                                     <<<<<          [ACK]
                        ;       [EOT]                         >>>>>
                        ;                                     <<<<<          [ACK]
                        ;
                        ;-if we get <EOT> then ACK and terminate XModem
                        ;-if we get <CAN> then terminate XModem
                        ;-if checksum invalid, then NAK
                        ;-if seq number not correct as per [NOT seq], then NAK
                        ;-if seq number = previous number, then ACK (But ignore block)
                        ;-if seq number not the expected number, then <CAN><CAN> and terminate XModem
                        ;-if data not received after 10 seconds, then NAK (inc Timeout Retry)
                        ;-if timeout retry>10 then <CAN><CAN> and terminate XModem
                        ;
                        ;-To keep synchronized,
                        ;  -Look for <SOH>, qualify <SOH> by checking the [seq] / [NOT seq]
                        ;  -if no <SOH> found after 135 chars, then NAK
                        ;
                        ;-False EOT condtion
                        ;  -NAK the first EOT
                        ;  -if the next char is EOT again, then ACK and leave XModem
                        ;
                        ;-False <CAN>, expect a 2nd <CAN> ?
                        ;
                        ;-Using CRC, send "C" instead of <NAK> for the first packet
                        ;  -Send "C" every 3 seconds for 3 tries, then degrade to checksums by sending <NAK>
                        ;
                        ;
                        ;
                        ;* The character-receive subroutine should be called with a
                        ;parameter specifying the number of seconds to wait.  The
                        ;receiver should first call it with a time of 10, then <nak> and
                        ;try again, 10 times.
                        ;  After receiving the <soh>, the receiver should call the
                        ;character receive subroutine with a 1-second timeout, for the
                        ;remainder of the message and the <cksum>.  Since they are sent
                        ;as a continuous stream, timing out of this implies a serious
                        ;like glitch that caused, say, 127 characters to be seen instead
                        ;of 128.
                        ;
                        ;* When the receiver wishes to <nak>, it should call a "PURGE"
                        ;subroutine, to wait for the line to clear.  Recall the sender
                        ;tosses any characters in its UART buffer immediately upon
                        ;completing sending a block, to ensure no glitches were mis-
                        ;interpreted.
                        ;  The most common technique is for "PURGE" to call the
                        ;character receive subroutine, specifying a 1-second timeout,
                        ;and looping back to PURGE until a timeout occurs.  The <nak> is
                        ;then sent, ensuring the other end will see it.
                        ;
                        ;* You may wish to add code recommended by Jonh Mahr to your
                        ;character receive routine - to set an error flag if the UART
                        ;shows framing error, or overrun.  This will help catch a few
                        ;more glitches - the most common of which is a hit in the high
                        ;bits of the byte in two consecutive bytes.  The <cksum> comes
                        ;out OK since counting in 1-byte produces the same result of
                        ;adding 80H + 80H as with adding 00H + 00H.



                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_8	Menu operations. RAM TEST
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;----------------------------------------------------------------------------------------------------; RAM TEST
                        ;B=START PAGE
                        ;C=END PAGE
1100  CD 490D           RAM_TEST:	CALL	SPACE_GET_BYTE
1103  47                		LD	B, A
1104  CD 490D           		CALL	SPACE_GET_BYTE
1107  4F                		LD	C, A

1108  21 7C0C           		LD	HL,GET_REG_RUN
110B  22 B4FF           		LD	(GET_REG),HL
110E  CD 1811           		CALL	RT_GO
1111  21 710C           		LD	HL,GET_REG_MON
1114  22 B4FF           		LD	(GET_REG),HL
1117  C9                		RET

                        ;Page March Test.  1 Sec/K
                        ;
                        ; FOR E = 00 TO FF STEP FF   'March 00 then March FF
                        ;   FOR H = B TO C
                        ;      PAGE(H) = E
                        ;   NEXT H
                        ;   FOR D = B TO C
                        ;      PAGE(D) = NOT E
                        ;      FOR H = B TO C
                        ;         A = E
                        ;         IF H = D THEN A = NOT E
                        ;         IF PAGE(H) <> A THEN ERROR1
                        ;      NEXT H
                        ;   NEXT D
                        ; NEXT E
                        ;

1118  CD CA0D           RT_GO		CALL	PRINTI
111B  0D0A5445 5354494E 		DB	CR,LF,"TESTING RAM",EOS
1123  47205241 4D00
1129  1E FF             		LD	E,0xFF		;E selects the polarity of the test, ie March a page of 1'S or 0's

                        ;Clear/Set all pages
112B  60                RT1_LP0		LD	H,B		;HL = BASE RAM ADDRESS
112C  2E 00             		LD	L,0
112E  7B                RT1_LP1		LD	A,E		;CLEAR A
112F  2F                		CPL
1130  77                RT1_LP2		LD	(HL),A		;WRITE PAGE
1131  2C                		INC	L
1132  20 FC             		JR NZ,	RT1_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
1134  7C                		LD	A,H
1135  24                		INC	H		;ADVANCE TO NEXT PAGE
1136  B9                		CP	C		;COMPARE WITH END PAGE
1137  20 F5             		JR NZ,	RT1_LP1		;LOOP UNTIL = END PAGE

                        ;March 1 PAGE through RAM
1139  50                		LD	D,B		;Begin with START PAGE

                        ;Write FF to page D
113A  62                RT1_LP3		LD	H,D		;HL = Marched Page ADDRESS
                        		;LD	L,0
113B  CD 6C13           		CALL	ABORT_CHECK

113E  7A                		LD	A,D
113F  2F                		CPL
                        ;		OUT	FPLED
                        		;LD	A,E		;SET A
1140  73                RT1_LP4		LD	(HL),E		;WRITE PAGE
1141  2C                		INC	L
1142  20 FC             		JR  NZ,	RT1_LP4		;LOOP TO QUICKLY WRITE 1 PAGE

                        ;Test all pages for 0 (except page D = FF)
1144  60                		LD	H,B		;HL = BASE RAM ADDRESS
                        		;LD	L,0

1145  7C                RT1_LP5		LD	A,H		;IF H = D
1146  BA                		CP	D
1147  7B                		LD	A,E		;THEN Value = FF
1148  28 01             		JR Z,	RT1_LP6
114A  2F                		CPL			;ELSE Value = 00

114B  BE                RT1_LP6		CP	(HL)		;TEST RAM
114C  C2 DE12           		JP NZ,	RT_FAIL1
114F  2C                		INC	L
1150  20 F9             		JR NZ,	RT1_LP6		;LOOP TO QUICKLY TEST 1 PAGE
1152  7C                		LD	A,H
1153  24                		INC	H		;ADVANCE TO NEXT PAGE
1154  B9                		CP	C		;COMPARE WITH END PAGE
1155  20 EE             		JR NZ,	RT1_LP5		;LOOP UNTIL = END PAGE

                        ;Write 00 back to page D
1157  62                		LD	H,D		;HL = Marched Page ADDRESS
                        		;LD	L,0
1158  7B                		LD	A,E
1159  2F                		CPL
115A  77                RT1_LP7		LD	(HL),A		;WRITE PAGE
115B  2C                		INC	L
115C  20 FC             		JR NZ,	RT1_LP7		;LOOP TO QUICKLY WRITE 1 PAGE

115E  7A                		LD	A,D
115F  14                		INC	D		;ADVANCE TO NEXT PAGE
1160  B9                		CP	C		;COMPARE WITH END PAGE
1161  20 D7             		JR NZ,	RT1_LP3		;LOOP UNTIL = END PAGE

1163  1C                		INC	E
1164  28 C5             		JR Z,	RT1_LP0

1166  CD CA0D           		CALL	PRINTI
1169  0D0A5241 4D205041 		DB	CR,LF,"RAM PAGE MARCH PASSED",EOS
1171  4745204D 41524348
1179  20504153 53454400


                        ;Byte March Test.  7 Sec/K
                        ;
                        ; FOR E = 00 TO FF STEP FF   'March 00 then March FF
                        ;   FOR H = B TO C
                        ;      PAGE(H) = E
                        ;      FOR D = 00 TO FF
                        ;         PAGE(H).D = NOT E
                        ;         FOR L=0 TO FF
                        ;            IF PAGE(H).L <> E THEN
                        ;               IF PAGE(H).L <> NOT E THEN ERROR2
                        ;               IF L<>D THEN ERROR2
                        ;            ENDIF
                        ;         NEXT L
                        ;      NEXT D
                        ;   NEXT H
                        ; NEXT E

1181  1E FF             		LD	E,0xFF		;E selects the polarity of the test, ie March a page of 1'S or 0's

                        ;Clear/Set all pages

1183  60                RT2_LP0		LD	H,B		;HL = BASE RAM ADDRESS
1184  2E 00             RT2_LP1		LD	L,0
1186  CD 6C13           		CALL	ABORT_CHECK

1189  7C                		LD	A,H
118A  2F                		CPL
                        ;		OUT	FPLED

118B  7B                		LD	A,E		;CLEAR A
118C  2F                		CPL
118D  77                RT2_LP2		LD	(HL),A		;WRITE PAGE
118E  2C                		INC	L
118F  20 FC             		JR NZ,	RT2_LP2		;LOOP TO QUICKLY WRITE 1 PAGE


1191  16 00             		LD	D,0		;Starting with BYTE 00 of page

1193  6A                RT2_LP3		LD	L,D		;Save at byte march ptr
1194  7B                		LD	A,E		;SET A
1195  77                		LD	(HL),A

                        		;LD	A,E
1196  2F                		CPL			;CLEAR A
1197  2E 00             		LD	L,0

1199  BE                RT2_LP4		CP	(HL)		;TEST BYTE FOR CLEAR
119A  28 0C             		JR Z,	RT2_NX1
119C  2F                		CPL			;SET A
119D  BE                		CP	(HL)		;TEST BYTE FOR SET
119E  C2 0113           		JP NZ,	RT_FAIL2	;IF NOT FULLY SET, THEN DEFINITELY FAIL
11A1  7D                		LD	A,L		;ELSE CHECK WE ARE ON MARCHED BYTE
11A2  BA                		CP	D
11A3  C2 0113           		JP NZ,	RT_FAIL2
11A6  7B                		LD	A,E		;CLEAR A
11A7  2F                		CPL
11A8  2C                RT2_NX1		INC	L
11A9  20 EE             		JR NZ,	RT2_LP4		;LOOP TO QUICKLY WRITE 1 PAGE

11AB  6A                		LD	L,D		;Save at byte march ptr
11AC  7B                		LD	A,E
11AD  2F                		CPL			;CLEAR A
11AE  77                		LD	(HL),A

11AF  14                		INC	D
11B0  20 E1             		JR NZ,	RT2_LP3

11B2  7C                		LD	A,H
11B3  24                		INC	H		;ADVANCE TO NEXT PAGE
11B4  B9                		CP	C		;COMPARE WITH END PAGE
11B5  20 CD             		JR NZ,	RT2_LP1		;LOOP UNTIL = END PAGE

11B7  1C                		INC	E
11B8  28 C9             		JR Z,	RT2_LP0

11BA  CD CA0D           		CALL	PRINTI
11BD  0D0A5241 4D204259 		DB	CR,LF,"RAM BYTE MARCH 1 PASSED",EOS
11C5  5445204D 41524348
11CD  20312050 41535345
11D5  4400

                        ;26 Sec/K

11D7                    BYTEMARCH2
11D7  1E FF             		LD	E,0xFF		;E selects the polarity of the test, ie March a page of 1'S or 0's

11D9  16 00             RT4_LP0		LD	D,0		;Starting with BYTE 00 of page

                        ;CLEAR all pages

11DB  60                		LD	H,B		;HL = BASE RAM ADDRESS
11DC  2E 00             		LD	L,0

11DE  7B                RT4_LP1		LD	A,E		;CLEAR A
11DF  2F                		CPL
11E0  77                RT4_LP2		LD	(HL),A		;WRITE PAGE
11E1  2C                		INC	L
11E2  20 FC             		JR NZ,	RT4_LP2		;LOOP TO QUICKLY WRITE 1 PAGE

11E4  7C                		LD	A,H
11E5  24                		INC	H		;ADVANCE TO NEXT PAGE
11E6  B9                		CP	C		;COMPARE WITH END PAGE
11E7  20 F5             		JR NZ,	RT4_LP1		;LOOP UNTIL = END PAGE


11E9  CD 6C13           RT4_LP3		CALL	ABORT_CHECK
11EC  7A                		LD	A,D
11ED  2F                		CPL
                        ;		OUT	FPLED

                        					;Write SET byte at "D" in every page
11EE  60                		LD	H,B		;HL = BASE RAM ADDRESS
11EF  6A                		LD	L,D		;Save at byte march ptr
11F0  73                RT4_LP4		LD	(HL),E

11F1  7C                		LD	A,H
11F2  24                		INC	H		;ADVANCE TO NEXT PAGE
11F3  B9                		CP	C		;COMPARE WITH END PAGE
11F4  20 FA             		JR NZ,	RT4_LP4		;LOOP UNTIL = END PAGE


11F6  2E 00             		LD	L,0

11F8  60                RT4_LP5		LD	H,B		;HL = BASE RAM ADDRESS
11F9  7D                		LD	A,L
11FA  BA                		CP	D
11FB  28 0D             		JR Z,	RT4_LP7		;Test for marked byte in all pages

11FD  7B                RT4_LP6		LD	A,E
11FE  2F                		CPL			;CLEAR A
11FF  BE                		CP	(HL)		;TEST BYTE FOR CLEAR
1200  C2 0113           		JP NZ,	RT_FAIL2

1203  7C                		LD	A,H
1204  24                		INC	H		;ADVANCE TO NEXT PAGE
1205  B9                		CP	C		;COMPARE WITH END PAGE
1206  20 F5             		JR NZ,	RT4_LP6		;LOOP UNTIL = END PAGE
1208  18 0A             		JR	RT4_NX

120A  7B                RT4_LP7		LD	A,E
120B  BE                		CP	(HL)		;TEST BYTE FOR SET
120C  C2 0113           		JP NZ,	RT_FAIL2

120F  7C                		LD	A,H
1210  24                		INC	H		;ADVANCE TO NEXT PAGE
1211  B9                		CP	C		;COMPARE WITH END PAGE
1212  20 F6             		JR NZ,	RT4_LP7		;LOOP UNTIL = END PAGE

1214  2C                RT4_NX		INC	L
1215  20 E1             		JR NZ,	RT4_LP5

                        					;Write CLEAR byte at "D" in every page
1217  60                		LD	H,B		;HL = BASE RAM ADDRESS
1218  6A                		LD	L,D		;Save at byte march ptr
1219  7B                RT4_LP8		LD	A,E
121A  2F                		CPL
121B  77                		LD	(HL),A

121C  7C                		LD	A,H
121D  24                		INC	H		;ADVANCE TO NEXT PAGE
121E  B9                		CP	C		;COMPARE WITH END PAGE
121F  20 F8             		JR NZ,	RT4_LP8		;LOOP UNTIL = END PAGE

1221  14                		INC	D
1222  20 C5             		JR NZ,	RT4_LP3


1224  1C                		INC	E
1225  28 B2             		JR Z,	RT4_LP0

1227  CD CA0D           		CALL	PRINTI
122A  0D0A5241 4D204259 		DB	CR,LF,"RAM BYTE MARCH 2 PASSED",EOS
1232  5445204D 41524348
123A  20322050 41535345
1242  4400


1244                    BIT_MARCH
                        ;Bit March Test.  0.1 Sec/K

1244  1E 01             		LD	E,01		;E selects the bit to march

                        ;Clear/Set all pages

1246  60                RT3_LP1		LD	H,B		;HL = BASE RAM ADDRESS
1247  2E 00             		LD	L,0

1249  CD 6C13           		CALL	ABORT_CHECK

124C  7B                		LD	A,E		;Display bit pattern on LED PORT
124D  2F                		CPL
                        ;		OUT	FPLED

124E  7B                RT3_LP2		LD	A,E		;FETCH MARCHING BIT PATTERN
124F  77                RT3_LP3		LD	(HL),A		;WRITE PAGE
1250  2C                		INC	L
1251  20 FC             		JR NZ,	RT3_LP3		;LOOP TO QUICKLY WRITE 1 PAGE

1253  7C                		LD	A,H
1254  24                		INC	H		;ADVANCE TO NEXT PAGE
1255  B9                		CP	C		;COMPARE WITH END PAGE
1256  20 F6             		JR NZ,	RT3_LP2		;LOOP UNTIL = END PAGE

1258  60                		LD	H,B		;HL = BASE RAM ADDRESS
                        ;		LD	L,0

1259  7B                RT3_LP4		LD	A,E		;FETCH MARCHING BIT PATTERN
125A  BE                RT3_LP5		CP	(HL)
125B  C2 2413           		JP NZ,	RT_FAIL3
125E  2C                		INC	L
125F  20 F9             		JR NZ,	RT3_LP5		;LOOP TO QUICKLY WRITE 1 PAGE

1261  7C                		LD	A,H
1262  24                		INC	H		;ADVANCE TO NEXT PAGE
1263  B9                		CP	C		;COMPARE WITH END PAGE
1264  20 F3             		JR NZ,	RT3_LP4		;LOOP UNTIL = END PAGE


                        					;0000 0010
                        					;...
                        					;1000 0000

1266  7B                		LD	A,E
1267  17                		RLA			;ROTATE THE 01 UNTIL 00
1268  7B                		LD	A,E
1269  07                		RLCA
126A  5F                		LD	E,A
126B  FE 01             		CP	1
126D  20 04             		JR NZ,	RT3_NX1
126F  2F                		CPL			;INVERT ALL BITS
1270  5F                		LD	E,A
1271  18 D3             		JR	RT3_LP1
1273  FE FE             RT3_NX1		CP	0xFE
1275  20 CF             		JR NZ,	RT3_LP1

1277  CD CA0D           		CALL	PRINTI
127A  0D0A5241 4D204249 		DB	CR,LF,"RAM BIT MARCH PASSED",EOS
1282  54204D41 52434820
128A  50415353 454400


1291  1E 01             		LD	E,01		;E selects the start sequence

                        ;Clear/Set all pages

1293  CD 6C13           RT5_LP1		CALL	ABORT_CHECK

1296  7B                		LD	A,E		;Display bit pattern on LED PORT
1297  2F                		CPL
                        ;		OUT	FPLED

1298  60                		LD	H,B		;HL = BASE RAM ADDRESS
1299  2E 00             		LD	L,0
129B  53                		LD	D,E

129C  14                RT5_LP2		INC	D
129D  20 01             		JR NZ,	RT5_NX1
129F  14                		INC	D
12A0  72                RT5_NX1		LD	(HL),D		;WRITE PAGE
12A1  2C                		INC	L
12A2  20 F8             		JR NZ,	RT5_LP2		;LOOP TO QUICKLY WRITE 1 PAGE

12A4  7C                		LD	A,H
12A5  24                		INC	H		;ADVANCE TO NEXT PAGE
12A6  B9                		CP	C		;COMPARE WITH END PAGE
12A7  20 F3             		JR NZ,	RT5_LP2		;LOOP UNTIL = END PAGE

12A9  60                		LD	H,B		;HL = BASE RAM ADDRESS
                        		;LD	L,0
12AA  53                		LD	D,E

12AB  14                RT5_LP3		INC	D
12AC  20 01             		JR NZ,	RT5_NX2
12AE  14                		INC	D
12AF  7A                RT5_NX2		LD	A,D
12B0  BE                		CP	(HL)		;TEST
12B1  C2 4613           		JP NZ,	RT_FAIL5
12B4  2C                		INC	L
12B5  20 F4             		JR NZ,	RT5_LP3		;LOOP TO QUICKLY WRITE 1 PAGE

12B7  7C                		LD	A,H
12B8  24                		INC	H		;ADVANCE TO NEXT PAGE
12B9  B9                		CP	C		;COMPARE WITH END PAGE
12BA  20 EF             		JR NZ,	RT5_LP3		;LOOP UNTIL = END PAGE

12BC  1C                		INC	E
12BD  20 D4             		JR NZ,	RT5_LP1

12BF  CD CA0D           		CALL	PRINTI
12C2  0D0A5241 4D205345 		DB	CR,LF,"RAM SEQUENCE TEST PASSED",EOS
12CA  5155454E 43452054
12D2  45535420 50415353
12DA  454400
12DD  C9                		RET

12DE  CD CA0D           RT_FAIL1	CALL	PRINTI
12E1  0D0A5241 4D204641 		DB	CR,LF,"RAM FAILED PAGE MARCH AT:",EOS
12E9  494C4544 20504147
12F1  45204D41 52434820
12F9  41543A00
12FD  CD EA0D           		CALL	PUT_HL
1300  C9                		RET

1301  CD CA0D           RT_FAIL2	CALL	PRINTI
1304  0D0A5241 4D204641 		DB	CR,LF,"RAM FAILED BYTE MARCH AT:",EOS
130C  494C4544 20425954
1314  45204D41 52434820
131C  41543A00
1320  CD EA0D           		CALL	PUT_HL
1323  C9                		RET

1324  CD CA0D           RT_FAIL3	CALL	PRINTI
1327  0D0A5241 4D204641 		DB	CR,LF,"RAM FAILED BIT MARCH AT:",EOS
132F  494C4544 20424954
1337  204D4152 43482041
133F  543A00
1342  CD EA0D           		CALL	PUT_HL
1345  C9                		RET

1346  CD CA0D           RT_FAIL5	CALL	PRINTI
1349  0D0A5241 4D204641 		DB	CR,LF,"RAM FAILED SEQUENCE TEST AT:",EOS
1351  494C4544 20534551
1359  55454E43 45205445
1361  53542041 543A00
1368  CD EA0D           		CALL	PUT_HL
136B  C9                		RET

136C  CD 1D14           ABORT_CHECK	CALL	IN_CHAR
136F  D8                		RET C
1370  FE 1B             		CP	27
1372  C0                		RET NZ
1373  E1                		POP	HL			;SCRAP RETURN ADDRESS AND GO TO PARENT ROUTINE
1374  CD CA0D           		CALL	PRINTI
1377  0D0A4142 4F525445 		DB	CR,LF,"ABORTED",EOS
137F  4400
1381  C9                		RET


                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_10	BIOS.
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;SET_IO		Sets the IO pointed to by PUT_CHAR AND IN_CHAR
                        ;GET_CHAR_NE	Uses IN_CHAR
                        ;GET_CHAR	Uses IN_CHAR
                        ;Put_Char	
                        ;RX_COUNT	Returns count of bytes recieved
                        ;IN_CHAR	Returns received char or CF=1 if no char
                        ;PURGE		
                        ;TIMED1_GETCHAR	
                        ;TIMED_GETCHAR	
                        ;
                        ;RXC_BOTH	BOTH BIT AND ACE
                        ;IC_BOTH		
                        ;PC_BOTH		
                        ;
                        ;LED_HOME	LED
                        ;IC_KEY		
                        ;PC_LED		
                        ;
                        ;RXC_ACE	ACE	
                        ;IC_ACE		
                        ;PC_ACE		
                        ;
                        ;RXC_BIT	BITBANG	
                        ;IC_BIT		
                        ;PC_POS_UPDATE	
                        ;PC_BIT		

                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;----------------------------------------------------------------------------------------------------; CONSOLE BIOS


                        				;HW_LIST: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP
                        				;Input C: 00=BIT, 01=BIT, 02=ACE, 03=BOTH, 04=LED
1382  E5                SET_IO		PUSH	HL
1383  D5                		PUSH	DE
1384  C5                		PUSH	BC		
1385  F5                		PUSH	AF
1386  21 95FF           		LD	HL,HW_LIST	;Only set the new I/O if Hardware is present
1389  79                		LD	A,C
138A  B7                		OR	A
138B  28 0F             		JR  Z,	SIO_ZERO	;Special case, No FP & No SIO
138D  A6                		AND	(HL)
138E  4F                		LD	C,A
138F  20 0D             		JR NZ,	SIO_OK
1391  79                		LD	A,C		;Handle special LED case.
1392  0F                		RRCA			;Shift LED (04) to FP hardware (01)
1393  0F                		RRCA
1394  A6                		AND	(HL)
1395  79                		LD	A,C
1396  20 06             		JR NZ,	SIO_OK
1398  F1                		POP	AF
1399  37                		SCF
139A  18 19             		JR 	SIO_RET
                        		
139C  0C                SIO_ZERO	INC	C
139D  3C                		INC	A
139E  32 94FF           SIO_OK		LD	(HW_SETIO),A	;Save set IO configuration
13A1  0D                		DEC	C
13A2  CB21              		SLA	C		;x2 for word
13A4  CB21              		SLA	C		;x2 for 2 words
13A6  06 00             		LD	B,0
13A8  21 B913           		LD	HL,IOD_TABLE
13AB  09                		ADD	HL,BC
13AC  11 90FF           		LD	DE,PUTCHAR_EXE
13AF  0E 04             		LD	C,4
13B1  EDB0              		LDIR
13B3  F1                		POP	AF
13B4  B7                		OR	A		;CY=0
13B5  C1                SIO_RET		POP	BC
13B6  D1                		POP	DE
13B7  E1                		POP	HL
13B8  C9                		RET

13B9  3415              IOD_TABLE	DW	PC_BIT		;FP       (PUTCHAR_EXE)
13BB  1315              		DW	IC_BIT		;FP       (INCHAR_EXE)
13BD  DC14              		DW	PC_ACE		;SIO      (PUTCHAR_EXE)
13BF  CB14              		DW	IC_ACE		;SIO 	  (INCHAR_EXE)
13C1  6C14              		DW	PC_BOTH		;FP & SIO (PUTCHAR_EXE)
13C3  6614              		DW	IC_BOTH		;FP & SIO (INCHAR_EXE)
13C5  8614              		DW	PC_LED		;LED      (PUTCHAR_EXE)
13C7  B614              		DW	IC_KEY		;LED      (INCHAR_EXE)


                        				;HW_SETIO: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP
13C9  3A 94FF           GET_POS		LD	A,(HW_SETIO)
13CC  0F                		RRCA
13CD  0F                		RRCA
13CE  3A D7FF           		LD	A,(POS_ACE)
13D1  D8                		RET	C	;Exit with POS_ACE if ACE Selected
13D2  3A D6FF           		LD	A,(POS_BIT)
13D5  C9                		RET


                        ;===============================================
                        ;GET_CHAR -- Get a char from the console NO ECHO
                        ;-----------------------------------------------
                        ;HW_LIST: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP
13D6  CD 1D14           GET_CHAR_NE:	CALL	IN_CHAR
13D9  38 FB             		JR C,	GET_CHAR_NE
13DB  C9                		RET

                        ;===============================================
                        ;GET_CHAR -- Get a char from the console
                        ;-----------------------------------------------
13DC  3A F2FF           GET_CHAR:	LD	A,(ECHO_STATE)
13DF  B7                		OR	A
13E0  28 F4             		JR Z,	GET_CHAR_NE
13E2  CD D613           GET_CHAR_LP	CALL	GET_CHAR_NE
13E5  FE 20             		CP	' '	;Do not echo control chars
13E7  F8                		RET M
                        		;RET		;ECHO THE CHAR
                        				;FALL INTO PUT_CHAR

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Send A byte to Bitbanged RS-232, ACE RS-232 or LED
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
13E8  F5                PUT_CHAR:	PUSH	AF
13E9  C5                		PUSH	BC		;Save registers
13EA  D5                		PUSH	DE
13EB  E5                		PUSH	HL
13EC  4F                		LD	C,A		;Put character to send IN C for shifting

13ED  2A 90FF           		LD	HL,(PUTCHAR_EXE)
13F0  CD A00C           		CALL	VCALL_HL	;JP	(HL)

13F3  E1                		POP HL
13F4  D1                		POP DE
13F5  C1                		POP BC
13F6  F1                		POP AF
13F7  C9                		RET

                        ;Update position of PUT_CHAR (Used later to create aligned columns)
13F8  FE 0D             PC_POS_UPDATE	CP	13
13FA  20 03             		JR NZ,	PC_NCR
13FC  36 00             		LD	(HL),0
13FE  C9                		RET
13FF  FE 20             PC_NCR		CP	' '
1401  F8                		RET M
1402  34                		INC	(HL)
1403  C9                		RET

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;RS-232 RX Buffer Count
1404  E5                RX_COUNT	PUSH	HL
1405  CD 0A14           		CALL	RXC_DO	;Create a routine without stack management
1408  E1                		POP	HL
1409  C9                		RET

140A  3A 92FF           RXC_DO		LD	A,(INCHAR_EXE)	;Test which INCHAR routine is active
140D  FE 13             		CP	LOW IC_BIT
140F  CA 0515           		JP Z,	RXC_BIT
1412  FE CB             		CP	LOW IC_ACE
1414  CA C014           		JP Z,	RXC_ACE
1417  FE 66             		CP	LOW IC_BOTH
1419  28 42             		JR Z,	RXC_BOTH
141B  AF                		XOR	A
141C  C9                		RET


                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Check for A byte
                        ;	Exit:	C=0, A=Byte from Buffer
                        ;		C=1, Buffer Empty, no byte
                        ;		w/call, tcy if no byte = ACE:141, BIT:181, BOTH:269
141D  E5                IN_CHAR:	PUSH	HL		;11
141E  2A 92FF           		LD	HL,(INCHAR_EXE)	;16
1421  CD A00C           		CALL	VCALL_HL	;17 +4 +routine ACE=56, BIT=96, Both=32+ACE+BIT   JP (HL)
1424  E1                		POP HL			;10
1425  C9                		RET			;10


                        ;===============================================
                        ;PURGE - Clears all in coming bytes until the line is clear for a full 2 seconds
                        ;-----------------------------------------------
1426  3E 01             PURGE		LD	A,1	;1 seconds for time out
1428  CD 4714           		CALL	TIMED_GETCHAR
142B  30 F9             		JR NC,	PURGE
142D  C9                		RET

                        ;===============================================
                        ;DOT_GETCHAR
                        ;in:	B=Count of Dots
                        ;out: 	C=1, No Char (Time Out)
                        ;	C=0, A = Char
                        ;-----------------------------------------------
142E  3E 01             DOT_GETCHAR	LD	A,1
1430  CD 4714           		CALL	TIMED_GETCHAR	;C=0, A=Byte from Buffer; C=1, no byte
1433  38 07             		JR  C,	DGC_DOT
1435  FE 09             		CP	9
1437  28 0A             		JR   Z,	DGC_RET
1439  E6 5F             		AND 	0x5F		;to upper case
143B  C9                		RET			;Return to check charcter
143C  3E 2E             DGC_DOT		LD	A,'.'		;Put out some thinking dots
143E  CD E813           		CALL	PUT_CHAR
1441  10 EB             		DJNZ	DOT_GETCHAR
1443  37                DGC_RET		SCF
1444  C9                		RET

                        ;===============================================
                        ;TIMED1_GETCHAR - Gets a character within 1 second
                        ;-----------------------------------------------
1445  3E 02             TIMED1_GETCHAR	LD	A,2

                        ;===============================================
                        ;TIMED_GETCHAR - Gets a character within a time limit
                        ;in:	A contains # of 1/2 seconds to wait before returning
                        ;out: 	C=1, No Char (Time Out)
                        ;	C=0, A = Char
                        ;-----------------------------------------------
1447  D5                TIMED_GETCHAR	PUSH	DE
1448  C5                		PUSH	BC
1449  57                		LD	D,A
144A  0E 0F             TGC_LP1		LD	C,15		;B,C=Loop Count down until timeout
                        					;TEST FOR RX DATA
144C  CD 1D14           TGC_LP2		CALL	IN_CHAR	;ACE:141, BIT:181, BOTH:269	
144F  D2 5A14           		JP NC,	TGC_RET	;10
1452  10 F8             		DJNZ	TGC_LP2	;13/8	;110 Cycles inner Loop time. 164*256/4 ~= 10 mSec
1454  0D                		DEC	C	;5
1455  20 F5             		JR NZ,	TGC_LP2	;10
1457  15                		DEC	D
1458  20 F0             		JR NZ,	TGC_LP1
                        ;		SCF		;CARRY STILL SET TO INDICATE TIME OUT
145A  C1                TGC_RET		POP	BC
145B  D1                		POP	DE
145C  C9                		RET


                        ;-----------------------   B O T H  I/O   -----------------------
                        ;----------------------------------------------------------------
145D  CD 0515           RXC_BOTH	CALL	RXC_BIT
1460  6F                		LD	L,A	
1461  CD C014           		CALL	RXC_ACE
1464  B5                		OR	L
1465  C9                		RET

1466  CD 1315           IC_BOTH		CALL	IC_BIT		;17
1469  D0                		RET	NC		;11/5 RETURN IF CHAR
146A  18 5F             		JR	IC_ACE		;10

146C  CD DC14           PC_BOTH		CALL	PC_ACE
146F  CD 3415           		CALL	PC_BIT
1472  C9                		RET		


                        ;-----------------------   L E D  I/O   -----------------------
                        ;--------------------------------------------------------------
                        ;
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Select Put_Char Output
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1473  E5                LED_HOME	PUSH	HL
1474  21 E0FF           		LD	HL,LED_DISPLAY
1477  22 C8FF           		LD	(LED_CURSOR),HL
147A  E1                		POP	HL
147B  C9                		RET
                        		
147C  E5                LED_CLEAR	PUSH	HL
147D  C5                		PUSH	BC
147E  3E 0C             		LD	A,0x0C
1480  CD 8614           		CALL	PC_LED
1483  C1                		POP	BC
1484  E1                		POP	HL
1485  C9                		RET
                        		

                        ;Put_Char to LED Display, Char in C
1486  2A C8FF           PC_LED		LD	HL,(LED_CURSOR)	;Point to LED Display Buffer
1489  79                		LD	A,C
148A  FE 20             		CP	0x20		;Test for Control/unprintable characters
148C  38 0B             		JR  C,	PCL_CTRL

148E  06 29             		LD	B,HIGH LED_FONT	;Set BC to point to LED FONT
1490  CBB9              		RES	7,C		;Ensure ASCII 0x20-0x7F only
1492  0A                		LD	A,(BC)
1493  CBFF              		SET	7,A		;Ensure TXbit is 1
1495  77                		LD	(HL),A		;Save Character in LED_DISPLAY BUFFER
1496  2C                		INC	L
1497  18 17             		JR	PCL_RET2

1499  FE 0C             PCL_CTRL	CP	0x0C		;<NP>
149B  20 0D             		JR NZ,	PCLC_1
149D  06 08             		LD	B,8		;<NP> Clears LED Line
149F  3E 80             		LD	A,0x80
14A1  21 E0FF           		LD	HL,LED_DISPLAY
14A4  77                PCLC_LP		LD	(HL),A
14A5  2C                		INC	L
14A6  10 FC             		DJNZ	PCLC_LP
14A8  18 03             		JR	PCL_RETC

14AA  FE 0D             PCLC_1		CP	0x0D		;<CR>	Control characters:
14AC  C0                		RET	NZ
14AD  21 E0FF           PCL_RETC	LD	HL,LED_DISPLAY	;<CR> Returns cursor to start of LED Line
14B0  CB9D              PCL_RET2	RES	3,L
14B2  22 C8FF           		LD	(LED_CURSOR),HL
14B5  C9                		RET

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Keyboard Get A byte
                        ;All Keys are equal, but F works as a SHIFT on Press and F on release
                        ;Output:	Z=1, No Key Pressed
                        ;		Z=0, A=Key Pressed, bit 4 = Shift, ie, 0x97 = Shift-7
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
14B6  E5                IC_KEY		PUSH	HL
14B7  21 EFFF           		LD	HL,KEY_PRESSED
14BA  7E                		LD	A,(HL)
14BB  36 00             		LD	(HL),0
14BD  E1                		POP	HL
14BE  B7                		OR	A
14BF  C9                		RET


                        ;-----------------------   A C E  I/O   -----------------------
                        ;--------------------------------------------------------------
                        ;HW_LIST: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP

14C0  3A 94FF           RXC_ACE		LD	A,(HW_SETIO)
14C3  E6 02             		AND	2
14C5  C8                		RET  Z
14C6  DB CD             		IN	A,(ACE_STATUS)
14C8  E6 01             		AND	1		
14CA  C9                		RET

14CB  3A 94FF           IC_ACE		LD	A,(HW_SETIO)	;13
14CE  E6 02             		AND	2		;4
14D0  37                		SCF			;4  C=1, Assume byte NOT available
14D1  C8                		RET  Z			;11/5
14D2  DB CD             		IN	A,(ACE_STATUS)	;11
14D4  E6 01             		AND	1		;4
14D6  37                		SCF			;4  C=1, Assume byte NOT available
14D7  C8                		RET Z			;11/5 Exit if byte not available C=1
14D8  DB C8             		IN	A,(ACE_DATA)
14DA  B7                		OR	A		;Exit with C=0
14DB  C9                		RET

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Put Char ACE,  C=Char to send
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
14DC  3A 94FF           PC_ACE		LD	A,(HW_SETIO)
14DF  E6 02             		AND	2
14E1  C8                		RET  Z
14E2  DB CD             PCA_LP		IN	A,(ACE_STATUS)
14E4  E6 20             		AND	0x20
14E6  28 FA             		JR Z,	PCA_LP
14E8  79                		LD	A,C
14E9  D3 C8             		OUT	(ACE_DATA),A
14EB  21 D7FF           		LD  	HL, POS_ACE
14EE  CD F813           		CALL	PC_POS_UPDATE
14F1  C9                		RET

14F2  3E 80             ACE_SET_BAUD	LD	A,0x80		;Set baud rate
14F4  D3 CB             		OUT	(ACE_LCR),A
14F6  3A 8FFF           		LD	A,(ACE_BAUD)	;12=9600 baud
14F9  D3 C8             		OUT	(ACE_BAUD0),A
14FB  AF                		XOR	A
14FC  D3 C9             		OUT	(ACE_BAUD1),A
14FE  3E 03             		LD	A,3		;Set 8 data bits, no parity, 1 stop
1500  D3 CB             		OUT	(ACE_LCR),A
1502  DB C8             		IN	A,(ACE_DATA)	;Clear any rxd flag
1504  C9                		RET


                        ;-----------------------   B I T  I/O   -----------------------
                        ;--------------------------------------------------------------
1505  3A 94FF           RXC_BIT		LD	A,(HW_SETIO)
1508  E6 01             		AND	1
150A  C8                		RET  Z		
150B  3A CAFF           		LD	A,(RXBHEAD)
150E  21 CCFF           		LD	HL,RXBTAIL
1511  96                		SUB	(HL)		
1512  C9                		RET

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;RS-232 Get A byte
                        ;	Exit:	C=0, A=Byte from Buffer
                        ;		C=1, Buffer Empty, no byte
                        ;		w/call, tcy=87 if no byte
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1513  3A 94FF           IC_BIT		LD	A,(HW_SETIO)	;13
1516  E6 01             		AND	1		;4
1518  37                		SCF			;4  C=1, Assume byte NOT available
1519  C8                		RET  Z			;11/5
151A  C5                		PUSH	BC		;11
151B  3A CAFF           		LD	A,(RXBHEAD)	;13 Test if TAIL=HEAD (=No bytes in buffer)
151E  47                		LD	B,A		;4
151F  3A CCFF           		LD	A,(RXBTAIL)	;13
1522  A8                		XOR	B		;4 Check if byte(s) in receive buffer
1523  C1                		POP	BC		;10
1524  37                		SCF			;4  C=1, Assume byte NOT available
1525  C8                		RET Z			;11 Exit if byte not available (ie TAIL=HEAD), C=1
1526  E5                		PUSH	HL
1527  F3                		DI
1528  2A CCFF           		LD	HL,(RXBTAIL)
152B  2C                		INC	L
152C  22 CCFF           		LD	(RXBTAIL),HL	;Tail = Tail + 1
152F  FB                		EI
1530  7E                		LD	A,(HL)		;A = Byte from buffer (@ TAIL)
1531  E1                		POP	HL
1532  B7                		OR	A		;Exit with C=0
1533  C9                		RET


                        ;Put_Char to RS232 BIT banger
                        ;The bit banged byte to be sent is done through the msb of the LED Display Output byte.
                        ;To simplify AND expedite the sending of those Display bytes (with the RS-232 BIT), the transmitted
                        ;byte will be scattered in a secondary buffer that is 10 bytes (1 start, 8 data, 1 stop)
                        ;This secondary buffer will have the transmitted bits mixed IN with the LED Display Bytes
                        ;The Interrupt is disabled only at crucial moments, but otherwise left on to accept any characters
                        ;received from the RS-232 line
1534  21 D6FF           PC_BIT		LD  	HL, POS_BIT
1537  CD F813           		CALL	PC_POS_UPDATE
153A  21 F6FF           		LD  	HL,LED_DISPLAY_SB
                        				;Copy 10 bytes from the LED_DISPLAY buffer (MOD 8) to the secondary buffer
153D  ED5B D0FF         PC_REDO		LD  	DE,(SCAN_PTR)   ;SCAN_PTR holds the next LED BYTE @ OUTPUT.
1541  43                		LD  	B,E		;Save SCAN_PTR for test if an Interrupt occurs

1542  3A F5FF           		LD	A,(SCAN_LED)
1545  77                		LD  	(HL),A
1546  CBBE              		RES 	7,(HL)	;Configure Start BIT (msb) to be 0

1548  2C                		INC 	L
                        				;Shift next 9 bits IN this loop,
1549  3A 95FF           PC_LP0		LD	A,(HW_LIST)	;Skip other buffer bytes if FP not present
154C  B7                		OR	A
154D  3A F5FF           		LD	A,(SCAN_LED)	;Save for next interrupt
1550  28 04             		JR  Z,	PC_NOFP

1552  1C                		INC 	E
1553  CB9B              		RES 	3,E		;Bound DE to the 8 bytes of LED_DISPLAY
1555  1A                		LD  	A,(DE)
                        		
1556  17                PC_NOFP		RLA		;Bump OUT msb
1557  CB09              		RRC 	C		;Fetch Data BIT (non destructive shifting incase of REDO)
1559  CB1F              		RR  	A		;Shift IN Data BIT
155B  77                		LD  	(HL),A
155C  2C                		INC 	L
155D  20 EA             		JR  	NZ,PC_LP0

155F  2D                		DEC 	L
1560  CBFE              		SET 	7,(HL)	;Stop Bit

1562  2E F6             		LD  	L,LOW LED_DISPLAY_SB  ;Restart Pointer to Secondary Buffer

                        				;Test if SCAN_PTR Changed (due to ISR)
1564  1E 05             		LD  E,5		;Preload RX delay counter (incase of RX byte during TX)
1566  16 80             		LD  D,0x80	;Preload RxD Register with A marker BIT (to count 8 data bits)

1568  F3                		DI		;STOP INTERRUPTS HERE to see if SCAN_PTR has changed (due to Timer Interrupt)
1569  3A D0FF           		LD  A,(SCAN_PTR) ;Adjust working scan pointer (counted to 10 mod 8, so subtract 2 to restore)
156C  A8                		XOR B
156D  28 05             		JR  Z,PC_0
                        				;If SCAN_PTR changed, Redo the Secondary Buffer
156F  FB                		EI		;Allow Interrupts again while preparing Secondary Buffer
1570  CB01              		RLC C		;ADJUST Transmitted bits due to 9 bits shifted (back up 1 BIT)
1572  18 C9             		JR  PC_REDO
                        ;- - - - - - - - - - - - - - - - - - - - - Transmit the BYTE here....(BYTE encoded in temp 10 byte LED buffer)
                        ;1 Bit time at 9600 = 416.6666 cycles

1574  0E 40             PC_0		LD  C,Port40

1576  7E                PC_1		LD  A,(HL)	;7	Send BIT
1577  D3 40             		OUT (Port40),A	;11
1579  06 08             		LD  B,8		;7

157B  ED78              PC_2		IN  A,(C)	;12	;While waiting, Poll for RX DATA Start bit
157D  F2 9B15           		JP  P,PC_5	;10 tc (Note 1.JP)
1580  3A 0000           		LD  A,(0)	;13 tc NOP
1583  10 F6             PC_3		DJNZ PC_2	;13/8  ;48 IN loop (-5 on last itteration).  48 * 8 + 39 - 5 = 418 tc per BIT

1585  2C                		INC L		;4
1586  C2 7615           		JP  NZ,PC_1	;10	;39 TC Overhead to send BIT
1589  C3 1E16           		JP  PC_RET

158C  CB38              PC_4		SRL B		;4	If false start bit detected, Divide B by 2 and return to simple tx
158E  C2 8315           		JP  NZ,PC_3	;10
1591  2C                		INC L		;4
1592  CA 1E16           		JP  Z,PC_RET	;10
1595  7E                		LD  A,(HL)	;7	Send BIT
1596  D3 40             		OUT (Port40),A	;11
1598  C3 7B15           		JP  PC_2	;10


                        				;Here an RX byte was detected while transmitting.
                        				;Delay IN detection could be as much as 60tc, we will assume 1/2 (=30tc)
                        				;We need to test Start Bit @ 208tc,
                        				;We are juggling TX & RX. TX will occur earlier than BIT time due to shorter loop delay
159B  2C                PC_5		INC  L		;4
159C  05                		DEC  B		;4
159D  CA A715           		JP Z,PC_7	;10
15A0  CB20              		SLA  B		;8      Multiply B by 2 for 24 cycle loop
15A2  1D                PC_6		DEC  E		;4	RxBit Timing
15A3  28 0F             		JR   Z,PC_9	;7/12   ;Either before OR after sending A BIT, we will branch OUT of loop here to check for RX Start Bit
15A5  10 FB             		DJNZ PC_6	;13/8 tc TxBit Timing
                        				;		24 tc Loop
                        ;TxBit
15A7  06 0D             PC_7	       	LD  B,13	;7
15A9  AF                		XOR A		;4
15AA  B5                		OR  L		;4
15AB  28 04             		JR  Z,PC_8	;7/12	;Stop sending if L=0
15AD  7E                		LD  A,(HL)	;7	;39 to send next BIT
15AE  D3 40             		OUT (Port40),A	;11
15B0  2C                		INC L		;4
15B1  C3 A215           PC_8		JP  PC_6	;10 tc (Note 1.JP)

                        				;Test if Start Bit is good (at ~1/2 BIT time)
15B4  1E 05             PC_9		LD  E,5		;7   E=5 incase we have a bad start bit and have to return to simple TX
15B6  ED78              		IN  A,(C)	;12  Re-TEST Start Bit at 1/2 bit time
15B8  FA 8C15           		JP  M,PC_4	;10  If Start BIT not verified, then return to simple TXD (return at point where we are Decrementing B to minimize diff)
15BB  1E 0F             		LD  E,15	;7   Adjust initial sampling delay (as per timing observed)


                        				;At this point, we have good start BIT, 1 OR more TX bits left to go...  here's where timing is accurate again
                        				;We will go through each TXbit AND RXBit once during the full BIT time.  So the time of these routines are added
15BD  1D                PC_10		DEC E		;4
15BE  28 14             		JR  Z,PC_14	;7/12
15C0  10 FB             PC_11		DJNZ PC_10	;13/8 tc    24Loop= 6uSec

                        				; TX= S 0 1 2 3 4 5 6 7 S
                        				; RX=  S 0 1 2 3 4 5 6 7 S  <-It's possible to receive all 8 data bits before sending Stop Bit
                        ;TxBit ;54tc to Send BIT
15C2  AF                		XOR A		;4
15C3  B5                		OR  L		;4
15C4  28 09             		JR  Z,PC_13	;7/12	;Stop sending if L=0
15C6  7E                		LD  A,(HL)	;7
15C7  D3 40             		OUT (Port40),A	;11
15C9  2C                		INC L		;4
15CA  06 0D             PC_12        	LD  B,13	;7     (417 - 54 - 51)/24 = 13 counts required to pace 1 BIT
15CC  C3 BD15           		JP  PC_10	;10 tc (Note 1.JP)

15CF  06 0D             PC_13		LD  B,13	;7     (7tc NOP)
15D1  C3 CA15           		JP  PC_12	;10 tc (Note 1.JP)

                        ;RxBit ;51tc to Receive BIT
15D4  DB 40             PC_14		IN   A,(Port40)	;11	Fetch RXbit
15D6  00                		NOP		;4
15D7  07                		RLCA		;4	put IN CARRY
15D8  CB1A              		RR    D		;8	shift into RxD
15DA  1E 0D             		LD    E,13	;7      (417 - 54 - 51)/24 = 13 counts required to pace 1 BIT
15DC  38 03             		JR C, PC_15	;7/12	;Test for marker BIT shifting OUT of D
15DE  C3 C015           		JP    PC_11	;10	RXBIT = 40tc

15E1  00                PC_15		NOP		;4
15E2  1D                PC_16		DEC  E		;4
15E3  28 14             		JR Z,PC_19	;7/12
15E5  10 FB             		DJNZ PC_16	;13/8 tc    24Loop= 6uSec

                        				; TX= S 0 1 2 3 4 5 6 7 S
                        				; RX=  S 0 1 2 3 4 5 6 7 S  <-It's possible to receive all 8 data bits before sending Stop Bit
                        ;TxBit ;54tc to Send BIT
15E7  AF                		XOR  A		;4
15E8  B5                		OR   L		;4
15E9  28 09             		JR Z,PC_18	;7/12	;Stop sending if L=0
15EB  7E                		LD   A,(HL)	;7
15EC  D3 40             		OUT (Port40),A	;11
15EE  2C                		INC  L		;4
15EF  06 0D             PC_17        	LD   B,13	;7     (417 - 54 - 51)/24 = 13 counts required to pace 1 BIT
15F1  C3 E215           		JP   PC_16	;10 tc (Note 1.JP)

15F4  06 0D             PC_18		LD   B,13	;7     (7tc NOP)
15F6  C3 EF15           		JP   PC_17	;10 tc (Note 1.JP)



                        ;RxBit ;51tc to Receive BIT
15F9  DB 40             PC_19		IN  A,(Port40)	;11	Fetch Stop BIT
15FB  07                		RLCA		;4	put IN CARRY
15FC  DA 0516           		JP C,PC_20
15FF  21 8DFF           		LD   HL,RX_ERR_STOP
1602  CD 260E           		CALL TINC

1605  7A                PC_20		LD  A,D		;Fetch received byte to RX Buffer
1606  2A CAFF           		LD  HL,(RXBHEAD)
1609  2C                		INC L
160A  22 CAFF           		LD  (RXBHEAD),HL ;Head = Head + 1
160D  77                		LD  (HL),A	;Stuff into RX BUFFER
160E  3A CCFF           		LD  A,(RXBTAIL)
1611  BD                		CP  L
1612  20 0A             		JR  NZ,PC_RET	;Jump if NOT Zero = No Over run error (Head <> Tail)
1614  3C                		INC A		;Else
1615  32 CCFF           		LD  (RXBTAIL),A	;Tail = Tail + 1
1618  21 8EFF           		LD   HL,RX_ERR_OVR ;Count Over Run Error
161B  CD 260E           		CALL TINC

161E  3A 95FF           PC_RET		LD	A,(HW_LIST)	;Skip Resync if FP not present
1621  B7                		OR	A
1622  28 11             		JR  Z,	PC_RET1

1624  DB 40             		IN	A,(Port40)	;Resync the SCAN_PTR
1626  3C                		INC	A
1627  E6 07             		AND	7
1629  F6 E0             		OR  LOW LED_DISPLAY
162B  6F                		LD	L,A
162C  32 D0FF           		LD	(SCAN_PTR),A	;Save Scan Ptr @ Next Scan Output
162F  26 FF             		LD	H,HIGH SCAN_PTR
1631  7E                		LD	A,(HL)
1632  32 F5FF           		LD	(SCAN_LED),A	;Save for next interrupt		
1635  FB                PC_RET1		EI
1636  C9                		RET


                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_11	ISR.  RS-232 Receive, LED & Keyboard scanning, Timer tic counting
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;

                        ;                       *********   *******    ********
                        ;                       *********  *********   *********
                        ;                          ***     **     **   **     **
                        ;                          ***     **          **     **
                        ;---------------------     ***     *******     ********   ---------------------
                        ;---------------------     ***       *******   ********   ---------------------
                        ;                          ***            **   **  **
                        ;                          ***     **     **   **   **
                        ;                       *********  *********   **    **
                        ;                       *********   *******    **     **
                        ;
                        ;
                        ;
                        ;The ISR will service either the Timer interrupt or Serial Data (bit banger) interrupt.
                        ;
                        ;The ISR will re-enable interrupts during Timer functions for re-entry to catch Serial Data.
                        ;
                        ;
                        ;The INT calls RST 38.  RST38 is the same in ROM or RAM.
                        ;
                        ;**RST38--------Switch to the Alternate Register set, jump to ISR_VEC (typcially ISR_DISPATCH)
                        ;**ISR_DISPATCH-Direct Select ROM, Check input port, jump to ISR_RXD (RS-232) or ISR_TIMER
                        ;**ISR_RXD------Bit Bang a byte, store in RXBUFFER, jump to ISR_RET
                        ;**ISR_TIMER----Output LED (Clears TIMER_INT), enter Extended Timer or jump to ISR_RET (If
                        ;		already executing the extended Timer)
                        ;ISR_EXTIMER----RAM/ROM state, set to ROM. Use ISR Stack, Undo Alternate Registers, EI, PUSH HL, AF
                        ;		Resync LED to scan, Do Halt Test (jump BREAK_RET), Run TicCounter (1mSec),
                        ;		Do extra extended timer to complete keypad scans every 32mSec or exit EXTIMER
                        ;ISR_EXXTIMER---Scan Keypad for events, do Keyevents as they occur to control LED output,
                        ;		update LED output, <Ctrl>-C Test (jump BREAK_RET), Call User Interrupt Vector
                        ;		Keypad Event F-E causes jump to BREAK_RET
                        ;		Single Step causes jump to BREAK_RET
                        ;ISR_EXTIMER_RET POP AF, HL. Restore Stack, Restore RAM/ROM state, Switch to Alternate Registers for RET
                        ;**ISR_RET------Select RAM/ROM state as tracked in Mainline code, Undo Alternate Registers, EI. RETI
                        ;BREAK_RET------Leaves the ISR to return to 0000 and restart the monitor.

                        ;** = ISR RUNNING ON ALTERNATE REGSITERS (**IROAR**)

                        ;
                        ;
                        ;	Normal timer interrupt takes 463 cycles  (??? outdated counts)
                        ;	42  ISR Vectoring & Redirection
                        ;	50  Timer Int Detection
                        ;	28  LED Refresh (Re-enable Interrupts)
                        ;	78  Resync & Prepare next LED Refresh value
                        ;	111 Halt Test
                        ;	38  TIC Counter
                        ;	21  Keyboard/Display maintenance required check
                        ;	41  User Interrupt Check
                        ;	34  ISR Exit
                        ;
                        ;	Occuring 8 out of 32 ISR's:
                        ;	82  Scanning non pressed keys
                        ;
                        ;	Occuring 1 out of 32 ISR's
                        ;	165 Processing non pressed keys
                        ;	97  Ctrl-C Checking
                        ;	67  Beeper Timer
                        ;	31  Cmd Expiration Timer
                        ;	262 Display Memory contents
                        ;	649 Display Register contents
                        ;
                        ;	24/32 ISR's = 463 cycles	= 11,112
                        ;	7/32  ISR's = 545 cycles    	=  3,815
                        ;	1/32  ISR's = 1,554 cycles	=  1,554 (Displaying Register)
                        ;	Total over 32 ISR's		= 16,481
                        ;	Average per ISR = 515 cycles
                        ;			= 128.75uS used every 1024uS interrupt cycle
                        ;			= 13% ISR Overhead (When Displaying Register)
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;Note: A start bit can still hijack the ISR at Dispatch.
                        ;
                        ;A start bit happening anywhere in mainline code will take ~???tc to reach ISR_RXD
                        ;A start bit happening upon entry to ISR_DISPATCH (when doing timer int) will take ??tc to reach ISR_RXD
                        ;A start bit happening just past the ISR_DISPATCH window of opportunity will take
                        ;
                        ;ISR_DISPATCH Sort out what is causing the interrupt
                        ;


                        ;- - - - - - - - - - - - - - RS-232 Receive BYTE
                        ;
                        ;1 Bit time at 9600 = 416.6666 cycles	;We get here ~25 to 200 tc (range = 175tc = 1/2 bit time)
                        ;**IROAR**
1637  2E 02             ISR_RXD		LD   L,2	;7
1639  DB 40             IRXD_VS		IN   A,(Port40)	;11	;Re-sample Start BIT @+7, +35tc
163B  07                		RLCA		;4	;(Actual sampling occurs 9 OR 10 tc later)
163C  38 3E             		JR   C,IRXD_INC	;7/12
163E  2D                		DEC  L		;4
163F  20 F8             		JR  NZ,IRXD_VS	;7/12
                        				;35tc per loop
                        				;@+68 when we come OUT of loop
                        				;
                        				;=~93tc to ~268tc  Middle = 180
                        				;
                        				;Must have a total delay of 1.5 bits 625 to reach middle of 1st data BIT
                        				;Total delay: 1.5 * 416 = 625tc
                        				;Next bit is at 417tc to 834tc
                        				;625-180 = Need another 445 Delay
                        		

                        				;My cycle counting is off by at least 30uSec = 120tc
                        				;Changed 26 to 20.  20*16-5=315 (411-315=96)

                        		
1641  3E 16             		LD   A,22	;7	;Delay loop after START Bit
1643  3D                		DEC  A		;4
1644  20 FD             		JR   NZ,$-1	;12/7	Delay loop = 26 * 16 - 5 = 411


                        ;- - - - - - - - - - - - - - RS-232 Receive BYTE
1646  2E 08             		LD   L,8	;7
                        				;@624	;Loop through sampling 8 data bits
1648                    IRXD_NB		
1648  DB 40             		IN   A,(Port40)	;11	;Sample BIT
164A  07                		RLCA		;4	;Get BIT
164B  CB1C              		RR   H		;8	;Shift IN
164D  2D                		DEC  L		;4	;Count down 8 bits
                        	;	JR   Z,IRXD_STP	;7/12	;Use this jump to test for STOP bit

164E  28 14             		JR  Z,IRXD_SAVE	;7/12	Optional to finish receiving byte here AND ignore framing errors
                        				;	(Replace the previous condital jump with IRXD_SAVE destination).

1650  3E 17             IRXD_NI		LD  A,23	;7	;Delay loop between data bits
1652  3D                		DEC A		;4
1653  20 FD             		JR  NZ,$-1	;12/7	;Delay loop = 16 * 23 + 53 - 5 = 416
1655  18 F1             		JR  IRXD_NB	;12	;Total Overhead = 53
                        				;Time to get all data bits = 416 * 7 + 39 = 2951 (last BIT does not get full delay)
                        				
                        				;@3576  (we wish to sample stop BIT @3958) (need to delay another 382)				
1657  3E 17             IRXD_STP	LD  A,23	;7	;Delay loop before STOP BIT
1659  3D                		DEC A		;4
165A  20 FD             		JR  NZ,$-1	;12/7	;Delay loop =
165C  DB 40             		IN  A,(Port40)	;11	;NOP for 11tc
165E  DB 40             		IN  A,(Port40)	;11	;Sample Stop BIT @3957
1660  B7                		OR  A		;4	;(Actual sampling occurs 9 OR 10 tc later)
1661  F2 8116           		JP  P,IRXD_BAD

1664  7C                IRXD_SAVE	LD  A,H		;4	;Fetch received byte
1665  2A CAFF           		LD  HL,(RXBHEAD) ;16	;Advance Head Ptr of RX Buffer, Head = Head + 1
1668  2C                		INC L		;4
1669  22 CAFF           		LD  (RXBHEAD),HL ;16
166C  77                		LD  (HL),A	;7	;Save Received byte into RX Buffer
                        		
                        		

                        		
166D  3A CCFF           		LD  A,(RXBTAIL)	;13	;Test if buffer has over ran
1670  BD                		CP  L		;4	;If Tail = Head Then Tail = Tail + 1 & Flag overrun
1671  20 14             		JR NZ,IRXD_RESET ;Return if NO overrun error
                        				
1673  3C                		INC A		;Lose A BYTE in buffer and count the overrun
1674  32 CCFF           		LD  (RXBTAIL),A

1677  21 8EFF           		LD   HL,RX_ERR_OVR
167A  18 08             		JR 	IRXD_TINC
167C  21 8CFF           IRXD_INC	LD   HL,RX_ERR_LDRT ;10
167F  18 03             		JR 	IRXD_TINC
1681  21 8DFF           IRXD_BAD	LD  HL,RX_ERR_STOP
1684  CD 260E           IRXD_TINC	CALL TINC

1687  3A 95FF           IRXD_RESET	LD	A,(HW_LIST)	;Skip Resync if FP not present
168A  B7                		OR	A
168B  28 13             		JR  Z,	IRXD_WS

168D  DB 40             		IN	A,(Port40)	;Resync the SCAN_PTR
168F  3C                		INC	A
1690  E6 07             		AND	7
1692  F6 E0             		OR  LOW LED_DISPLAY	;LED_DISPLAY is at xxEO (it's ok to overlap in this order)
1694  32 D0FF           		LD	(SCAN_PTR),A	;Save Scan Ptr @ Next Scan Output

1697  2A D0FF           		LD	HL,(SCAN_PTR)	;Fetch next byte to output
169A  7E                		LD	A,(HL)
169B  D3 40             		OUT	(Port40),A	;Output ASAP to satisfy Interrupt Flag
169D  32 F5FF           		LD	(SCAN_LED),A	;Save for next interrupt

16A0  DB 40             IRXD_WS		IN   	A,(Port40)	;11	;Sample BIT
16A2  07                		RLCA		;4	;Get BIT
16A3  30 FB             		JR  NC,	IRXD_WS		;Wait for STOP bit

16A5  C3 3BFB           		JP	ISR_RET

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Timer Tics
                        ;Refresh next LED Display
                        ;**IROAR**
16A8  3A F5FF           ISR_TIMER	LD	A,(SCAN_LED)	;13 ZMC-Display Refresh / Reset Int
16AB  D3 40             		OUT	(Port40),A	;11 Output ASAP to satisfy Interrupt Flag

16AD  21 D8FF           		LD	HL,ISR_FLAGS	;10
16B0  CB46              		BIT	0,(HL)		;12
16B2  C2 3BFB           		JP  NZ,	ISR_RET		;10

16B5                    ISR_EXTIMER	;Extended Timer Int.
                        					;If ISR NEST level = 0 then save the stack and run on ISR Stack

16B5  CBC6              		SET	0,(HL)		;ISR_FLAGS (Prevent addition entries to this routine)

16B7  ED73 28FB         		LD	(SP_ISR_SAVE),SP ;20 ;ALTERNATE TIMER STACK
16BB  31 28FB           		LD	SP,STACK_ISR1	;10  ;ALTERNATE TIMER STACK

16BE  2C                		INC	L		;RRSTATE
16BF  CB06              		RLC	(HL)		;RRSTATE.0=0 Additional interrupts shall return to ROM
                        					;RRSTATE.1=RRSTATE.0 Save RAM/ROM selection for exit from this TIMER ISR
                        	
16C1  08                		EX	AF,AF'		;Revert to regular registers in the event of another interrupt.
16C2  FB                		EI			;4  Allow RXD interrupts
16C3  D9                		EXX

                        ;Time critical functions are over.  		
                        ;We've entered an interrupt and want to stay in for a while to update the front panel.
                        ;But we want serial interrupts to be allowed to continue
                        ;Alternate registers have been relinquished for other Interrupts.
                        ;Must Push our own.

                        ;On First entry here, we have a new stack, old stack is saved at SP_ISR_SAVE and return address is on the old stack

16C4  E5                		PUSH	HL
16C5  F5                		PUSH	AF

                        					;********************************* Tic counter - Advance
16C6  2A F0FF           		LD	HL,(TicCounter)	;16 Advance Timer Counter
16C9  23                		INC	HL		;6
16CA  22 F0FF           		LD	(TicCounter),HL	;16
                        					;st=38

16CD  3A 95FF           		LD	A,(HW_LIST)	;Exit ISR if FP not present
16D0  B7                		OR	A
16D1  28 29             		JR  Z,	ISR_EXTIMER_RET

                        					;********************************* SCAN RESYNC
16D3  DB 40             		IN	A,(Port40)	;11 Resync the SCAN_PTR
16D5  3C                		INC	A		;4  Advance to next column to match column after next OUT
16D6  E6 07             		AND	7		;7
16D8  F6 E0             		OR  LOW LED_DISPLAY	;7  LED_DISPLAY is at xxEO (it's ok to overlap in this order)
16DA  32 D0FF           		LD	(SCAN_PTR),A	;13 Save Scan Ptr @ Next Scan Output
16DD  2A D0FF           		LD	HL,(SCAN_PTR)	;16 Fetch next byte to output
16E0  7E                		LD	A,(HL)		;7
16E1  32 F5FF           		LD	(SCAN_LED),A	;13 Save for next interrupt
                        					;st=78


                        					;********************************* HALT TEST
16E4  2A D2FF           		LD	HL,(HALT_TEST)	;Ignore HALT Test in SD Card Mode
16E7  E9                		JP	(HL)
16E8                    DO_HALT_TEST
16E8  2A 28FB           		LD	HL,(SP_ISR_SAVE);10 Get PC
16EB  CD 4A0E           		CALL	LD_HL_HL	;17+43
16EE  2B                		DEC	HL		;6
16EF  7E                		LD	A,(HL)		;7 Fetch Previous Instruction
16F0  FE 76             		CP	0x76		;7 Is HALT?
16F2  CA FE17           		JP  Z,	ICMD_BREAK_RET	;10
                        					;st=111
16F5                    SKIP_HALT_TEST


                        ;Keyboard / Display Update / Keyboard Commands or Entry
                        					;********************************* KEYBOARD SCANNING
16F5  21 DAFF           		LD	HL,XTIMER_TIC
16F8  35                		DEC	(HL)
16F9  FA 1017           		JP  M,	ISR_EXXTIMER
                        		
                        ;*************************************************** EXIT THE EXTENDED (INTERRUPTABLE) ISR

16FC  F1                ISR_EXTIMER_RET	POP	AF
16FD  E1                		POP	HL

16FE  F3                		DI
16FF  ED7B 28FB         		LD	SP,(SP_ISR_SAVE) ;RESUME SAVED STACK

1703  08                		EX	AF,AF'		;Swap Registers for Jump Back
1704  D9                		EXX

1705  21 D8FF           		LD	HL,ISR_FLAGS
1708  CB86              		RES	0,(HL)		;Reset NEST level to 0

170A  2C                		INC	L		;RRSTATE
170B  CB0E              		RRC	(HL)		;RRSTATE.0=RRSTATE.1 Restore RAM/ROM selection
170D  C3 3BFB           		JP	ISR_RET

                        ;Somewhere in High RAM...
                        ;
                        ;ISR_RET	LD	A,(RRSTATE)	;Restore RAM/ROM selection
                        ;		OUT	(RAMROM),A
                        ;		EX	AF,AF'		;Restore swapped Registers
                        ;		EXX
                        ;		EI
                        ;		RETI			;Return to Mainline code


1710                    ISR_EXXTIMER				;Extra Extended Timer (8 times every 32mSec)

1710  DB 40             		IN	A,(Port40)	;11 Read KEY down & ScanPtr
1712  21 E9FF           		LD	HL,KBPORTSAMPLE	;10
1715  77                		LD	(HL),A
1716  E6 07             		AND	7
1718  6F                		LD	L,A		;HL->BIT_TABLE
1719  7E                		LD	A,(HL)
171A  2E E8             		LD	L,LOW KBCOLSAMPLED ;HL->KBCOLSAMPLED
171C  B6                		OR	(HL)
171D  77                		LD	(HL),A		;Save bit map of columns sampled
                        				
171E  23                		INC	HL		;HL->KBPORTSAMPLE
171F  7E                		LD	A,(HL)
1720  E6 07             		AND	7
1722  CB5E              		BIT 	3,(HL)		;8  Test ROW-0
1724  20 05             		JR  NZ,	IKEY0_UP	;12 Jump if key UP
1726  F6 80             		OR	0x80		;Flag a Key is down
1728  23                		INC	HL		;HL->KBHEXSAMPLE
1729  77                		LD	(HL),A		;Save HEX key
172A  2B                		DEC	HL		;HL->KBPORTSAMPLE
                        		
                        					;Sample input again for Row-1 test
172B                    IKEY0_UP
172B  CB66              		BIT 	4,(HL)		;8 Test ROW-1
172D  20 05             		JR  NZ,	IKEY1_UP	;12 Jump if key UP
172F  F6 88             		OR	0x88		;Flag a key is down AND set bit 3 so key is between 8 and E
1731  23                		INC	HL		;HL->KBHEXSAMPLE
1732  77                		LD	(HL),A		;Save HEX key
1733  2B                		DEC	HL		;HL->KBPORTSAMPLE
                        		
1734                    IKEY1_UP		
                        					;   Test for all columns Scanned
1734  2B                		DEC	HL		;HL->KBCOLSAMPLED
1735  7E                		LD	A,(HL)		;   *ALL keys scanned when KBCOLSAMPLED = 0xFF
1736  3C                		INC	A		;4
1737  C2 F217           		JP  NZ,	IKEY_SCAN_END	;10
                        		
173A  77                		LD	(HL),A		;KBCOLSAMPLED = 0x00 for next Scan

                        ;- - - - - - - - - - - - - - - - - - - - - - - -
                        ;Keys and Display update on Column 7 Only
                        		
173B  23                		INC	HL		;HL->KBPORTSAMPLE
173C  CB6E              		BIT 	5,(HL)		;8  Test F KEY
173E  28 07             		JR  Z,	IKEYF_UP	;12 Jump if key UP
                        					;When F key is down, it can serve as either F or Shift.
                        					;
1740  3A C1FF           		LD	A,(KEYBFMODE)	;Check the F MODE (shift key or HEX key)
1743  23                		INC	HL		;HL->KBHEXSAMPLE
1744  B6                		OR	(HL)		;8F=HEX INPUT, 90=Shiftable
                        					;so when F is pressed:
                        					;  If 8F it overrides all the other keys and KBHEXSAMPLE=8F
                        					;  If 90 it OR's with KBHEXSAMPLE to become 9X where X is previous key held down
1745  77                		LD	(HL),A		;Save HEX key
1746  2B                		DEC	HL		;HL->KBPORTSAMPLE
                        		
1747                    IKEYF_UP


                        ;-Keyboard Scanning, only after scanning Column 7 we are here with the following:
                        ;	KeyPad	KBHEXSAMPLE
                        ;	no-key	0000 0000
                        ;	  0	1000 0000
                        ;	  1	1000 0001
                        ;	  2	1000 0010
                        ;	  3	1000 0011
                        ;	  4	1000 0100
                        ;	  5	1000 0101
                        ;	  6	1000 0110
                        ;	  7	1000 0111
                        ;	  8	1000 1000
                        ;	  9	1000 1001
                        ;	  A	1000 1010
                        ;	  B	1000 1011
                        ;	  C	1000 1100
                        ;	  D	1000 1101
                        ;	  E	1000 1110
                        ;	  F	1000 1111
                        ;	  ^F			1001 xxxx (xxxx=any key pressed during the scan from Column 0)

1747  23                		INC	HL		;HL->KBHEXSAMPLE
1748  7E                		LD	A,(HL)		;7  Get new HEX sample		
1749  36 00             		LD	(HL),0		;10 Zero KBHEXSAMPLE for next scan
174B  21 DAFF           		LD	HL,XTIMER_TIC
174E  36 14             		LD	(HL),20		;Start new Scan in 20 Tics

1750                    IKEY_DEBOUNCE	;A=current key scan or 0x00 for no key.
1750  2A EBFF           		LD	HL,(KEYBSCANPV) ;16 Get previously saved scanned key and timer
1753  BD                		CP	L		;4
1754  28 03             		JR  Z,	IKEYP_NCOS	;12 Jump if NO Change of State
1756  26 03             		LD	H,3		;Timer = 3 (Controls how sensitive the keyboard is to Key Inputs)
1758  6F                		LD	L,A		;Previous scan=current scan

1759  25                IKEYP_NCOS	DEC	H		;4  Timer = Timer - 1
175A  22 EBFF           		LD	(KEYBSCANPV),HL	;16 Save previous scan & timer
175D  CA 6F17           		JP  Z,	IKEYP_EVENT	;10 Jump when Timer = 0
1760  F2 AA17           		JP  P,	IK_NOKEY_EVENT	;10 Jump when Timer = 1 to 7F
                        					
                        					;When Timer underflows to FF, we can use the range from FF to 80
                        					;to perform time delayed auto repeat for the key.
                        					
1763  3E D0             		LD	A,0xD0		;Sets when to repeat (closer to FF, faster)
1765  BC                		CP	H
1766  C2 AA17           		JP  NZ, IK_NOKEY_EVENT
                        					;Timer then "lives" between D4 and D0 causing auto repeat of
                        					;present key pressed (even if it's no key).
                        		
1769  3E D4             		LD	A,0xD4		;Sets how fast to repeat (closer to "when to repeat" faster)
176B  32 ECFF           		LD	(KEYBSCANTIMER),A ;Save timer
176E  7D                		LD	A,L		;Fetch keyscan


176F                    IKEYP_EVENT	;A=current key scan or 0x00 for no key (either after debounce or as repeat)
176F  21 EDFF           		LD	HL,KEY_PRES_EV	;Point HL to previously saved/processed Key
1772  B7                		OR	A
1773  28 0F             		JR  Z,	IK_KEYUP_EVENT
                        		
1775                    IKEYP_EVENT_DN				;When A<>0, It's a KEY DOWN EVENT
1775  FE 90             		CP	0x90		;Is it Shift key down?
1777  C2 9217           		JP  NZ,	IK_KEYDN_EVENT	;Jump to process key down if it's NOT a shift key
                        					;Special consideration given here for Shift Key down.

177A  CB66              		BIT	4,(HL)		;Test bit 4 of KEY_PRES_EV (previously saved/processed key)
177C  77                		LD	(HL),A		;Save the 0x90 to KEY_PRES_EV
                        					;Exit with just the Shift Key pressed (wait for the next shifted key to come in)
177D  CA DB17           		JP  Z,	IKEY_DONE	;If previously saved key was not a shifted key, keep the 0x90
                        					;If shift key is held down long enough to repeat, it then becomes F key
1780  3D                		DEC	A		;Otherwise, reduce the shift key to a simple "F" key (0x90 - 1 = 0x8F)
1781  C3 9217           		JP	IK_KEYDN_EVENT

1784                    IK_KEYUP_EVENT	;*************************************************** KEY UP EVENT
                        					;When A=0, It's a KEY UP EVENT
1784  23                		INC	HL
1785  36 00             		LD	(HL),0
1787  2B                		DEC	HL
1788  7E                		LD	A,(HL)		;Fetch the previous key down code
1789  FE 90             		CP	0x90
178B  C2 DB17           		JP  NZ,	IKEY_DONE	;Exit if not the shift key going up
                        					;Otherwise, if it was the Shift key going up....
178E  3D                		DEC	A  ;90->8F	;replace it with a simple "F" key
                        		;JP	IK_KEYDN_EVENT	;and execute the key down event.
178F  23                		INC	HL
1790  77                		LD	(HL),A
1791  2B                		DEC	HL


1792                    IK_KEYDN_EVENT	;*************************************************** KEY DOWN EVENT
1792  77                		LD	(HL),A		;Save Last Key Down (for Shift Testing)
1793  23                		INC	HL
1794  BE                		CP	(HL)
1795  28 05             		JR   Z,	IK_RTN
1797  34                		INC	(HL)
1798  35                		DEC	(HL)
1799  20 0F             		JR  NZ,	IK_NOKEY_EVENT
179B  77                		LD	(HL),A

179C  21 E7FF           IK_RTN		LD	HL,LED_ANBAR
179F  CBC6              		SET	0,(HL)		;ANBARLED 0 = BEEPER
17A1  21 B2FF           		LD	HL,BEEP_TO
17A4  CBCE              		SET	1,(HL)		;Time out beep in 2 counts

17A6  2A BEFF           		LD	HL,(KEY_EVENT)
17A9  E9                		JP	(HL)
                        ;KEY_EVENT_DISPATCH
                        ;Execute different routines based on Users actions.
                        ;Possible choices within this firmware include:
                        ;IMON_CMD	- Menu Command Input (default and initial setting).  Resets to this even upon IKC_RESET_CMD
                        ;ICMD0_R	- HEX Input Mode to select a Register (valid input is 0-12 for the 13 registers). Value saved in RegPtr.
                        ;ICMD_BYTE	- BYTE Input Mode. IK_HEXST tracks state machine of routine. IK_HEXH store the value.  Execute @HEX_READY when done.
                        ;ICMD_WORD	- WORD Input Mode. IK_HEXST tracks state machine of routine. IK_HEXH & IK_HEXL store the value.  Execute @HEX_READY when done.
                        ;ISET_PRESSED	- Saves Key Pressed for User, does not process any keys.

17AA                    IK_NOKEY_EVENT	;*************************************************** NO KEY EVENT


                        					;********************************* <Ctrl>-C Checking
17AA  2A B8FF           		LD	HL,(CTRL_C_CHK)	;16 <Ctrl>-C check +77
17AD  E9                		JP	(HL)		;4
                        					;st=97
17AE                    CTRL_C_RET

17AE  21 C0FF           		LD	HL,IK_TIMER	;10
17B1  7E                		LD	A,(HL)		;7 Time out any pending Monitor Input
17B2  B7                		OR	A		;4
17B3  CA DB17           		JP Z,	IKEY_DONE	;10 st=31
17B6  35                		DEC	(HL)
17B7  C2 DB17           		JP NZ,	IKEY_DONE

                        					;IK Timer Expired Event
17BA                    IKC_RESET_CMD				;Upon time out, return monitor to CMD input
17BA  2A BAFF           		LD	HL,(LDISPMODE)
17BD  22 BCFF           		LD	(DISPMODE),HL
17C0  21 3E18           		LD	HL,IMON_CMD
17C3  22 BEFF           		LD	(KEY_EVENT),HL
17C6  21 C1FF           		LD	HL,KEYBFMODE	;Shiftable Keyboard
17C9  36 90             		LD	(HL),0x90

17CB  3A B3FF           IKC_REFRESH	LD	A,(ANBAR_DEF)	;Refresh Display
17CE  32 E7FF           		LD	(LED_ANBAR),A
17D1  3E FF             IKR_QREFRESH	LD	A,-1
17D3  32 C3FF           		LD	(IK_HEXST),A	;Zero HEX Input Sequencer
17D6  3E 01             		LD	A,1		;Force Quick Refresh of Label
17D8  32 C2FF           		LD	(DISPLABEL),A
                        		;JP	IKEY_DONE
17DB                    IKEY_DONE


                        		;*************************************************** UP DATE LED DISPLAY
17DB  2A BCFF           		LD	HL,(DISPMODE)	;16 +242 (for Display Memory)
17DE  E9                		JP	(HL)		;4
17DF                    IDISP_RET
17DF  21 B2FF           		LD	HL,BEEP_TO	;10
17E2  35                		DEC	(HL)		;11
17E3  28 07             		JR Z,	IKEY_NO_BEEP	;10
17E5  21 E7FF           		LD	HL,LED_ANBAR	;10  ANBARLED 0 = BEEPER
17E8  CBC6              		SET	0,(HL)		;15	BEEP ON WHEN BEEP_TO > 1
17EA  18 06             		JR	IKEY_SCAN_END
                        		
17EC  34                IKEY_NO_BEEP	INC	(HL)		;11
17ED  21 E7FF           		LD	HL,LED_ANBAR	;10
17F0  CB86              		RES	0,(HL)		;15  ANBARLED 0 = BEEPER
                        					;st=67
                        					
17F2                    IKEY_SCAN_END	

17F2  2A B0FF           		LD	HL,(UiVec)	;16  Do a User Interrupt Vector
17F5  CD A00C           		CALL	VCALL_HL
17F8  C3 FC16           		JP	ISR_EXTIMER_RET

17FB  C9                UiVec_RET	RET			;Default Return for UiVec

17FC  3E FE             ICMD_BREAK	LD	A,0xFE
17FE  32 DFFF           ICMD_BREAK_RET	LD	(SOFT_RST_FLAG),A	;FE=RESTART, D1=SINGLE STEP, F6=HALT, CC=<Ctrl>-C
1801  3A B3FF           		LD	A,(ANBAR_DEF)	;Soft Restart only allowed while in Run Mode
1804  E6 02             		AND	2		;Run mode LED
1806  CA DB17           		JP  Z,	IKEY_DONE

1809  F3                		DI
180A  F1                		POP	AF
180B  E1                		POP	HL
180C  ED7B 28FB         		LD	SP,(SP_ISR_SAVE)
1810  C3 0000           		JP	0
                        		
1813  2A CAFF           CTRL_C_TEST	LD	HL,(RXBHEAD)	;16
1816  7E                		LD	A,(HL)		;7
1817  21 DEFF           		LD	HL,CTRL_C_TIMER	;10
181A  FE 03             		CP	3		;7  Compare <Ctrl>-C
181C  CA 2118           		JP  Z,	CTRL_C_IN_Q	;10
181F  36 0A             		LD	(HL),10		;10
1821  35                CTRL_C_IN_Q	DEC	(HL)		;7
1822  C2 AE17           		JP  NZ,	CTRL_C_RET	;10  st=77
1825  3E CC             		LD	A,0xCC
1827  C3 FE17           		JP	ICMD_BREAK_RET

182A  21 1318           CTRL_C_CHK_ON	LD	HL,CTRL_C_TEST
182D  22 B8FF           		LD	(CTRL_C_CHK),HL
1830  C9                		RET
1831  21 AE17           CTRL_C_CHK_OFF	LD	HL,CTRL_C_RET
1834  22 B8FF           		LD	(CTRL_C_CHK),HL
1837  C9                		RET



                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Keyboard Monitor
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;

                        ;============================================================================
                        ; No Keyboard activity, Save Key for User.
1838  32 EFFF           ISET_PRESSED	LD	(KEY_PRESSED),A
183B  C3 DB17           		JP	IKEY_DONE


                        ;============================================================================
                        ;	IMON - Monitor Loop
                        ;
                        ; This is the main executive loop for the Front Panel Emulator, Dispatch the Command
                        ;============================================================================
183E  21 5318           IMON_CMD	LD	HL,IMON_TBL
1841  E6 1F             		AND	0x1F
1843  07                		RLCA			;X2
1844  CD 450E           		CALL	ADD_HL_A
1847  CD 4A0E           		CALL	LD_HL_HL	; HL = (HL)
184A  E9                		JP	(HL)

184B  21 D8FF           ICMD4_EXEC	LD	HL,ISR_FLAGS
184E  CB86              		RES	0,(HL)		;Reset NEST level to 0
1850  C3 600B           		JP	GO_EXEC_T

1853  9318              IMON_TBL	DW	ICMD0		;0 = Display Register
1855  DB17              		DW	IKEY_DONE	;ICMD1
1857  DB17              		DW	IKEY_DONE	;ICMD2
1859  DB17              		DW	IKEY_DONE	;ICMD3
185B  4B18              		DW	ICMD4_EXEC	;4 = GO Execute
185D  9719              		DW	ICMD5		;5 = Input Port
185F  B419              		DW	ICMD6		;6 = Output Port
1861  2C1A              		DW	ICMD7		;7 = Single Step
1863  DB17              		DW	IKEY_DONE	;ICMD8
1865  D919              		DW	IRAMROMBANK	;ICMD9
1867  B11A              		DW	ICMDA		;A = Advance Element
1869  D21A              		DW	ICMDB		;B = Backup Element
186B  DB17              		DW	IKEY_DONE	;ICMDC
186D  FD1A              		DW	ICMDD		;D = Alter Element
186F  A918              		DW	ICMDE		;E = Display Memory
1871  DB17              		DW	IKEY_DONE	;ICMDF
1873  DB17              		DW	IKEY_DONE	;ICMD10 (Shift-0 Can't happen, you get hard reset)
1875  DB17              		DW	IKEY_DONE	;ICMD11
1877  DB17              		DW	IKEY_DONE	;ICMD12
1879  DB17              		DW	IKEY_DONE	;ICMD13
187B  DB17              		DW	IKEY_DONE	;ICMD14
187D  DB17              		DW	IKEY_DONE	;ICMD15
187F  DB17              		DW	IKEY_DONE	;ICMD16
1881  DB17              		DW	IKEY_DONE	;ICMD17
1883  DB17              		DW	IKEY_DONE	;ICMD18
1885  DB17              		DW	IKEY_DONE	;ICMD19
1887  D919              		DW	IRAMROMBANK	;ICMD1A
1889  DB17              		DW	IKEY_DONE	;ICMD1B
188B  DB17              		DW	IKEY_DONE	;ICMD1C
188D  DB17              		DW	IKEY_DONE	;ICMD1D
188F  FC17              		DW	ICMD_BREAK	;ICMD1E
1891  DB17              		DW	IKEY_DONE	;ICMD1F (Shift-F Can't happen)


1893  CD 1D0C           ICMD0		CALL	WRITE_BLOCK	;0 = Display Register
1896  BAFF              		DW	LDISPMODE	;Where to write
1898  0700              		DW	7		;Bytes to write
189A  631B              		DW	IDISP_REG	;(LDISPMODE)
189C  631B              		DW	IDISP_REG	;(DISPMODE)
189E  E81A              		DW	ICMD0_R		;(KEY_EVENT) Switch to HEX Input Mode
18A0  50                		DB	80		;(IK_TIMER)
18A1  21 E7FF           		LD	HL,LED_ANBAR
18A4  CBF6              		SET	6,(HL)		;ANBARLED 6 = Enter Register
18A6  C3 DB17           		JP	IKEY_DONE

18A9  CD 1D0C           ICMDE		CALL	WRITE_BLOCK	;E = Display Memory
18AC  BAFF              		DW	LDISPMODE	;Where to write
18AE  0E00              		DW	14		;Bytes to write
18B0  981B              		DW	IDISP_MEM	;(LDISPMODE)
18B2  981B              		DW	IDISP_MEM	;(DISPMODE)
18B4  C618              		DW	ICMD_WORD	;(KEY_EVENT) Switch to HEX Input Mode
18B6  50                		DB	80		;(IK_TIMER)
18B7  8F                		DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
18B8  00                		DB	0		;(DISPLABEL)
18B9  FF                		DB	-1		;(IK_HEXST)
18BA  E0FF              		DW	LED_DISPLAY	;(HEX_CURSOR) @d1
18BC  1C19              		DW	HEX2ABUSS	;(HEX_READY)

18BE  21 E7FF           		LD	HL,LED_ANBAR
18C1  CBEE              		SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
18C3  C3 DB17           		JP	IKEY_DONE


18C6  2A C4FF           ICMD_WORD	LD	HL,(HEX_CURSOR)
18C9  CD 4F1C           		CALL	LED_PUT_HEX_HL
18CC  22 C4FF           		LD	(HEX_CURSOR),HL
18CF  21 C3FF           		LD	HL,IK_HEXST
18D2  34                		INC	(HL)
18D3  20 1B             		JR NZ,	ICMD_WORDN1	;Do 1st digit

18D5  2A BCFF           		LD	HL,(DISPMODE)
18D8  22 BAFF           		LD	(LDISPMODE),HL
18DB  21 DF17           		LD	HL,IDISP_RET
18DE  22 BCFF           		LD	(DISPMODE),HL	;No Display Update while HEX Input Mode

18E1  2A C4FF           		LD	HL,(HEX_CURSOR)
18E4  3E 81             		LD	A,0x81		;Underscore
18E6  77                		LD	(HL),A		;Display X _
18E7  2C                		INC	L
18E8  77                		LD	(HL),A		;Display X _ _
18E9  2C                		INC	L
18EA  77                		LD	(HL),A		;Display X _ _ _
18EB  21 5AFF           		LD	HL,IK_HEXH	;HL=DIGITS 1&2
18EE  18 0D             		JR	ICMD_WORD1

18F0  7E                ICMD_WORDN1	LD	A,(HL)
18F1  21 5AFF           		LD	HL,IK_HEXH	;HL=DIGITS 1&2
18F4  3D                		DEC	A
18F5  28 0D             		JR Z,	ICMD_WORD2	;Do 2nd digit
18F7  21 59FF           		LD	HL,IK_HEXL	;HL=DIGITS 3&4
18FA  3D                		DEC	A
18FB  20 07             		JR NZ,	ICMD_WORD2

18FD  3A EDFF           ICMD_WORD1	LD	A,(KEY_PRES_EV)	;1st & 3rd DIGIT
1900  ED67              		RRD
1902  18 07             		JR	ICMD_WORD_RET

1904  ED67              ICMD_WORD2	RRD			;2nd & 4th DIGIT
1906  3A EDFF           		LD	A,(KEY_PRES_EV)
1909  ED6F              		RLD

190B  3E A0             ICMD_WORD_RET	LD	A,160
190D  32 C0FF           		LD	(IK_TIMER),A	;Set Time out on Register Selection
1910  3A C3FF           		LD	A,(IK_HEXST)	;Advance to next DspMod
1913  FE 03             		CP	3
1915  C2 DB17           		JP NZ,	IKEY_DONE
1918  2A C6FF           		LD	HL,(HEX_READY)
191B  E9                		JP	(HL)

191C  2A 59FF           HEX2ABUSS	LD	HL,(IK_HEXL)
191F  22 88FF           		LD	(ABUSS),HL
1922  C3 BA17           		JP	IKC_RESET_CMD

1925  3A 8AFF           HEX2REG		LD	A,(RegPtr)	;Select Register
1928  D5                		PUSH	DE
1929  ED5B 59FF         		LD	DE,(IK_HEXL)
192D  CD 820C           		CALL	PUT_REGISTER
1930  D1                		POP	DE
1931  C3 BA17           		JP	IKC_RESET_CMD


1934  2A C4FF           ICMD_BYTE	LD	HL,(HEX_CURSOR)
1937  CD 4F1C           		CALL	LED_PUT_HEX_HL
193A  22 C4FF           		LD	(HEX_CURSOR),HL		
193D  21 C3FF           		LD	HL,IK_HEXST
1940  34                		INC	(HL)
1941  20 22             		JR NZ,	ICMD_BYTE2	;Do 1st digit

1943  2A BCFF           		LD	HL,(DISPMODE)
1946  22 BAFF           		LD	(LDISPMODE),HL
1949  21 DF17           		LD	HL,IDISP_RET
194C  22 BCFF           		LD	(DISPMODE),HL	;No Display Update while HEX Input Mode

194F  2A C4FF           		LD	HL,(HEX_CURSOR)
1952  3E 81             		LD	A,0x81		;Underscore
1954  77                		LD	(HL),A		;Display X _

1955  21 5AFF           		LD	HL,IK_HEXH	;HL=DIGITS 1&2
1958  3A EDFF           		LD	A,(KEY_PRES_EV)	;1st DIGIT
195B  ED67              		RRD
195D  3E A0             		LD	A,160
195F  32 C0FF           		LD	(IK_TIMER),A	;Set Time out on Register Selection
1962  C3 DB17           		JP 	IKEY_DONE

1965  21 5AFF           ICMD_BYTE2	LD	HL,IK_HEXH	;HL=DIGITS 1&2
1968  ED67              		RRD			;2nd DIGIT
196A  3A EDFF           		LD	A,(KEY_PRES_EV)
196D  ED6F              		RLD
196F  7E                		LD	A,(HL)
1970  2A C6FF           		LD	HL,(HEX_READY)
1973  E9                		JP	(HL)

1974  32 8BFF           HEX2IN_Ptr	LD	(IoPtr),A	;Save Byte input to IoPtr
1977  C3 BA17           		JP	IKC_RESET_CMD

197A  32 8BFF           HEX2OUT_Ptr	LD	(IoPtr),A	;Save Byte input to IoPtr
197D  C3 461B           		JP	ICMD_IO_OUT

1980  2A 88FF           HEX2MEM		LD	HL,(ABUSS)
1983  77                		LD	(HL),A
1984  23                		INC	HL
1985  22 88FF           		LD	(ABUSS),HL
1988  C3 061B           		JP	ICMD_AMEM

198B  C5                HEX2OUT_PORT	PUSH	BC
198C  47                		LD	B,A
198D  3A 8BFF           		LD	A,(IoPtr)
1990  4F                		LD	C,A
1991  ED41              		OUT	(C),B
1993  C1                		POP	BC
1994  C3 461B           		JP	ICMD_IO_OUT

1997                    ICMD1
1997                    ICMD2
1997                    ICMD3
1997                    ICMD4

1997  CD 1D0C           ICMD5		CALL	WRITE_BLOCK
199A  BAFF              		DW	LDISPMODE	;Where to write
199C  0E00              		DW	14		;Bytes to write
199E  CC1B              		DW	IDISP_IN	;(LDISPMODE)
19A0  CC1B              		DW	IDISP_IN	;(DISPMODE)
19A2  3419              		DW	ICMD_BYTE	;(KEY_EVENT) Switch to BYTE Input Mode
19A4  50                		DB	80		;(IK_TIMER)
19A5  8F                		DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
19A6  00                		DB	0		;(DISPLABEL)
19A7  FF                		DB	-1		;(IK_HEXST)
19A8  E2FF              		DW	LED_DISPLAY+2	;(HEX_CURSOR) @d3
19AA  7419              		DW	HEX2IN_Ptr	;(HEX_READY)

19AC  21 E7FF           		LD	HL,LED_ANBAR
19AF  CBEE              		SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
19B1  C3 DB17           		JP	IKEY_DONE

19B4  CD 1D0C           ICMD6		CALL	WRITE_BLOCK
19B7  BAFF              		DW	LDISPMODE	;Where to write
19B9  0E00              		DW	14		;Bytes to write
19BB  011C              		DW	IDISP_OUT	;(LDISPMODE)
19BD  011C              		DW	IDISP_OUT	;(DISPMODE)
19BF  3419              		DW	ICMD_BYTE	;(KEY_EVENT) Switch to BYTE Input Mode
19C1  50                		DB	80		;(IK_TIMER)
19C2  8F                		DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
19C3  00                		DB	0		;(DISPLABEL)
19C4  FF                		DB	-1		;(IK_HEXST)
19C5  E2FF              		DW	LED_DISPLAY+2	;(HEX_CURSOR) @d3
19C7  7A19              		DW	HEX2OUT_Ptr	;(HEX_READY)

19C9  21 E5FF           		LD	HL,LED_DISPLAY+5
19CC  36 80             		LD	(HL),0x80	;Blank d6
19CE  2C                		INC	L
19CF  36 80             		LD	(HL),0x80	;Blank d7
19D1  21 E7FF           		LD	HL,LED_ANBAR
19D4  CBEE              		SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
19D6  C3 DB17           		JP	IKEY_DONE



19D9  CD 1D0C           IRAMROMBANK	CALL	WRITE_BLOCK
19DC  BCFF              		DW	DISPMODE	;Where to write
19DE  0500              		DW	5		;Bytes to write
19E0  DF17              		DW	IDISP_RET	;(DISPMODE)
19E2  0F1A              		DW	IRAMROMBANK_CHG	;(KEY_EVENT) Switch to BYTE Input Mode
19E4  50                		DB	80		;(IK_TIMER)
                        		
19E5  3A DBFF           		LD	A,(READ_RAMROM)
19E8  1F                IDDR_DISP	RRA
19E9  D3 CC             		OUT	(ACE_OUT),A	;SET Bank
19EB  30 14             		JR  NC,	IDRR_ROM
19ED  CD 861C           		CALL	LED_HOME_PRINTI
19F0  72616D20 20202000 		DB	'ram    ',EOS
19F8  21 E4FF           		LD	HL,LED_DISPLAY+4
19FB  CD 4F1C           		CALL	LED_PUT_HEX_HL
19FE  C3 DB17           		JP	IKEY_DONE
                        		
1A01  CD 861C           IDRR_ROM	CALL	LED_HOME_PRINTI
1A04  726F6D20 20202000 		DB	'rom    ',EOS
1A0C  C3 DB17           		JP	IKEY_DONE

                        ;SET_BANK	
1A0F  3E 50             IRAMROMBANK_CHG	LD	A,80
1A11  32 C0FF           		LD	(IK_TIMER),A
1A14  3A DBFF           		LD	A,(READ_RAMROM)
1A17  1F                		RRA
1A18  30 08             		JR  NC,	IDRRC_ROM
1A1A  3C                		INC	A
1A1B  CB67              		BIT	4,A
1A1D  20 07             		JR  NZ,	IDRRC_2ROM
1A1F  17                		RLA
1A20  18 05             		JR	IDRRC_RET

1A22  3E 01             IDRRC_ROM	LD	A,1		;Start at BANK 0 of RAM, bit0 set = RAM
1A24  18 01             		JR	IDRRC_RET
                        		
1A26  AF                IDRRC_2ROM	XOR	A		;Return to ROM after 15 Banks
1A27  32 DBFF           IDRRC_RET	LD	(READ_RAMROM),A
1A2A  18 BC             		JR	IDDR_DISP




                        ;============================================================================
                        ;	Single Step
                        ;============================================================================
1A2C  3A B3FF           ICMD7		LD	A,(ANBAR_DEF)	;Single step only allowed while in Monitor Mode
1A2F  E6 04             		AND	4
1A31  CA DB17           		JP  Z,	IKEY_DONE
                        		
                        		;DEBUG SINGLE STEP ONLY ALLOWED WITH FP BOARD
1A34  3A 95FF           		LD	A,(HW_LIST)
1A37  E6 01             		AND	1
1A39  CA DB17           		JP  Z,	IKEY_DONE
                        		

1A3C  3A 95FF           GO_SINGLE	LD	A,(HW_LIST)	;TEST HARDWARE LIST here for Return to Main Menu when
1A3F  E6 01             		AND	1		;Single Step was an RS232 input command
1A41  20 27             		JR  NZ,	GS_OK

1A43  CD CA0D           		CALL	PRINTI
1A46  0D0A5369 6E676C65 		DB	CR,LF,"Single Step requires Front Panel",EOS		
1A4E  20537465 70207265
1A56  71756972 65732046
1A5E  726F6E74 2050616E
1A66  656C00
1A69  C9                		RET	
                        		
1A6A  21 711A           GS_OK		LD	HL,ISINGLE	;Redirect next Interrupt to Single Step
1A6D  22 CEFF           		LD	(INT_VEC),HL
1A70  76                		HALT			;Halt for next interrupt (Aligns TC with INT)

                        					;The following interrupt code happens		
                        		;RST	0x38		;13  (11 + 2 wait cycles)
                        		;EX	AF,AF'		;4
                        		;EXX			;4
                        		;LD	HL,(INT_VEC)	;16 Typical Calls are to ISR_DISPATCH
                        		;JP	(HL)		;4
                        					;st=41
                        					
                        					;On the next interrupt, handle it here
1A71  08                ISINGLE		EX	AF,AF'		;4
1A72  D9                		EXX			;4
1A73  3A F5FF           		LD	A,(SCAN_LED)	;13 ZMC-Display Refresh / Reset Int
1A76  D3 40             		OUT	(Port40),A	;11 Output ASAP to satisfy Interrupt Flag

1A78  DB 40             		IN	A,(Port40)	;11 Resync the SCAN_PTR
1A7A  3C                		INC	A		;4  Advance to next column to match column after next OUT
1A7B  E6 07             		AND	7		;7
1A7D  F6 E0             		OR  LOW LED_DISPLAY	;7  LED_DISPLAY is at xxEO (it's ok to overlap in this order)
1A7F  32 D0FF           		LD	(SCAN_PTR),A	;13 Save Scan Ptr @ Next Scan Output
1A82  2A D0FF           		LD	HL,(SCAN_PTR)	;16 Fetch next byte to output
1A85  7E                		LD	A,(HL)		;7
1A86  32 F5FF           		LD	(SCAN_LED),A	;13 Save for next interrupt
                        					;st=110

1A89  21 981A           		LD	HL,ISINGLE_DONE	;10 Redirect next Interrupt to Single Step
1A8C  22 CEFF           		LD	(INT_VEC),HL	;16

1A8F  3E D4             		LD	A,212		;7
                        					;st=33
                        					;-----
                        					;184 (+completion), There are 4096 cycles between interrupts.
                        					;	 4096 cycles to waste
                        					;	 -184 cycles to get here
                        					;	 -525 cycles to execute
                        					;	=3387 cycles more to waste
                        					;
                        					;	Waste Loop = 16 * 212 -5 = 3387
                        					;
1A91  3D                ISINGLE_LP	DEC	A		;4  Count down the cycles to time the next ISR to occur
1A92  20 FD             		JR NZ,	ISINGLE_LP	;12/7 cycle after execution commences
1A94  00                		NOP		
1A95  C3 710B           		JP	GO_EXEC		;10 Go Execute the single instruction!
                        					;(515 T states until executing next instruction)

1A98  08                ISINGLE_DONE	EX	AF,AF'		;4
1A99  D9                		EXX			;4
1A9A  ED73 28FB         		LD	(SP_ISR_SAVE),SP
1A9E  E5                		PUSH	HL
1A9F  F5                		PUSH	AF

1AA0  3E D1             		LD	A,0xD1		;ISR being re-entered after the single step
1AA2  C3 FE17           		JP 	ICMD_BREAK_RET	;

                        ;ICMD_BREAK_RET	....
                        ;		DI
                        ;		POP	AF
                        ;		POP	HL
                        ;		LD	SP,(SP_ISR_SAVE)
                        ;		JP	0
                        		




                        ;============================================================================
1AA5  3A BCFF           GET_DISPMODE	LD	A,(DISPMODE)
1AA8  FE 75             		CP  LOW IDISP_REG_DATA
1AAA  C8                		RET Z				;Z=1 : DISPMODE = REGISTER
1AAB  FE B0             		CP  LOW IDISP_MEM_DATA
1AAD  37                		SCF
1AAE  C0                		RET NZ				;Z=0, C=1 : DISPMODE = I/O
1AAF  B7                		OR	A			;WARNING, If LOW IDISP_MEM_DATA=0 Then ERROR
1AB0  C9                		RET				;Z=0, C=0 : DISPMODE = MEM

                        	if 0x00 = LOW IDISP_MEM_DATA
                        	endif

                        ;============================================================================
                        ;	Increment Display Element
                        ;============================================================================
1AB1  CD A51A           ICMDA		CALL	GET_DISPMODE
1AB4  CA C41A           		JP  Z,	ICMA_REG
1AB7  DA CB1A           		JP  C,	ICMA_IO

1ABA  2A 88FF           		LD	HL,(ABUSS)
1ABD  23                		INC     HL
1ABE  22 88FF           		LD	(ABUSS),HL
1AC1  C3 D117           		JP	IKR_QREFRESH

1AC4  3A 8AFF           ICMA_REG	LD      A,(RegPtr)
1AC7  3C                		INC	A
1AC8  C3 EB1A           		JP	ICMD_SET_REG

1ACB  21 8BFF           ICMA_IO		LD	HL,IoPtr
1ACE  34                		INC	(HL)
1ACF  C3 D117           		JP	IKR_QREFRESH


                        ;============================================================================
                        ;	Decrement Display Element (Reg, I/O, Mem)
                        ;============================================================================
1AD2  CD A51A           ICMDB		CALL	GET_DISPMODE
1AD5  CA E51A           		JP  Z,	ICMB_REG
1AD8  DA F61A           		JP  C,	ICMB_IO

1ADB  2A 88FF           		LD	HL,(ABUSS)
1ADE  2B                		DEC     HL
1ADF  22 88FF           		LD	(ABUSS),HL
1AE2  C3 D117           		JP	IKR_QREFRESH

1AE5  3A 8AFF           ICMB_REG	LD      A,(RegPtr)
1AE8  3D                ICMD0_R		DEC	A		;Adjust so Key 1 = 0 = SP
1AE9  E6 0F             		AND	0xF
1AEB  FE 0D             ICMD_SET_REG	CP	13
1AED  38 01             		JR  C,	ICMD_SR_OK
1AEF  AF                		XOR	A
1AF0  32 8AFF           ICMD_SR_OK	LD	(RegPtr),A
1AF3  C3 BA17           		JP	IKC_RESET_CMD


1AF6  21 8BFF           ICMB_IO		LD	HL,IoPtr
1AF9  35                		DEC	(HL)
1AFA  C3 D117           		JP	IKR_QREFRESH

                        ;============================================================================
                        ;	Alter Display Element (Reg, I/O, Mem)
                        ;============================================================================
1AFD  CD A51A           ICMDD		CALL	GET_DISPMODE
1B00  CA 251B           		JP  Z,	ICMD_REG
1B03  DA 411B           		JP  C,	ICMD_IO

1B06  CD 1D0C           ICMD_AMEM	CALL	WRITE_BLOCK
1B09  BAFF              		DW	LDISPMODE	;Where to write
1B0B  0E00              		DW	14		;Bytes to write
1B0D  981B              		DW	IDISP_MEM	;(LDISPMODE)
1B0F  981B              		DW	IDISP_MEM	;(DISPMODE)
1B11  3419              		DW	ICMD_BYTE	;(KEY_EVENT) Switch to BYTE Input Mode
1B13  50                		DB	80		;(IK_TIMER)
1B14  8F                		DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
1B15  01                		DB	1		;(DISPLABEL)
1B16  FF                		DB	-1		;(IK_HEXST)
1B17  E5FF              		DW	LED_DISPLAY+5	;(HEX_CURSOR) @d6
1B19  8019              		DW	HEX2MEM		;(HEX_READY)

1B1B  21 E7FF           		LD	HL,LED_ANBAR
1B1E  CBEE              		SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
1B20  CBE6              		SET	4,(HL)		;ANBARLED 4 = Alter
1B22  C3 DB17           		JP	IKEY_DONE



1B25  21 C618           ICMD_REG	LD	HL,ICMD_WORD	;Switch to WORD Input Mode
1B28  22 BEFF           		LD	(KEY_EVENT),HL
1B2B  21 2519           		LD	HL,HEX2REG
1B2E  22 C6FF           		LD	(HEX_READY),HL
1B31  21 E3FF           		LD	HL,LED_DISPLAY+3 ;@d4
1B34  22 C4FF           		LD	(HEX_CURSOR),HL
                        		;LD	A,0x8F
                        		;LD	(KEYBFMODE),A	;HEX Keyboard
1B37  21 E7FF           		LD	HL,LED_ANBAR
1B3A  CBEE              		SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
1B3C  CBE6              		SET	4,(HL)		;ANBARLED 4 = Alter
1B3E  C3 DB17           		JP	IKEY_DONE

1B41  FE E3             ICMD_IO		CP  LOW IDISP_IN_DATA
1B43  CA 9719           		JP  Z,	ICMD5

1B46  CD 1D0C           ICMD_IO_OUT	CALL	WRITE_BLOCK
1B49  BAFF              		DW	LDISPMODE	;Where to write
1B4B  0E00              		DW	14		;Bytes to write
1B4D  011C              		DW	IDISP_OUT	;(LDISPMODE)
1B4F  011C              		DW	IDISP_OUT	;(DISPMODE)
1B51  3419              		DW	ICMD_BYTE	;(KEY_EVENT) Switch to HEX Input Mode
1B53  50                		DB	80		;(IK_TIMER)
1B54  8F                		DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
1B55  00                		DB	0		;(DISPLABEL)
1B56  FF                		DB	-1		;(IK_HEXST)
1B57  E5FF              		DW	LED_DISPLAY+5	;(HEX_CURSOR) @d6
1B59  8B19              		DW	HEX2OUT_PORT	;(HEX_READY)
1B5B  21 E7FF           		LD	HL,LED_ANBAR
1B5E  CBDE              		SET	3,(HL)		;ANBARLED 3 = Send Data to Output Port
1B60  C3 DB17           		JP	IKEY_DONE


                        ;============================================================================
                        ;	LED Display Register
                        ;============================================================================
1B63  CD 7314           IDISP_REG	CALL	LED_HOME
1B66  3A 8AFF           		LD	A,(RegPtr)
1B69  CD 2E0C           		CALL	GET_REGNAME
1B6C  CD 741C           		CALL	LED_PRINT
1B6F  21 751B           		LD	HL,IDISP_REG_DATA
1B72  22 BCFF           		LD	(DISPMODE),HL

1B75  3A 8AFF           IDISP_REG_DATA	LD	A,(RegPtr)	;13 Then Display Data
1B78  CD 6D0C           		CALL	GET_REGISTER	;17+169
1B7B  7D                		LD	A,L		;4
1B7C  F5                		PUSH	AF		;11
1B7D  7C                		LD	A,H		;4
1B7E  21 E3FF           		LD	HL,LED_DISPLAY+3 ;10
1B81  CD 461C           		CALL	LED_PUT_BYTE_HL	;17+165
1B84  F1                		POP	AF		;10
1B85  CD 461C           		CALL	LED_PUT_BYTE_HL	;17+165
1B88  21 C2FF           		LD	HL,DISPLABEL	;10
1B8B  35                		DEC	(HL)		;7
1B8C  C2 DF17           		JP NZ,	IDISP_RET	;10   sp=629
1B8F  21 631B           		LD	HL,IDISP_REG
1B92  22 BCFF           		LD	(DISPMODE),HL
1B95  C3 DF17           		JP 	IDISP_RET

                        ;============================================================================
                        ;	LED Display Memory Location
                        ;============================================================================
1B98  21 E0FF           IDISP_MEM	LD	HL,LED_DISPLAY	;First, Display location
1B9B  3A 89FF           		LD	A,(ABUSS+1)
1B9E  CD 461C           		CALL	LED_PUT_BYTE_HL
1BA1  3A 88FF           		LD	A,(ABUSS)
1BA4  CD 461C           		CALL	LED_PUT_BYTE_HL
1BA7  3E 80             		LD	A,0x80		;Blank next char
1BA9  77                		LD	(HL),A
1BAA  21 B01B           		LD	HL,IDISP_MEM_DATA
1BAD  22 BCFF           		LD	(DISPMODE),HL
                        					;Then Display DATA
1BB0  2A 88FF           IDISP_MEM_DATA	LD	HL,(ABUSS)	;16
1BB3  CD 45FB           		CALL	GET_MEM
1BB6  21 E5FF           		LD	HL,LED_DISPLAY+5 ;10
1BB9  CD 461C           		CALL	LED_PUT_BYTE_HL	;17+165
1BBC  21 C2FF           		LD	HL,DISPLABEL	;10 Repeat Display of Data several times before redisplaying Location
1BBF  35                		DEC	(HL)		;7
1BC0  C2 DF17           		JP NZ,	IDISP_RET	;10  st=242
1BC3  21 981B           		LD	HL,IDISP_MEM
1BC6  22 BCFF           		LD	(DISPMODE),HL
1BC9  C3 DF17           		JP 	IDISP_RET


                        ;============================================================================
                        ;	LED Display Input Port
                        ;============================================================================
1BCC  CD 861C           IDISP_IN	CALL	LED_HOME_PRINTI
1BCF  696E00            		DB	'in',EOS
1BD2  3A 8BFF           		LD	A,(IoPtr)
1BD5  21 E2FF           		LD	HL,LED_DISPLAY+2
1BD8  CD 461C           		CALL	LED_PUT_BYTE_HL
1BDB  36 80             		LD	(HL),0x80	;Blank d5
1BDD  21 E31B           		LD	HL,IDISP_IN_DATA
1BE0  22 BCFF           		LD	(DISPMODE),HL

1BE3  C5                IDISP_IN_DATA	PUSH	BC
1BE4  3A 8BFF           		LD	A,(IoPtr)
1BE7  4F                		LD	C,A
1BE8  ED78              		IN	A,(C)
1BEA  C1                		POP	BC
1BEB  21 E5FF           		LD	HL,LED_DISPLAY+5
1BEE  CD 461C           		CALL	LED_PUT_BYTE_HL
1BF1  21 C2FF           		LD	HL,DISPLABEL
1BF4  35                		DEC	(HL)
1BF5  C2 DF17           		JP NZ,	IDISP_RET
1BF8  21 CC1B           		LD	HL,IDISP_IN
1BFB  22 BCFF           		LD	(DISPMODE),HL
1BFE  C3 DF17           		JP 	IDISP_RET


                        ;============================================================================
                        ;	LED Display Output Port		cmd 6
                        ;============================================================================
1C01  CD 861C           IDISP_OUT	CALL	LED_HOME_PRINTI
1C04  6F7500            		DB	'ou',EOS
1C07  3A 8BFF           		LD	A,(IoPtr)
1C0A  21 E2FF           		LD	HL,LED_DISPLAY+2
1C0D  CD 461C           		CALL	LED_PUT_BYTE_HL
1C10  36 80             		LD	(HL),0x80	;Blank d5
1C12  21 181C           		LD	HL,IDISP_OUT_DATA
1C15  22 BCFF           		LD	(DISPMODE),HL

1C18  21 C2FF           IDISP_OUT_DATA	LD	HL,DISPLABEL
1C1B  35                		DEC	(HL)
1C1C  C2 DF17           		JP NZ,	IDISP_RET
1C1F  21 011C           		LD	HL,IDISP_OUT
1C22  22 BCFF           		LD	(DISPMODE),HL
1C25  C3 DF17           		JP 	IDISP_RET

                        ;============================================================================
                        ;	LED Display OFF
                        ;============================================================================
1C28  21 E0FF           IDISP_OFF	LD	HL,LED_DISPLAY
1C2B  3E 80             		LD	A,0x80
1C2D  C5                		PUSH	BC
1C2E  06 08             		LD	B,8
1C30  77                IDO_LP		LD	(HL),A
1C31  2C                		INC	L
1C32  10 FC             		DJNZ	IDO_LP
1C34  C1                		POP	BC
1C35  21 DF17           		LD	HL,IDISP_RET
1C38  22 BCFF           		LD	(DISPMODE),HL
1C3B  E9                		JP 	(HL)

                        ;============================================================================
                        ;	LED Delay	- After a delay for spash screen, display Registers
                        ;============================================================================
1C3C  21 C2FF           IDISP_DELAY	LD	HL,DISPLABEL
1C3F  35                		DEC	(HL)
1C40  C2 DF17           		JP NZ,	IDISP_RET
1C43  C3 BA17           		JP 	IKC_RESET_CMD

                        ;============================================================================
                        ;PUTS 2 HEX digits to LED Display
                        ;Input:	A=BYTE to display
                        ;	HL=Where to display
                        ;Output: HL=Next LED Display location
1C46  F5                LED_PUT_BYTE_HL	PUSH	AF		;11 Save Byte to display (for 2nd HEX digit)
1C47  0F                		RRCA			;4
1C48  0F                		RRCA			;4
1C49  0F                		RRCA			;4
1C4A  0F                		RRCA			;4
1C4B  CD 4F1C           		CALL	LED_PUT_HEX_HL
1C4E  F1                		POP	AF		;10
                        		;CALL	LED_PUT_HEX_HL
                        		;RET			;10  st=165

1C4F  E5                LED_PUT_HEX_HL	PUSH	HL
1C50  E6 0F             		AND	0xF
1C52  26 29             		LD	H,HIGH LED_HEX
1C54  6F                		LD	L,A
1C55  7E                		LD	A,(HL)		;Fetch LED Font for HEX digit
1C56  E1                		POP	HL
1C57  77                		LD	(HL),A		;Display HEX digit
1C58  2C                		INC	L
1C59  CB9D              		RES	3,L
1C5B  C9                		RET
                        		
1C5C  E5                LED_PUT_BYTE	PUSH	HL
1C5D  2A C8FF           		LD	HL,(LED_CURSOR)
1C60  CD 461C           		CALL	LED_PUT_BYTE_HL
1C63  22 C8FF           		LD	(LED_CURSOR),HL
1C66  E1                		POP	HL
1C67  C9                		RET
                        		
1C68  E5                LED_PUT_HEX	PUSH	HL
1C69  2A C8FF           		LD	HL,(LED_CURSOR)
1C6C  CD 4F1C           		CALL	LED_PUT_HEX_HL
1C6F  22 C8FF           		LD	(LED_CURSOR),HL
1C72  E1                		POP	HL
1C73  C9                		RET
                        		
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;LED_PRINT -- Print A null-terminated string @(HL)
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1C74  F5                LED_PRINT:	PUSH	AF
1C75  C5                		PUSH	BC
1C76  7E                LED_PRINT_LP	LD	A, (HL)
1C77  23                		INC	HL
1C78  B7                		OR	A
1C79  28 08             		JR Z,	LED_PRINT_RET
1C7B  4F                		LD	C,A
1C7C  E5                		PUSH	HL
1C7D  CD 8614           		CALL	PC_LED
1C80  E1                		POP	HL
1C81  18 F3             		JR	LED_PRINT_LP
1C83  C1                LED_PRINT_RET	POP	BC
1C84  F1                		POP	AF
1C85  C9                		RET



1C86  CD 7314           LED_HOME_PRINTI	CALL	LED_HOME
                        		
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;PRINT IMMEDIATE
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1C89  E3                LED_PRINTI:	EX	(SP),HL	;HL = Top of Stack
1C8A  CD 741C           		CALL	LED_PRINT
1C8D  E3                		EX	(SP),HL	;Move updated return address back to stack
1C8E  C9                		RET



                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;
                        ;	Chapter_12	S D - C A R D
                        ;
                        ;   *******   *******                *******      ***     ********   *******
                        ;  *********  ********              *********    *****    *********  ********
                        ;  **         **    ***             **     **   *** ***   **     **  **    ***
                        ;  **         **     **             **         ***   ***  **     **  **     **
                        ;   ******    **     **   ******    **         *********  ********   **     **
                        ;    ******   **     **   ******    **         *********  ********   **     **
                        ;         **  **     **             **         **     **  **  **     **     **
                        ;         **  **    ***             **     **  **     **  **   **    **    ***
                        ;  *********  ********              *********  **     **  **    **   ********
                        ;   *******   *******                *******   **     **  **     **  *******
                        ;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;

                        ;String equates

1C8F  F3                GO_SD_CARD	DI			; Disable Interrupts

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Init all System RAM, enable interrupts
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1C90  21 3800           GSC_INIT	LD	HL,0x0038
1C93  11 3800           		LD	DE,0x0038
1C96  01 0600           		LD	BC,RST38_LEN
1C99  EDB0              		LDIR

1C9B  21 80FB           		LD	HL,SDISKA	;Initialize New Variables for SD-CARD operation & full 64K RAM
1C9E  22 08FF           		LD	(FCB_PTR),HL
1CA1  21 F516           		LD	HL,SKIP_HALT_TEST
1CA4  22 D2FF           		LD	(HALT_TEST),HL
                        	
1CA7  CD 1D0C           		CALL	WRITE_BLOCK
1CAA  B3FF              		DW	ANBAR_DEF	;Where to write
1CAC  1000              		DW	16		;Bytes to write
1CAE  82                		DB	0x82		;(ANBAR_DEF) = RUN MODE
1CAF  7C0C              		DW	GET_REG_RUN	;(GET_REG)
1CB1  910C              		DW	PUT_REG_RUN	;(PUT_REG)
1CB3  AE17              		DW	CTRL_C_RET	;(CTRL_C_CHK)
1CB5  DF17              		DW	IDISP_RET	;(LDISPMODE)
1CB7  DF17              		DW	IDISP_RET	;(DISPMODE)
1CB9  3E18              		DW	IMON_CMD	;(KEY_EVENT) Initialize to Command Mode
1CBB  01                		DB	1		;(IK_TIMER)
1CBC  90                		DB	0x90		;(KEYBFMODE) HEX Keyboard Mode (F on release)
1CBD  FF                		DB	0xFF		;(DISPLABEL)

1CBE  FB                		EI			;************** Interrupts ON!!!!

1CBF  CD 861C           		CALL	LED_HOME_PRINTI
1CC2  53642D43 41524400 		DB	"Sd-CARD",EOS
                        		
1CCA  CD D722           		CALL	INIT_FAT
1CCD  C0                		RET	NZ		;RETURN IF FAILED

1CCE  CD 1F0E           		CALL	PUT_NEW_LINE
                        		
1CD1  3E C0             		LD	A,0xC0
1CD3  32 0CFF           		LD	(VIEW_FLAGS),A	;View File open/not status & Size

                        					;Filename will be preloaded on auto run
1CD6  3A 43FF           		LD	A,(FILENAME)	;Check for any Auto Run
1CD9  B7                		OR	A
1CDA  28 08             		JR   Z,	SDC_MENU
                        		
1CDC  CD A41D           		CALL	SD_OPEN_FILENAME
1CDF  28 03             		JR Z,	SDC_MENU	;Jump if file not found
1CE1  CD BE1E           		CALL	READ_HEX_EXEC	;Read & Execute HEX file, Return if Error

                        ;----------------------------------------------------------------------------------------------------; SD MENU
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;----------------------------------------------------------------------------------------------------; SD MENU

1CE4  CD CA0D           SDC_MENU:	CALL	PRINTI		;Monitor Start, Display Welcome Message
1CE7  0D0A              		DB	CR,LF
1CE9  4C202020 20202020 		DB	"L              LIST FILES",CR,LF
1CF1  20202020 2020204C
1CF9  49535420 46494C45
1D01  530D0A
1D04  57202020 20202020 		DB	"W              WITNESS LOAD",CR,LF
1D0C  20202020 20202057
1D14  49544E45 5353204C
1D1C  4F41440D 0A
1D21  3F203E00          		DB	"? >",EOS

1D25  CD DC13           		CALL 	GET_CHAR	;get char
1D28  FE 1B             		CP	27
1D2A  C8                		RET	Z		;MAIN MENU
1D2B  E6 5F             		AND 	0x5F		;to upper case
1D2D  FE 4C             		CP	'L'
1D2F  28 15             		JR Z,	DO_DIR		; L = List Files
1D31  FE 57             		CP	'W'
1D33  28 02             		JR Z,	BOOT_SDVIEW	; W = Witness Load
1D35  18 AD             		JR	SDC_MENU	

                        ;=============================================================================
1D37  21 0CFF           BOOT_SDVIEW	LD	HL,VIEW_FLAGS	;BIT .0=View HEX Load
1D3A  CBC6              		SET	0,(HL)
1D3C  CD CA0D           		CALL 	PRINTI
1D3F  202D4F4E 00       		DB	" -ON",EOS
1D44  18 9E             		JR	SDC_MENU	
                        			
                        ;=============================================================================
1D46  CD 5A1D           DO_DIR		CALL	PRINT_DIR
1D49  CD 2521           		CALL	INPUT_FILENAME
1D4C  D8                		RET	C		;Return to Menu if <Esc>
1D4D  CD 1F0E           		CALL	PUT_NEW_LINE
1D50  CD A41D           		CALL	SD_OPEN_FILENAME
1D53  28 F1             		JR Z,	DO_DIR		;Jump if file not found
1D55  CD BE1E           		CALL	READ_HEX_EXEC	;Read & Execute HEX file, Return if Error
1D58  18 EC             		JR	DO_DIR


                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_13	FILE operations
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;

                        ;=============================================================================
                        ;		Destroys A,B,C,IX
                        ;-----------------------------------------------------------------------------
1D5A  CD CA0D           PRINT_DIR	CALL	PRINTI
1D5D  0D0A4449 52454354 		DB CR,LF,"\DIRECTORY:",CR,LF,EOS
1D65  4F52593A 0D0A00
1D6C  CD C620           		CALL	SD_LDIR1
1D6F  C8                SDLF_LP 	RET	Z			;End of list
1D70  7E                		LD	A,(HL)
1D71  FE 21             		CP	33
1D73  FA 9F1D           		JP M,	DD_NEXT
1D76  FE 7F             		CP	127
1D78  F2 9F1D           		JP P,	DD_NEXT
1D7B  E5                		PUSH	HL			;Test if starting cluster is 0, skip file
1D7C  DDE1              		POP	IX
1D7E  DD7E 1A           		LD	A,(IX+1Ah)
1D81  DDB6 1B           		OR	(IX+1Bh)
1D84  CA 9F1D           		JP Z,	DD_NEXT

1D87  CD 0021           		CALL	PRINT_FILENAME
                        		
1D8A  CD C913           		CALL	GET_POS		;Get output position (counted characters after CR)
1D8D  FE 40             		CP	64
1D8F  F4 1F0E           		CALL P,	PUT_NEW_LINE
1D92  CD C913           DD_TAB_LP	CALL	GET_POS		;TAB OUT 16 CHARS
1D95  E6 0F             		AND	0Fh
1D97  CA 9F1D           		JP Z,	DD_NEXT
1D9A  CD 190E           		CALL	PUT_SPACE
1D9D  18 F3             		JR	DD_TAB_LP

1D9F  CD DB20           DD_NEXT		CALL	SD_LDIRN
1DA2  18 CB             		JR	SDLF_LP


                        ;=============================================================================
                        ;Open File	Enter with FILENAME set and FCB_PTR set to desired FCB
                        ;		EXIT Z=1 If File Not Found
                        ;-----------------------------------------------------------------------------
1DA4  2A 08FF           SD_OPEN_FILENAME LD	HL,(FCB_PTR)
1DA7  23                		INC	HL		;+1 = FNAME
1DA8  EB                		EX	DE,HL		
1DA9  21 43FF           		LD	HL,FILENAME	;Write FILENAME to FCB
1DAC  01 0B00           		LD	BC,11
1DAF  EDB0              		LDIR

                        ;=============================================================================
                        ;Open File	Enter with FCB_PTR set to desired FCB
                        ;		EXIT Z=1 If File Not Found
                        ;-----------------------------------------------------------------------------
1DB1  2A 08FF           SD_OPEN		LD	HL,(FCB_PTR)
1DB4  36 00             		LD	(HL),0		;FSTAT=0, Clear Open Status
1DB6  23                		INC	HL		;+1 = FNAME
1DB7  11 43FF           		LD	DE,FILENAME	;Write FCB Name to FILENAME
1DBA  01 0B00           		LD	BC,11
1DBD  EDB0              		LDIR		
1DBF  CD 8620           		CALL	SDV_FIND_FILE	;HL = Directory Entry  ;PRINT FILE NAME, FOUND OR NOT
1DC2  C8                		RET	Z		;Exit if file not found

                        ;FAT-16 Directory Entry
                        ; 46 44 49 53 4b 20 20 20 45 58 45 20 00 00 00 00  FDISK   .EXE
                        ; 00 00 00 00 00 00 36 59 62 1b 02 00 17 73 00 00
                        ;
                        ;Bytes   Content
                        ;0-10    File name (8 bytes) with extension (3 bytes)
                        ;11      Attribute - a bitvector. Bit 0: read only. Bit 1: hidden.
                        ;        Bit 2: system file. Bit 3: volume label. Bit 4: subdirectory.
                        ;        Bit 5: archive. Bits 6-7: unused.
                        ;12-21   Reserved (see below)
                        ;22-23   Time (5/6/5 bits, for hour/minutes/doubleseconds)
                        ;24-25   Date (7/4/5 bits, for year-since-1980/month/day)
                        ;26-27   Starting cluster (0 for an empty file)
                        ;28-31   Filesize in bytes
                        ;
                        ;Z80MC FCB
                        ;
                        ;SDFCB:
                        ;FSTAT		EQU	0	;DS  1	;+0  Status of FCB, 00=File Not Open, 01=File Opened, 80=EOF (Line_Input)
                        ;FNAME		EQU	1	;DS 11	;+1  File name
                        ;AFClus0	EQU	12	;DS  2	;+12 First Cluster of File as given by the Directory Entry.
                        ;CRFClus (FFFF)	EQU	14	;DS  2	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
                        ;CAFClus (FFFF)	EQU	16	;DS  2	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
                        ;RFSec	 (FFFF)	EQU	18	;DS  2	;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
                        ;SSOC	 (FF's)	EQU	20	;DS  4	;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
                        ;ABS_SEC (FF's)	EQU	24	;DS  4	;+24 Absolute Sector of Current Relative Sector
                        ;FSIZE		EQU	28	;DS  4	;+28 File Size of file (not used, just kept for completness)


1DC3  E5                SDO_DO		PUSH	HL		;HL Points to FAT Directory Entry
1DC4  01 1C00           		LD	BC,1Ch		;File Size Offset (into Directory Entry)
1DC7  09                		ADD	HL,BC
1DC8  EB                		EX	DE,HL
1DC9  2A 08FF           		LD	HL,(FCB_PTR)	;HL=FCB
1DCC  09                		ADD	HL,BC		;1C is also the offset for FSIZE
1DCD  E5                		PUSH	HL
1DCE  EB                		EX	DE,HL
1DCF  CD 3927           		CALL	MOV_32_HL	;Move (HL) to 32 bit register BCDE, Fetch File Size
1DD2  21 4EFF           		LD	HL,FILESIZE
1DD5  CD 4427           		CALL	MOV_HL_32	;Save 32 bits to RAM at HL (FILESIZE)
1DD8  E1                		POP	HL		;HL = FCB.FSIZE
1DD9  CD 4427           		CALL	MOV_HL_32	;Save 32 bits to RAM at HL (FCB)
1DDC  E1                		POP	HL

1DDD  01 1A00           		LD	BC,1Ah		;H=(START CLUSTER)
1DE0  09                		ADD	HL,BC
1DE1  CD 4A0E           		CALL	LD_HL_HL	;Fetch Starting Custer
1DE4  EB                		EX	DE, HL		;DE=Starting Cluster
1DE5  2A 08FF           		LD	HL,(FCB_PTR)	;HL=FCB
1DE8  36 01             		LD	(HL),1		;FSTAT=1
1DEA  01 0C00           		LD	BC,AFClus0 	;offset to AFClus0
1DED  09                		ADD	HL,BC
1DEE  73                		LD	(HL),E		;Save Starting Cluster
1DEF  23                		INC	HL
1DF0  72                		LD	(HL),D
1DF1  23                		INC	HL
1DF2  06 0E             		LD	B,14
1DF4  3E FF             		LD	A,0FFH
1DF6  CD 160C           		CALL	FILL_BLOCK	;Fill 14 bytes of FF (Nuke pointers to force new calculations)
                        		
1DF9  3A 0CFF           		LD	A,(VIEW_FLAGS)	;BIT .0=View HEX Load, .6=FILE SIZE
1DFC  CB77              		BIT	6,A
1DFE  28 1D             		JR  Z,	SDO_RET
                        		
1E00  CD CA0D           		CALL	PRINTI
1E03  2046494C 45205349 		DB 	" FILE SIZE=0x",EOS
1E0B  5A453D30 7800
1E11  2A 50FF           		LD	HL, (FILESIZE+2)
1E14  CD EA0D           		CALL	PUT_HL
1E17  2A 4EFF           		LD	HL, (FILESIZE)
1E1A  CD EA0D           		CALL	PUT_HL
                        					
1E1D  2A 08FF           SDO_RET		LD	HL,(FCB_PTR)	;HL=FCB
1E20  F6 FF             		OR	0FFh		;Clear Z
1E22  C9                		RET
                        		

                        ;=============================================================================
                        ;LINE INPUT	Enter with FCB_PTR set to desired FCB
                        ;		(Recently opened so pointers will be initialized)
                        ;		if Relative Cluster = 0xFFFF (new open), pointer will init to start of file.
                        ;		Output Z=1 if EOF, HL=FCB_PTR
                        ;		Z=0, HL=Pointer to Line Buffer
                        ;		BC, DE nuked
                        ;		LOGICAL_SEC is used/nuked
                        ;-----------------------------------------------------------------------------
1E23  2A 08FF           LINE_INPUT	LD	HL,(FCB_PTR)	;Test FSTAT for EOF, marked in FCB Status
1E26  CB7E              		BIT	7,(HL)
1E28  C0                		RET	NZ		;Exit if EOF
                        					;Test for newly opened file
1E29  01 0E00           		LD	BC,14		; check Current Relative Cluster <> FFFF
1E2C  09                		ADD	HL,BC
1E2D  3E FF             		LD	A,0xFF
1E2F  BE                		CP	(HL)
1E30  20 1F             		JR NZ,	LI_TP		;Jump if file was read from
1E32  23                		INC	HL
1E33  BE                		CP	(HL)
1E34  20 1B             		JR NZ,	LI_TP		;Jump if file was read from
                        					;File has not yet been read...
1E36  01 0D00           		LD	BC, 28-15	;Advance to File Size
1E39  09                		ADD	HL,BC
1E3A  11 82FA           		LD	DE,LI_FILESIZE	;Init LI_FILESIZE with max count of bytes to read
1E3D  01 0400           		LD	BC,4
1E40  EDB0              		LDIR			;Copy File Size to Byte counter

1E42  21 0000           		LD	HL,0		;Start at first Logical Sector
1E45  22 88FA           		LD	(LI_SDLOG_SEC),HL
1E48  22 0DFF           		LD	(LOGICAL_SEC),HL
                        					;FCB_PTR = FILE TO READ
1E4B  CD 8321           		CALL	DISK_READ	;HL=BUFF
1E4E  22 86FA           		LD	(LI_SDBUFF_PTR),HL	;Save Disk Buffer pointer
                        		
1E51  CD B51E           LI_TP		CALL	CLEAR_LINE_BUFF

1E54  ED4B 82FA         		LD	BC,(LI_FILESIZE) ;Low 16bits of Filesize counter (32bit)
1E58  11 00FA           		LD	DE, LINE_BUFF	;Data desination @DE
1E5B  2A 86FA           		LD	HL,(LI_SDBUFF_PTR) ;Data source (SD BUFFER)

1E5E  CD 9D1E           LI_LP		CALL	LI_GETDATA	;Fetch byte from SD_RAMBUFFER @HL
                        					;Advances to read next logical sector if HL>BUFF_SIZE
                        		
1E61  EDA0              LI_1		LDI			;COPY A BYTE.  (DE)=(HL), INC HL, INC DE, DEC BC
1E63  EA 7C1E           		JP PE,	LI_2		;Jump if BC>0, Not at End of File possible
                        		
                        					;BC=0
1E66  E5                		PUSH	HL		
1E67  2A 84FA           		LD	HL,(LI_FILESIZE+2) ;Check upper 32 bits for 0 or decrement size.
1E6A  37                		SCF
1E6B  ED42              		SBC	HL,BC		;HL=HL-0000-1 (HL=HL-1 with *Borrow*)
1E6D  30 09             		JR NC,	LI_1B
1E6F  EB                		EX	DE,HL
1E70  2A 08FF           		LD	HL,(FCB_PTR)
1E73  CBFE              		SET	7,(HL)		;SET FSTAT EOF FLAG
1E75  E1                		POP	HL
1E76  18 19             		JR	LI_EOL
                        		
                        		
1E78  22 84FA           LI_1B		LD	(LI_FILESIZE+2),HL
1E7B  E1                		POP	HL
                        	
1E7C  FE 0D             LI_2		CP	CR		;Test for CR
1E7E  20 08             		JR NZ,	LI_3
                        					;If CR, check if next char is LF
1E80  CD 9D1E           		CALL	LI_GETDATA	;Look ahead to next char
1E83  FE 0A             		CP	LF
1E85  20 0A             		JR NZ,	LI_EOL		;NO LF? Consider the CR as EOL
1E87  3C                		INC	A		;Nuke the LF
                        			
1E88  FE 0A             LI_3		CP	LF		;Test if LF
1E8A  28 05             		JR Z,	LI_EOL		;Jump if LF char copied
1E8C  3E 80             LI_4		LD	A,LOW LINE_BUFFEND
1E8E  BB                		CP	E
1E8F  20 CD             		JR NZ,	LI_LP

1E91  22 86FA           LI_EOL		LD	(LI_SDBUFF_PTR),HL	;Save SD_READ_BUFFER POINTER for next line
1E94  ED43 82FA         		LD	(LI_FILESIZE),BC ;Save count down for next line
1E98  21 00FA           		LD	HL, LINE_BUFF	;Return with HL=LINE_BUFF
1E9B  AF                		XOR	A		;Z=1
1E9C  C9                		RET

1E9D  7C                LI_GETDATA	LD	A,H		;Check for SD buffer over bounds
1E9E  FE FE             		CP	HIGH (SD_RAM_BUFFER + 0x200)
1EA0  7E                		LD	A,(HL)
1EA1  C0                		RET	NZ
1EA2  2A 88FA           		LD	HL,(LI_SDLOG_SEC) ;Read next 512 sector from file
1EA5  23                		INC	HL
1EA6  22 88FA           		LD	(LI_SDLOG_SEC),HL
1EA9  22 0DFF           		LD	(LOGICAL_SEC),HL
1EAC  C5                		PUSH	BC
1EAD  D5                		PUSH	DE
1EAE  CD 8321           		CALL	DISK_READ	;HL=BUFF
1EB1  D1                		POP	DE
1EB2  C1                		POP	BC
1EB3  7E                		LD	A,(HL)
1EB4  C9                		RET

1EB5  21 00FA           CLEAR_LINE_BUFF	LD	HL,LINE_BUFF	;Clear LINE_BUFF
1EB8  06 82             		LD	B, LOW (LINE_BUFFEND - LINE_BUFF) +2
1EBA  CD 100C           		CALL	CLEAR_BLOCK	;LINE FULL OF EOS
1EBD  C9                		RET

                        ;=============================================================================
                        ;	Read a HEX file and execute it
                        ;-----------------------------------------------------------------------------
1EBE  21 231E           READ_HEX_EXEC	LD	HL,LINE_INPUT
1EC1  22 5BFF           		LD	(HEX_SOURCE),HL

1EC4  CD EF1E           		CALL	READ_HEX_FILE
1EC7  D8                		RET	C		;CY=1 ERROR encountered

1EC8  3A 0CFF           		LD	A, (VIEW_FLAGS)	;When veiwing load, prompt EXECUTE
1ECB  0F                		RRCA
1ECC  D2 2D20           		JP  NC,	GH_EXEC

1ECF  CD CA0D           		CALL	PRINTI		;End of File Reached
1ED2  0D0A2D45 4F462D   		DB CR,LF,"-EOF-"
1ED9  0D0A4578 65637574 		DB CR,LF,"Execute?",EOS
1EE1  653F00
                        		
1EE4  CD DC13           		CALL	GET_CHAR
1EE7  E6 5F             		AND 	0x5F		;to upper case
1EE9  FE 59             		CP	'Y'
1EEB  CA 2D20           		JP Z,	GH_EXEC
1EEE  C9                		RET	



                        ;=============================================================================
                        ;	Read a HEX file
                        ;Input:	HEX_SOURCE must point to the routine that will fill LINE_BUFF with the next line
                        ;Output	CY=1 ERROR encountered,  Z=0 Time Out
                        ;-----------------------------------------------------------------------------
1EEF  CD 861C           READ_HEX_FILE	CALL	LED_HOME_PRINTI
1EF2  464C2000          		DB	'FL ',EOS
1EF6  21 0000           		LD	HL, 0		;Zero Line Counter
1EF9  22 8AFA           		LD	(RHF_LINES),HL
                        		

1EFC  2A 5BFF           RHF_LOOP	LD	HL,(HEX_SOURCE)
1EFF  CD A00C           		CALL	VCALL_HL	;JP	(HL)
1F02  37                		SCF
1F03  3F                		CCF			;CY=0
1F04  C0                		RET	NZ		;Exit if Z=1 (End of File or Serial Time Out)
                        				
1F05  2A 8AFA           		LD	HL, (RHF_LINES)	;Increment Line Counter
1F08  23                		INC	HL
1F09  22 8AFA           		LD	(RHF_LINES),HL
                        		
1F0C  7C                		LD	A,H		;Display line on LED
1F0D  45                		LD	B,L
1F0E  21 E3FF           		LD	HL,LED_DISPLAY+3
1F11  CD 461C           		CALL	LED_PUT_BYTE_HL
1F14  78                		LD	A,B
1F15  CD 461C           		CALL	LED_PUT_BYTE_HL
                        		
1F18  3A 0CFF           		LD	A, (VIEW_FLAGS)	;BIT .0=View HEX Load, .6=FILE SIZE
1F1B  0F                		RRCA
1F1C  30 06             		JR  NC,	RHF_DO
                        		
1F1E  21 00FA           		LD	HL, LINE_BUFF	;Reload HL
1F21  CD BD0D           		CALL	PRINT		
                        				
1F24  CD 2B1F           RHF_DO		CALL	RHF_LINE	;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
1F27  D8                		RET	C		;CY=1 ERROR encountered
1F28  20 D2             		JR  NZ,	RHF_LOOP	;Z=1 when End Of File record encountered
1F2A  C9                		RET
                        		
                        ;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
1F2B  21 00FA           RHF_LINE	LD	HL, LINE_BUFF	;Reload HL
1F2E  7E                		LD	A,(HL)
1F2F  FE 3A             		CP	':'		;Step 0, look for colon
1F31  28 0F             		JR Z,	RHF_OK1

1F33  B7                		OR	A		;If LINE BLANK then EOF
1F34  C8                		RET	Z		;Z=1,CY=0 EOF

1F35  CD CA0D           		CALL	PRINTI
1F38  0D0A434F 4C4F4E00 		DB CR,LF,"COLON",EOS
1F40  18 47             		JR	RHF_ERR_ON_LINE

1F42  E5                RHF_OK1		PUSH	HL
1F43  D1                		POP	DE		;DE=HL=LINE_BUFF
1F44  0E 00             		LD	C,0		;Convert remaining HEX characters to Binary values
1F46  06 02             RHF_BYTE_LP2	LD	B,2
1F48  23                RHF_BYTE_LP	INC	HL		;
1F49  7E                		LD	A,(HL)
1F4A  CD 980D           		CALL	ASC2HEX		;Process LSD char
1F4D  38 0C             		JR C,	RHF_NOT_HEX
1F4F  EB                		EX	DE,HL
1F50  ED6F              		RLD			;Shift digit to LINE_BUFF @ DE
1F52  EB                		EX	DE,HL
1F53  10 F3             		DJNZ	RHF_BYTE_LP	;Repeat for 2 HEX digits
1F55  1A                		LD	A,(DE)		;Update Checksum
1F56  81                		ADD	A,C
1F57  4F                		LD	C,A
1F58  13                		INC	DE
1F59  18 EB             		JR	RHF_BYTE_LP2	;Repeat for all HEX pairs
                        		
1F5B  CD 2720           RHF_NOT_HEX	CALL	IS_CRLF		;Test if final char is CR or LF
1F5E  28 14             		JR Z,	RHF_OK2
                        	
1F60  CD CA0D           		CALL	PRINTI
1F63  0D0A494E 56414C49 		DB CR,LF,"INVALID CHAR",EOS
1F6B  44204348 415200
1F72  18 15             		JR	RHF_ERR_ON_LINE

1F74  05                RHF_OK2		DEC	B
1F75  05                		DEC	B
1F76  28 2F             		JR Z,	RHF_OK3
1F78  CD CA0D           		CALL	PRINTI		;If B<>2 then there was a PAIRING error of HEX Digits
1F7B  0D0A4845 58205041 		DB CR,LF,"HEX PAIRING",EOS
1F83  4952494E 4700
                        		;JR	RHF_ERR_ON_LINE
                        		
1F89  CD CA0D           RHF_ERR_ON_LINE	CALL	PRINTI
1F8C  20455252 4F52204F 		DB " ERROR ON LINE# 0x",EOS
1F94  4E204C49 4E452320
1F9C  307800
1F9F  2A 8AFA           		LD	HL, (RHF_LINES)
1FA2  CD EA0D           		CALL	PUT_HL
1FA5  37                		SCF			;Return with ERROR
1FA6  C9                		RET			;Z=?,CY=1 ERROR


1FA7  3A 00FA           RHF_OK3		LD	A,(LINE_BUFF)	;Get Size of HEX line
1FAA  7B                		LD	A,E		;Get number of bytes processed from hex line
1FAB  D6 00             		SUB	LOW LINE_BUFF
1FAD  21 00FA           		LD	HL,LINE_BUFF
1FB0  96                		SUB	(HL)		;Subtract the number of bytes indicated in the HEX Line
1FB1  FE 05             		CP	5
1FB3  28 0E             		JR Z,	RHF_OK4
1FB5  CD CA0D           		CALL	PRINTI		;
1FB8  0D0A4C45 4E475448 		DB CR,LF,"LENGTH",EOS
1FC0  00
1FC1  18 C6             		JR	RHF_ERR_ON_LINE
                        		
                        ; LLAAAAFF000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1FXX
                        ;:200000000000000000000000000000000000000000000000000000000000000000000000E0
                        ;
                        ;Length is 0x20 bytes, total line length is then 0x25 (len+add+field+data+chksum)  1+2+1+20+1

1FC3  79                RHF_OK4		LD	A,C
1FC4  B7                		OR	A
1FC5  28 10             		JR Z,	RHF_OK5
1FC7  CD CA0D           		CALL	PRINTI		;If B<>2 then there was a PAIRING error of HEX Digits
1FCA  0D0A4348 45434B53 		DB CR,LF,"CHECKSUM",EOS
1FD2  554D00
1FD5  18 B2             		JR	RHF_ERR_ON_LINE

1FD7  21 03FA           RHF_OK5		LD	HL,LINE_BUFF+3	;FIELD TYPE
1FDA  7E                		LD	A,(HL)
1FDB  B7                		OR	A
1FDC  28 29             		JR Z,	RHF_OK6
1FDE  3D                		DEC	A
1FDF  C8                		RET	Z		;Z=1,CY=0 EOF
1FE0  CD CA0D           		CALL	PRINTI		;If B<>2 then there was a PAIRING error of HEX Digits
1FE3  0D0A554E 4B4E4F57 		DB CR,LF,"UNKNOWN RECORD TYPE, IGNORED",EOS
1FEB  4E205245 434F5244
1FF3  20545950 452C2049
1FFB  474E4F52 454400
2002  CD 891F           		CALL	RHF_ERR_ON_LINE
2005  18 1D             		JR	RHF_DO_NEXTL
                        		
2007  2B                RHF_OK6		DEC	HL		;ADDRESS (BIG ENDIAN)
2008  5E                		LD	E,(HL)
2009  2B                		DEC	HL
200A  56                		LD	D,(HL)
                        		
200B  2B                		DEC	HL		;Length
200C  7E                		LD	A,(HL)
200D  4F                		LD	C,A
200E  06 00             		LD	B,0

2010  21 0CFF           		LD	HL, VIEW_FLAGS
2013  CB4E              		BIT	1,(HL)
2015  C2 1F20           		JP  NZ,	RHF_OK7
2018  CBCE              		SET	1,(HL)
201A  EB                		EX	DE,HL
201B  22 0AFF           		LD	(GH_START), HL
201E  EB                		EX	DE,HL

201F  21 04FA           RHF_OK7		LD	HL,LINE_BUFF+4	;DATA
2022  EDB0              		LDIR
2024  AF                RHF_DO_NEXTL	XOR	A
2025  3D                		DEC	A
2026  C9                		RET			;Z=0,CY=0 IGNORE


2027  FE 0D             IS_CRLF		CP	CR
2029  C8                		RET 	Z
202A  FE 0A             		CP	LF
202C  C9                		RET

202D  3A 0CFF           GH_EXEC		LD	A, (VIEW_FLAGS)
2030  CB4F              		BIT	1,A
2032  20 20             		JR NZ,	GH_EXEC_GO
2034  CD CA0D           		CALL	PRINTI
2037  0D0A2121 21205354 		DB CR,LF,"!!! START ADDRESS NOT SET",EOS
203F  41525420 41444452
2047  45535320 4E4F5420
204F  53455400
2053  C9                		RET

2054  2A 0AFF           GH_EXEC_GO	LD	HL, (GH_START)	;HL = JUMP ADDRESS
2057  CD CA0D           GH_EXEC_GO2	CALL	PRINTI
205A  0D0A4578 65637574 		DB CR,LF,"Execute at:",EOS
2062  65206174 3A00
                        		
2068  CD EA0D           		CALL	PUT_HL
206B  CD 1F0E           		CALL	PUT_NEW_LINE

206E  E5                		PUSH	HL
206F  21 7E20           		LD	HL,HR_EXEC_GO_SUB	;Copy from
2072  11 53FB           		LD	DE,HR_EXE_GO		;Copy to
2075  01 0800           		LD	BC,HR_EXEC_GS_LEN	;Length=11 bytes
2078  EDB0              		LDIR
207A  E1                		POP	HL
207B  C3 53FB           		JP	HR_EXE_GO

207E  3E 01             HR_EXEC_GO_SUB	LD	A,1
2080  32 D9FF           		LD	(RRSTATE),A
2083  D3 C1             		OUT	(RAMROM),A
2085  E9                		JP	(HL)	;Execute the Get HEX

      = 0008            HR_EXEC_GS_LEN	EQU	$-HR_EXEC_GO_SUB



                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_14	FILE Support Routines
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;

                        ;=============================================================================
                        		;Find File w/ Verbose Output
                        		;Call with File Name set in FILENAME.EXT
                        		;Return Z=1 File Not Found
                        		;	Z=0 File Found, HL = Ptr to Directory Entry in SD_RAM_BUFFER
                        		;Destroys A,B,C
2086  3A 0CFF           SDV_FIND_FILE	LD	A,(VIEW_FLAGS)	;BIT .0=View HEX Load, .6=Display FILE SIZE, .7=Display File name & Found or Not
2089  07                		RLCA
208A  30 2C             		JR NC,	SD_FIND_FILE	;Call the Find File routine
208C  21 43FF           		LD	HL,FILENAME
208F  CD 0021           		CALL	PRINT_FILENAME
2092  CD B820           		CALL	SD_FIND_FILE	;Call the Find File routine
2095  F5                		PUSH	AF
2096  C2 AA20           		JP NZ,	SDV_FOUND	;Print Yah or Nah
2099  CD CA0D           		CALL 	PRINTI
209C  202D4E4F 5420464F 		DB " -NOT FOUND",EOS
20A4  554E4400
20A8  F1                		POP	AF
20A9  C9                		RET
20AA  CD CA0D           SDV_FOUND	CALL 	PRINTI
20AD  202D4558 49535453 		DB " -EXISTS",EOS
20B5  00
20B6  F1                		POP	AF
20B7  C9                		RET

                        ;=============================================================================
                        		;Find File
                        		;Call with File Name set in RAM variable: FILENAME.EXT
                        		;Return Z=1 File Not Found
                        		;	Z=0 File Found, HL = Ptr to Directory Entry in SD_RAM_BUFFER
20B8  CD C620           SD_FIND_FILE	CALL	SD_LDIR1
20BB  C8                SDFF_LP 	RET Z			;End of list
20BC  CD 5E21           		CALL	CMP_FILENAME	;Compares file name at (HL) with FILENAME.EXT in RAM
20BF  C0                		RET NZ			;FILE FOUND
20C0  CD DB20           		CALL	SD_LDIRN
20C3  C3 BB20           		JP	SDFF_LP


                        ;=============================================================================
                        ;Directory Routines.  1st Routine to start/init the search, 2nd routine to continue the search
                        ;-----------------------------------------------------------------------------
                        ;Call this routine to initialize and start the HL Pointer to the first Directory Entry
20C6  21 35FF           SD_LDIR1	LD	HL,DIR_SECTOR	;SEC_PTR = DIR_SECTOR
20C9  CD 3927           		CALL	MOV_32_HL
20CC  2A 25FF           		LD	HL, (ROOTDIR_SIZE)	;ENT_COUNT = ROOTDIR_SIZE (to count down directory entries searched)
20CF  22 41FF           		LD	(ENT_COUNT), HL
                        		

20D2  CD 9124           SD_FETCH	CALL	SD_READ_SEC		;Fetch a ROOT DIRECTORY sector
20D5  21 00FC           		LD	HL,SD_RAM_BUFFER	;(Re)start H at start of Sector
20D8  AF                SD_TEST		XOR	A			;EXIT Z=0 if there is a File at this entry
20D9  BE                		CP	(HL)
20DA  C9                		RET

                        ;=============================================================================
                        ;Call this routine to advance to the next Directory Entry (loads next sector and restarts HL as needed)
                        ;-----------------------------------------------------------------------------
20DB  01 2000           SD_LDIRN	LD	BC,20h		;Advance to next file entry
20DE  09                		ADD	HL,BC
20DF  7C                		LD	A,H
20E0  FE FE             		CP	HIGH SD_RAM_BUFFER+200h
20E2  C2 D820           		JP NZ,	SD_TEST		;Check if extended beyond this sector

20E5  AF                		XOR	A		;Return Z=1 if no more files
20E6  2A 41FF           		LD	HL, (ENT_COUNT)
20E9  01 F0FF           		LD	BC,-16
20EC  09                		ADD	HL,BC
20ED  22 41FF           		LD	(ENT_COUNT), HL
20F0  D0                		RET NC			;Out of Directory entries
20F1  7C                		LD	A,H
20F2  B5                		OR	L
20F3  C8                		RET Z			;Out of Directory entries

20F4  21 3DFF           		LD	HL,SEC_PTR	;Advance to next SECTOR
20F7  CD 3927           		CALL	MOV_32_HL
20FA  CD 6027           		CALL	INC_32
20FD  C3 D220           		JP	SD_FETCH


                        ;=============================================================================
                        ;	Prints Filename at HL (DESTROYS A)
                        ;-----------------------------------------------------------------------------
2100  E5                PRINT_FILENAME	PUSH	HL
2101  C5                		PUSH	BC
2102  06 08             		LD	B,8
2104  CD 1821           		CALL	PRINT_BS	;Print up to 8 characters or until an encouter with Space or NULL
2107  3E 2E             		LD	A,'.'
2109  CD E813           		CALL	PUT_CHAR
210C  48                		LD	C,B		;Adjust HL to +8
210D  06 00             		LD	B,0	
210F  09                		ADD	HL,BC
2110  06 03             		LD	B,3
2112  CD 1821           		CALL	PRINT_BS	;Print up to 3 characters or until an encouter with Space or NULL
2115  C1                		POP	BC
2116  E1                		POP	HL
2117  C9                		RET

2118  7E                PRINT_BS	LD	A,(HL)		;PRINT B CHARS OR UP TO EITHER A NULL OR SPACE.
2119  B7                		OR	A
211A  C8                		RET Z
211B  FE 20             		CP	' '
211D  C8                		RET Z
211E  CD E813           		CALL	PUT_CHAR
2121  23                		INC	HL
2122  10 F4             		DJNZ	PRINT_BS
2124  C9                		RET


                        ;=============================================================================
                        ;	OUTPUT: FILENAME ENTERED, C=0
                        ;		<ESC> PRESSED C=1
2125  CD CA0D           INPUT_FILENAME	CALL 	PRINTI		;Display Menu Prompt
2128  0D0A454E 54455220 		DB CR,LF,"ENTER 8.3 FILE NAME> ",EOS
2130  382E3320 46494C45
2138  204E414D 453E2000
2140  21 43FF           		LD	HL,FILENAME
2143  06 0B             		LD	B,11
2145  3E 20             		LD	A,' '
2147  CD 160C           		CALL	FILL_BLOCK
214A  0E 2E             		LD	C,'.'
214C  06 08             		LD	B,8
214E  CD 9227           		CALL	GET_STRING
2151  D8                		RET C
2152  FE 0D             		CP	13
2154  C8                		RET	Z
2155  21 4BFF           		LD	HL,FILEEXT
2158  06 03             		LD	B,3
215A  CD 9227           		CALL	GET_STRING
215D  C9                		RET

                        ;=============================================================================
215E  E5                CMP_FILENAME	PUSH	HL		;Save H pointer into  Directory
215F  01 0800           		LD	BC,8		;Compare 8 characters
2162  11 43FF           		LD	DE,FILENAME
2165  CD 7B21           		CALL	CMP_STRING
2168  20 0E             		JR NZ,	CMPF_RETFAIL	;Exit if not equal
                        		;ADD	HL,BC		;Adjust HL to +8, HL should be +8
216A  01 0300           		LD	BC,3
216D  11 4BFF           		LD	DE,FILEEXT
2170  CD 7B21           		CALL	CMP_STRING
2173  20 03             		JR NZ,	CMPF_RETFAIL	;Exit if not equal
2175  0C                		INC	C		;Z=0
2176  E1                		POP	HL
2177  C9                		RET
                        		
2178  AF                CMPF_RETFAIL	XOR	A		;Z=1
2179  E1                		POP	HL
217A  C9                		RET

217B  1A                CMP_STRING	LD	A, (DE)
217C  EDA1              		CPI			;CP (HL):INC HL:DEC BC
217E  C0                		RET NZ			;Exit if not equal
217F  E0                		RET PO			;Exit if end of string
2180  13                		INC	DE
2181  18 F8             		JR	CMP_STRING


                        ;=====================================================================================================
                        ;Read of Logical Disk Sector.
                        ;=====================================================================================================
                        	;Start-of-Directory = Size-of-Fat * Number-of-fats + 1 (boot sector)
                        	;Start-of-Data-Area = Start-of-Directory + #Entries/32/bytes_per_sector

                        	;Input:	LOGICAL_SEC Disk Sector required (0 to 2001) based on 26 sectors per track by 77 tracks, counting from 0
                        	;Disk FCB in HL

                        	;if AFClus0 = 0x0000 then attempt to open the file report Disk not loaded if fail
                        	;Relative file sector:
                        	;DISK_SEC is the input to this routine, it holds Virtual Disk Sector 0 to 2001
                        	;because every SD sector has 512 bytes, each SD sector holds 4 CP/M Virtual Disk sectors (that's 128 bytes)
                        	;RFSec is the Relative File Sector, it spans from 0 to 500 (this accomodates 501 SD Sectors or 256,512 bytes)
                        	;If RFSec = DISK_SEC / 4 Then...
                        	;If RFSec has not changed, then read that sector into RAM and be done.
                        	;That Relative File sector is located on the SD card at address set in the absolute sector (ABS_SEC)
                        	;
                        	;If RFSec has changed... then determine is the new RFSec is within the same cluster or not.
                        	;On a 1Gig SD card, the system uses 32 sectors per cluster.  This means, 32 sequential SD Memory Card sectors form 1 cluster.
                        	;If a sector within the same cluster is being accessed, then the cluster does not have to be found again.
                        	;If it's NOT in the same cluster, then find new cluster by looking through the FAT
                        	;If it is in the same cluster, then skip to the part were we can just offset the RFSec into the current cluster
                        	;
                        	;...else
                        	;RFSec = DISK_SEC / 4  'Set the new sector as the current one.
                        	;
                        	;Find the Relative File Cluster (RFClus).  This number will be from 0 to 15 on a 1Gig SD Card = 262,144 bytes (to hold a 256,256 file)
                        	;
                        	;Relative file cluster:
                        	;RFClus = RFSec / SEC_PER_CLUS
                        	;if RFClus has changed, then recalculate the File Cluster and then update the SSOC.
                        	;  if RFClus < CRFClus then CRFClus=0, CAFClus = AFClus0  'start FAT search from 0 if going backward
                        	;  RFClus = RFClus - CRFClus
                        	;  do while RFClus>0
                        	;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
                        	;      CAFClus = FAT(CAFClus)
                        	;      CRFClus = CRFClus + 1
                        	;      RFClus = RFClus - 1
                        	;  loop
                        	;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
                        	;if RFClus has NOT changed, then ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
                        ;Destroys: A, BC, DE, HL, IX
                        ;=====================================================================================================
                        ;Read of Logical Disk Sector.
                        ;Input:	LOGICAL_SEC = 0=First Sector
2183                    DISK_READ	
                        		;CALL	PRINTI		;debug
                        		;DB  " R-",EOS		;debug
                        		;LD	HL,(LOGICAL_SEC);debug
                        		;CALL	PUT_HL		;debug

2183  DD2A 08FF         		LD	IX,(FCB_PTR)	;Get Current Disk FCB
2187  DD7E 00           		LD	A,(IX)		;Is file open?
218A  B7                		OR	A		;Test FSTAT
218B  C2 AE21           		JP NZ,	DR_1		;Jump YES
                        		
                        		;PUSH	IX		;debug
                        		;POP	HL		;debug
                        		;CALL	PRINTI		;debug
                        		;DB  " HL:",EOS		;debug
                        		;CALL	PUT_HL		;debug
                        		
218E  CD B11D           		CALL	SD_OPEN		;ELSE, Attempt to open file
2191  DD7E 00           		LD	A, (IX)		;Is file open?
2194  B7                		OR	A		;Test FSTAT
2195  C2 AE21           		JP NZ,	DR_1		;Jump YES
2198  CD CA0D           		CALL	PRINTI
219B  202D4469 736B204E 		DB " -Disk Not Loaded",EOS
21A3  6F74204C 6F616465
21AB  6400
21AD  C9                		RET			;Exit if file could not open

21AE  DD6E 12           DR_1		LD	L,(IX+RFSec)	;If file open, Check if Read is from same Data Sector
21B1  DD66 13           		LD	H,(IX+RFSec+1)	;D=RFSec

                        		;CALL	PRINTI		;debug
                        		;DB  " LS:",EOS		;debug
                        		;CALL	PUT_DE		;debug

21B4  ED5B 0DFF         		LD	DE, (LOGICAL_SEC) ;Fetch sector to be read
21B8  CD 8C27           		CALL	CMP_DE_HL
21BB  C2 CB21           		JP NZ,	DR_NEW_SEC	;Jump if Read is from a different Data Sector

                        					;LOGICAL SECTOR = LAST READ SECTOR, Fetch Absolute Sector and read it to RAM (if wasn't last read)
21BE  2A 08FF           		LD	HL,(FCB_PTR)	;Get Current Disk FCB
21C1  3E 18             		LD	A,ABS_SEC	;H=FCB(ABS_SEC)
21C3  85                		ADD	A,L
21C4  6F                		LD	L,A

21C5  CD 3927           		CALL	MOV_32_HL
21C8  C3 D022           		JP	DR_READ_IT


                        	;RFClus = RFSec / SEC_PER_CLUS
                        	;if RFClus has changed, then recalculate the File Cluster and then update the SSOC.
                        	;  if RFClus < CRFClus then
                        	;     CRFClus=0, CAFClus = AFClus0  'start FAT search from 0 if going backward
                        	;  eles
                        	;     RFClus = RFClus - CRFClus	   'else, continue FAT search from point of
                        	;  endif
                        	;  do while RFClus>0
                        	;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
                        	;      CAFClus = FAT(CAFClus)
                        	;      CRFClus = CRFClus + 1
                        	;      RFClus = RFClus - 1
                        	;  loop
                        	;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
                        	;if RFClus has NOT changed, then ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
                        	
21CB                    DR_NEW_SEC				;We are to read a sector of the file that is different from the last READ.
                        					;This branch would also take place on the first time we read a file, since
                        					;the "Last Sector Read" was set to a dummy value of 0xFFFF
                        					;
                        					;Save the sector we are now reading as "Last Sector Read" = RFSec

21CB  DD73 12           		LD	(IX+RFSec  ),E	;D=LOGICAL_SEC = Relative File Sector (Update FCB with this new Rel-File-Sec
21CE  DD72 13           		LD	(IX+RFSec+1),D	;

                        					;Find in which relative or sequential Cluster this sector is in
                        					;by dividing by the "Sectors per Cluster"
                        					;eg. If there are 4 sectors per cluster, then Sectors 0 to 3 will be in Cluster 0
                        					;Cluster 0 is the first cluster of the file and the location of this cluster
                        					;(the Absolute Cluster) is given by the directory entry for this file.

21D1  2A 52FF           		LD	HL, (DIVIDE_FUNC)	;DE = DE / Sectors-Per-Cluster (Divide Func hard coded with Sec/Clus)
21D4  CD A00C           		CALL	VCALL_HL

                        		;CALL	PRINTI		;debug
                        		;DB  " RC:",EOS		;debug
                        		;CALL	PUT_DE		;debug
                        		
21D7  2A 08FF           		LD	HL,(FCB_PTR)
21DA  3E 0E             		LD	A,CRFClus	;H=FCB(CRFClus)
21DC  85                		ADD	A,L
21DD  6F                		LD	L,A

21DE  4E                		LD	C,(HL)
21DF  23                		INC	HL
21E0  46                		LD	B,(HL)		;BC = CRFClus
21E1  2B                		DEC	HL

                        		;CALL	PRINTI		;debug
                        		;DB  " LRC:", EOS	;debug
                        		;CALL	PUT_BC		;debug


                        					;H->FCB(CRFClus)
                        					;TEST DE - BC  aka NewRFClus vs FCB-RFClus
                        					;Speed Optimize the above code
21E2  7A                		LD	A,D
21E3  B8                		CP	B
21E4  20 05             		JR NZ,	DR_DIFF_CLUS
21E6  7B                		LD	A,E
21E7  B9                		CP	C
21E8  CA AD22           		JP Z,	DR_SAME_CLUS	;IF they are the same, then the new sector is in the same cluster
21EB  30 07             DR_DIFF_CLUS	JR NC,	DR_BIGGER_CLUS

                        					;If going to a smaller cluster, restart the FAT search from the begining
21ED  01 0000           		LD	BC,0		;CRFClus = 0
21F0  2B                		DEC	HL
21F1  2B                		DEC	HL
21F2  18 08             		JR	DR_SEEK_FAT	;HL will load with AFClus0

21F4  7B                DR_BIGGER_CLUS	LD	A,E		;NewRFClus = NewRFClus - FCB-RFClus,  ie Set counter for number of new FAT hops.
21F5  91                		SUB	C
21F6  5F                		LD	E,A
21F7  7A                		LD	A,D
21F8  98                		SBC	A,B
21F9  57                		LD	D,A

21FA  23                		INC	HL
21FB  23                		INC	HL		;HL will load with CAFClus

                        	;  do while RFClus>0
                        	;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
                        	;      CAFClus = FAT(CAFClus)
                        	;      CRFClus = CRFClus + 1
                        	;      RFClus = RFClus - 1
                        	;  loop

21FC                    DR_SEEK_FAT
21FC  CD 4A0E           		CALL	LD_HL_HL	;HL = CAFClus or AFClus0

                        ;		CALL	PRINTI		;debug
                        ;		DB  CR,LF,"CAFClus=",EOS ;debug
                        ;		CALL	PUT_HL		;debug
                        ;		CALL	PRINTI		;debug
                        ;		DB  CR,LF,"CRFClus=",EOS ;debug
                        ;		CALL	PUT_BC		;debug
                        ;		CALL	PRINTI		;debug
                        ;		DB  CR,LF,"RFClus=",EOS	;debug
                        ;		CALL	PUT_DE		;debug

                        					;BC = CRFClus
21FF  7A                DR_SEEK_LP	LD	A,D		;DE = RFClus
2200  B3                		OR	E
2201  28 61             		JR Z,	DR_SEEK_DONE

                        ;		CALL	PRINTI		;debug
                        ;		DB  CR,LF,"seek=",EOS	;debug
                        ;		CALL	PUT_HL		;debug
                        				
2203  7C                		LD	A,H		;IF CAFClus = 0xFFFF... (No more clusters to fetch)
2204  A5                		AND	L
2205  2F                		CPL
2206  B7                		OR	A		
2207  C2 3622           		JP NZ,	DR_SEEK_1
                        					;Error, File too small
220A  CD CA0D           		CALL	PRINTI
220D  202D4552 524F522C 		DB " -ERROR, NO MORE ALLOCATED CLUSTERS!",EOS
2215  204E4F20 4D4F5245
221D  20414C4C 4F434154
2225  45442043 4C555354
222D  45525321 00
2232  76                		HALT
2233  C3 3222           		JP	$-1
                        		
2236                    DR_SEEK_1	

                        	;Here comes the FAT Hopping FUN...
                        	;      CAFClus = FAT(CAFClus)
                        	;it's convenient that 1 Sector is 512 bytes, that's 256 words = 256 FAT Entries, therefore...
                        	;H = Sector of FAT
                        	;L = Word within that Sector of FAT

2236  C5                		PUSH	BC
2237  D5                		PUSH	DE
2238  E5                		PUSH	HL
2239  5C                		LD	E,H		;E=Sector of FAT
223A  2A 31FF           		LD	HL, (FAT1START)	;DE = E + FAT1START
223D  7D                		LD	A,L
223E  83                		ADD	A,E
223F  5F                		LD	E,A
2240  7C                		LD	A,H
2241  CE 00             		ADC	A,0		;Carry it forward
2243  57                		LD	D,A
2244  2A 33FF           		LD	HL, (FAT1START+2)
2247  30 01             		JR NC,	DRS_0		;Test for Carry
2249  23                		INC	HL		;Carry it forward
224A  44                DRS_0		LD	B,H
224B  4D                		LD	C,L		;BCDE now have Sector of FAT desired
224C  CD 9124           		CALL	SD_READ_SEC
224F  D1                		POP	DE		;Fetch DE, E=Word within that FAT sector
2250  21 00FC           		LD	HL,SD_RAM_BUFFER
2253  B7                		OR	A		;Clear Carry
2254  7B                		LD	A,E		;Fetch offset into FAT sector read
2255  17                		RLA
2256  6F                		LD	L,A		;
2257  7C                		LD	A,H
2258  CE 00             		ADC	A,0
225A  67                		LD	H,A		;HL -> FAT Entry
225B  CD 4A0E           		CALL	LD_HL_HL	;HL = FAT Entry
225E  D1                		POP	DE
225F  C1                		POP	BC

2260  03                		INC	BC
2261  1B                		DEC	DE
2262  18 9B             		JR	DR_SEEK_LP

2264                    DR_SEEK_DONE	;Write Registers to FCB
                        		;BC = CRFClus  = The Relative Cluster (ie, the 5th cluster into the file)
                        		;DE = RFClus - Not required (it's a counter down to zero to find the correct cluster)
                        		;HL = CAFClus  = The Absolute or Actual Cluster (ie, Cluster 149 on the disk)

2264  DD2A 08FF         		LD	IX,(FCB_PTR)
2268  DD71 0E           		LD	(IX+CRFClus  ),C	;Save CRFClust to FCB
226B  DD70 0F           		LD	(IX+CRFClus+1),B
226E  DD75 10           		LD	(IX+CAFClus  ),L	;Save CAFClus to FCB
2271  DD74 11           		LD	(IX+CAFClus+1),H

                        	;Now, let's find the Data Sector to be loaded....
                        	;First, calculate the Starting Sector of Cluster (SSOC)
                        	;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area

2274  2B                		DEC	HL		;HL = CAFClus - 2
2275  2B                		DEC	HL
                        		
2276  EB                		EX	DE,HL

                        ;-------------------------------------	Multiply Routine.  16bit by 8 bit -> 24bit
2277  0E 00             		LD	C,0		;CDE = 16bit input (need 24 bits to shift)
2279  06 08             		LD	B,8		;Go through 8 bits
227B  DD21 21FF         		LD	IX, SEC_PER_CLUS	;Fetch Multiplier
227F  AF                		XOR	A
2280  21 0000           		LD	HL,0		;AHL = 24bit output
                        		
2283  DDCB 00 0E        DRSS_LP		RRC	(IX)
2287  30 02             		JR NC,	DRSS_SHIFT
2289  19                		ADD	HL,DE		;DE=DE+HL
228A  89                		ADC	A,C

228B  CB23              DRSS_SHIFT	SLA	E
228D  CB12              		RL	D
228F  CB11              		RL	C
2291  10 F0             		DJNZ	DRSS_LP
                        	
2293  4F                		LD	C,A
2294  06 00             		LD	B,0		;BCHL = 32bit Absolute sector
                        					;Add to BCHL, the DATASTART sector
2296  ED5B 39FF         		LD	DE, (DATASTART)	;32 Bit ADD DATASTART
229A  19                		ADD	HL, DE
229B  EB                		EX	DE, HL		;DE=DE+START (LSB)
229C  2A 3BFF           		LD	HL, (DATASTART+2)
229F  ED4A              		ADC	HL,BC
22A1  4D                		LD	C,L
22A2  44                		LD	B,H		;BC=BC+START (MSB)
                        ;-------
                        					;Save the result to RAM variable SSOC
22A3  2A 08FF           		LD	HL,(FCB_PTR)
22A6  3E 14             		LD	A,SSOC		;Set FCB(SSOC)
22A8  85                		ADD	A,L
22A9  6F                		LD	L,A		
22AA  CD 4427           		CALL	MOV_HL_32	;Save the 32 bit register BCDE to (HL)
                        ;-------

                        	;ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
22AD                    DR_SAME_CLUS				;Fetch the RFSec
22AD  DD2A 08FF         		LD	IX,(FCB_PTR)	;Set FCB(RFSec)
22B1  DD5E 12           		LD	E,(IX+RFSec)	;DE=RFSec
22B4  DD56 13           		LD	D,(IX+RFSec+1)

22B7  2A 56FF           		LD	HL,(MOD_FUNC)	;DE = DE % Sectors-Per-Cluster
22BA  CD A00C           		CALL	VCALL_HL	;A = RFSec MOD SEC_PER_CLUS

22BD  01 0000           		LD	BC,0		;BCDE = (RFSec MOD SEC_PER_CLUS)
22C0  16 00             		LD	D,0
22C2  5F                		LD	E,A

22C3  2A 08FF           		LD	HL,(FCB_PTR)
22C6  3E 14             		LD	A,SSOC		;Set FCB(SSOC)
22C8  85                		ADD	A,L
22C9  6F                		LD	L,A		
22CA  CD 4F27           		CALL	ADD_32_HL	;BCDE = SSOC + (RFSec MOD SEC_PER_CLUS)
                        					;(HL returns +4) to ABS_SEC

22CD  CD 4427           		CALL	MOV_HL_32	;Save the ABS_SEC

22D0  CD 9124           DR_READ_IT	CALL	SD_READ_SEC	;Fetch the Sector

22D3  21 00FC           		LD	HL,SD_RAM_BUFFER
22D6  C9                		RET



                        ;=====================================================================================================
                        ;=====================================================================================================
                        ;SD_CARD_TYPE	.BLOCK	1	;SD CARD TYPE
                        ;SDC_STATUS	.BLOCK	1	;SD Status Code returned
                        ;SD_PARAM	.BLOCK	4	;32 bit address parameter for SD Commands
                        ;SD_PART_TYPE	.BLOCK	1	;SD PARTITION TYPE
                        ;SD_PART_BASE	.BLOCK	4	;SD PARTITION STARTING RECORD
                        ;SD_PART_SIZE	.BLOCK	4	;SD PARTITION SIZE (Must follow SD_PART_BASE)
                        ;SEC_PER_CLUS	.BLOCK	1	;0x0D
                        ;RESERVED_SEC	.BLOCK	2	;0x0E - 0x0F
                        ;FAT_COPIES	.BLOCK	1	;0x10
                        ;RT_DIR_ENTRIES	.BLOCK	2	;0x11 - 0x12
                        ;TOT_FILESYS_SEC.BLOCK	4	;0x13 - 0x14 or 0x20 - 0x23
                        ;HIDDEN_SECTORS	.BLOCK	4	;0x1C - 0x1F
                        ;SEC_PER_FAT	.BLOCK	2	;0x16 - 0x17
                        ;FAT1START	.BLOCK	4	;Calculated
                        ;DIR_SECTOR	.BLOCK	4	;Calculated
                        ;DATASTART	.BLOCK	4	;Calculated
                        ;-----------------------------------------------------------------------------
22D7  21 0AFF           INIT_FAT	LD	HL,FAT_CLEAR	;Clear RAM
22DA  06 39             		LD	B,FAT_CLR_LEN
22DC  CD 100C           		CALL	CLEAR_BLOCK

22DF  CD 9625           		CALL	INIT_SDCARD
22E2  C0                		RET NZ			;RET NZ IF FAILED

22E3  CD CA0D           		CALL 	PRINTI		;
22E6  4D425200          		DB "MBR",EOS

22EA  01 0000           		LD	BC,0		;BCDE = 0x00000000
22ED  11 0000           		LD	DE,0
22F0  CD AF24           		CALL	SD_RS_FORCED	;READ MBR (FORCED READ)
22F3  CD 7E24           		CALL	TEST_SIGNATURE
22F6  C0                		RET NZ			;RET NZ IF FAILED

22F7  CD CA0D           		CALL 	PRINTI		;
22FA  20547970 6500     		DB " Type",EOS
2300  3A C2FD           		LD	A, (SD_RAM_BUFFER+01C2h)
2303  CD F60D           		CALL	PUT_BYTE
2306  32 16FF           		LD	(SD_PART_TYPE), A
2309  FE 04             		CP	4
230B  28 09             		JR   Z,	INITFAT_PGOOD
230D  FE 06             		CP	6
230F  28 05             		JR   Z,	INITFAT_PGOOD
2311  FE 86             		CP	86h
2313  C2 6624           		JP  NZ,	INITFAT_FAIL

2316  21 C6FD           INITFAT_PGOOD	LD	HL,SD_RAM_BUFFER+1C6h
2319  11 17FF           		LD	DE,SD_PART_BASE
231C  01 0800           		LD	BC,8
231F  EDB0              		LDIR		;Copy BASE & SIZE from BUFFER to RAM Variables
2321  CD CA0D           		CALL 	PRINTI		;
2324  20504252 00       		DB " PBR",EOS

2329  21 17FF           		LD	HL,SD_PART_BASE
232C  CD 3927           		CALL	MOV_32_HL	;Copy BASE to SEC_PTR
232F  CD 9124           		CALL	SD_READ_SEC	;READ BOOT RECORD OF PARTITION
2332  CD 7E24           		CALL	TEST_SIGNATURE
2335  C0                		RET NZ

2336  21 0BFC           		LD	HL,SD_RAM_BUFFER+0Bh
2339  11 1FFF           		LD	DE,BYTE_P_SEC
233C  01 0A00           		LD	BC,10
233F  EDB0              		LDIR	;Copy Description Table to RAM Variables (Up to Total Filesys Sectors)
2341  EB                		EX	DE, HL	;Test TOTAL_FILESYS_SECTORS = 0
2342  2B                		DEC	HL
2343  2B                		DEC	HL
2344  7E                		LD	A,(HL)
2345  23                		INC	HL
2346  B6                		OR	(HL)
2347  20 0C             		JR  NZ,	INITFAT_TFS_OK
2349  2B                		DEC	HL
234A  EB                		EX	DE, HL	
234B  21 20FC           		LD	HL,SD_RAM_BUFFER+020h
234E  01 0400           		LD	BC,4
2351  EDB0              		LDIR
2353  18 07             		JR	INITFAT_TFS_DONE

2355  AF                INITFAT_TFS_OK	XOR	A
2356  23                		INC	HL
2357  77                		LD	(HL),A
2358  23                		INC	HL
2359  77                		LD	(HL),A
235A  23                		INC	HL
235B  EB                		EX	DE, HL	
235C                    INITFAT_TFS_DONE

235C  21 1CFC           		LD	HL,SD_RAM_BUFFER+01Ch
235F  01 0400           		LD	BC,4
2362  EDB0              		LDIR			;Copy HIDDEN_SECTORS to RAM Variables
2364  21 16FC           		LD	HL,SD_RAM_BUFFER+016h
2367  01 0200           		LD	BC,2
236A  EDB0              		LDIR			;Copy SECTORS_PER_FAT to RAM Variables

                        ;BS.fat1Start = MBR.part1Start + BS.reservedSectors;
236C  2A 22FF           		LD	HL, (RESERVED_SEC)	;H=Reserved Sectors
236F  EB                		EX	DE, HL	
2370  2A 17FF           		LD	HL, (SD_PART_BASE)	;FAT1START = SD_PART_BASE + RESERVED_SEC
2373  19                		ADD	HL,DE
2374  22 31FF           		LD	(FAT1START), HL
2377  2A 19FF           		LD	HL, (SD_PART_BASE+2)
237A  30 01             		JR  NC,	INITFAT_C1_DONE
237C  23                		INC	HL
237D  22 33FF           INITFAT_C1_DONE	LD	(FAT1START+2), HL

                        ;firstDirSector = BS.fat1Start + (BS.fatCopies * BS.sectorsPerFAT);
2380  3A 24FF           		LD	A, (FAT_COPIES)
2383  47                		LD	B,A
2384  2A 2FFF           		LD	HL, (SEC_PER_FAT)
2387  EB                		EX	DE, HL	
2388  21 0000           		LD	HL,0
238B  19                INITFAT_C2_LP	ADD	HL,DE
238C  10 FD             		DJNZ	INITFAT_C2_LP	;H = FAT_COPIES * SEC_PER_FAT
238E  EB                		EX	DE, HL		;DE = FATS * SECperFAT
238F  2A 31FF           		LD	HL, (FAT1START)
2392  19                		ADD	HL,DE		;DIR_SECTOR = FAT1START + FAT_COPIES * SEC_PER_FAT
2393  22 35FF           		LD	(DIR_SECTOR), HL
2396  2A 33FF           		LD	HL, (FAT1START+2)
2399  30 01             		JR  NC,	INITFAT_C2_DONE
239B  23                		INC	HL
239C  22 37FF           INITFAT_C2_DONE	LD	(DIR_SECTOR+2), HL

                        ;DATASTART = DIR_SECTOR + LEN(Directory)
                        ;          = DIR_SECTOR + ROOTDIR_SIZE * 32 / BYTE_P_SEC
239F  06 10             		LD	B,16		;Maximum # of Reductions
23A1  2A 1FFF           		LD	HL, (BYTE_P_SEC)	;To fit math into 16 bits, let's reduce "ROOTDIR_SIZE / BYTE_P_SEC"
23A4  EB                		EX	DE, HL	;Divide each by 2 while dividable
23A5  2A 25FF           		LD	HL, (ROOTDIR_SIZE)	;H=ROOTDIR_SIZE, D=BYTE_P_SEC
23A8  7B                INITFAT_C3_LP	LD	A,E
23A9  1F                		RRA
23AA  38 29             		JR  C,	INITFAT_C3_0	;If lsb of D is 1, no more Reduction possible
23AC  7D                		LD	A,L
23AD  1F                		RRA
23AE  38 25             		JR  C,	INITFAT_C3_0	;If lsb of H is 1, no more Reduction possible
23B0  7A                		LD	A,D
23B1  1F                		RRA
23B2  57                		LD	D,A
23B3  7B                		LD	A,E
23B4  1F                		RRA
23B5  5F                		LD	E,A
23B6  7C                		LD	A,H
23B7  1F                		RRA
23B8  67                		LD	H,A
23B9  7D                		LD	A,L
23BA  1F                		RRA
23BB  6F                		LD	L,A
23BC  10 EA             		DJNZ	INITFAT_C3_LP

23BE  CD CA0D           INITFAT_C3_ERR	CALL 	PRINTI		;
23C1  20457272 6F722044 		DB " Error DATASTART",EOS
23C9  41544153 54415254
23D1  00
23D2  AF                		XOR	A
23D3  3D                		DEC	A
23D4  C9                		RET
                        		
23D5  06 05             INITFAT_C3_0	LD	B,5		;5 shifts = Multiply 32
23D7  29                INITFAT_C3_LP2	ADD	HL,HL		;Double H
23D8  DA BE23           		JP C,	INITFAT_C3_ERR
23DB  10 FA             		DJNZ	INITFAT_C3_LP2

23DD  7B                		LD	A,E		;2'S Complement BYTE_P_SEC
23DE  2F                		CPL
23DF  4F                		LD	C,A
23E0  7A                		LD	A,D
23E1  2F                		CPL
23E2  47                		LD	B,A
23E3  03                		INC	BC
23E4  11 FFFF           		LD	DE,0FFFFh	;Start with -1
23E7  09                INITFAT_C3_LP3	ADD	HL,BC		;Divide by counting Subtractions
23E8  13                		INC	DE
23E9  38 FC             		JR   C,	INITFAT_C3_LP3
23EB  2A 35FF           		LD	HL, (DIR_SECTOR)	;Add the Dword at DIR_SECTOR
23EE  19                		ADD	HL,DE
23EF  22 39FF           		LD	(DATASTART), HL
23F2  2A 37FF           		LD	HL, (DIR_SECTOR+2)
23F5  30 01             		JR  NC,	INITFAT_C3_1
23F7  23                		INC	HL
23F8  22 3BFF           INITFAT_C3_1	LD	(DATASTART+2), HL

23FB  3A 21FF           		LD	A, (SEC_PER_CLUS)	;Determine the best way to divide Sectors into cluster#
23FE  3D                		DEC	A
23FF  32 58FF           		LD	(MODMASK), A
2402  3C                		INC	A
2403  28 4B             		JR   Z,	INITFAT_FAIL1
2405  01 0008           		LD	BC,0800h
2408  1F                INITFAT_C4_LP	RRA
2409  30 02             		JR  NC,	INITFAT_C4_1
240B  50                		LD	D,B		;Save location of "1" bit
240C  0C                		INC	C		;Count of 1 bits.
240D  10 F9             INITFAT_C4_1	DJNZ	INITFAT_C4_LP
240F  3E 01             		LD	A,1
2411  B9                		CP	C
2412  20 0F             		JR  NZ,	INITFAT_C4_2	;More than 1 "1" bit, cannot do divide by simple shift.
2414  7A                		LD	A,D		;Fetch position of the 1 bit.  8=lsb, 1=msb
2415  2F                		CPL
2416  C6 0A             		ADD	A,10		;Re-adjust to make 1=lsb AND 8=msb  A=9-A
2418  32 54FF           		LD	(DF_SHIFTCNT), A
241B  21 2727           		LD	HL,DIVBYSHIFT	;Use fast shift divider
241E  11 3427           		LD	DE,MODBYMASK
2421  18 05             		JR	INITFAT_C4_3

2423  21 0F27           INITFAT_C4_2	LD	HL,DIV16BY8SPC	;Use Full Divide function for Sectors Per Cluster
2426  E5                		PUSH	HL
2427  D1                		POP	DE
2428  22 52FF           INITFAT_C4_3	LD	(DIVIDE_FUNC), HL
242B  EB                		EX	DE, HL	
242C  22 56FF           		LD	(MOD_FUNC), HL

242F  CD CA0D           		CALL 	PRINTI		;
2432  20564F4C 3D00     		DB " VOL=",EOS
2438  21 2BFC           		LD	HL,SD_RAM_BUFFER+002Bh
243B  06 0B             		LD	B,11
243D  CD D00D           		CALL	PRINTB
2440  CD CA0D           		CALL 	PRINTI		;
2443  20535953 3D00     		DB " SYS=",EOS
2449  06 08             		LD	B,8
244B  CD D00D           		CALL	PRINTB
244E  AF                		XOR	A
244F  C9                		RET

2450  CD CA0D           INITFAT_FAIL1	CALL 	PRINTI		;
2453  0D0A4572 726F723D 		DB CR,LF,"Error=0 Sec/Clus",EOS
245B  30205365 632F436C
2463  757300
2466  CD CA0D           INITFAT_FAIL	CALL 	PRINTI		;
2469  0D0A4641 5420496E 		DB CR,LF,"FAT Init FAILED",EOS
2471  69742046 41494C45
2479  4400
247B  AF                		XOR	A
247C  3D                		DEC	A
247D  C9                		RET

                        ;-------------------------------------------------
247E  CD CA0D           TEST_SIGNATURE	CALL 	PRINTI		;
2481  205300            		DB " S",EOS
2484  2B                		DEC	HL
2485  3E AA             		LD	A,0AAh
2487  BE                		CP	(HL)
2488  20 DC             		JR  NZ,	INITFAT_FAIL
248A  2B                		DEC	HL
248B  3E 55             		LD	A,055h
248D  BE                		CP	(HL)
248E  20 D6             		JR  NZ,	INITFAT_FAIL
2490  C9                		RET



                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_15	SD Memory Card Routines, Mid Level, Send/Recieve Data Sectors (Writes out Dirty Data)
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;

                        ;-----------------------------------------------------------------------------------------------------
                        ;Read the SD Card at Sector BCDE TO the SD_RAM_BUFFER
                        ;-----------------------------------------------------------------------------------------------------
                        		;Sector in SEC_PTR
2491  21 3DFF           SD_READ_SEC	LD	HL,SEC_PTR	;READ SECTOR
2494  CD 7327           		CALL	CMP_HL_32
2497  C8                		RET Z			;Return if no change to sector being read

2498  3A 0FFF           		LD	A, (DIRTY_DATA)	;Test if flush required
249B  B7                		OR	A
249C  CA AF24           		JP Z,	SD_RS_FORCED	;Jump if no change in SD RAM BUFFER
249F  AF                		XOR	A
24A0  32 0FFF           		LD	(DIRTY_DATA), A	;Clear Write Flag

24A3  C5                		PUSH	BC		;Save BCDE (Sector to Read)
24A4  D5                		PUSH	DE
24A5  E5                		PUSH	HL
24A6  CD 3927           		CALL	MOV_32_HL	;Fetch the last SEC_PTR

                        ;		CALL	PRINTI		;debug
                        ;		DB  " Write:",EOS	;debug
                        ;		CALL	PUT_BC		;debug
                        ;		CALL	PUT_DE		;debug

24A9  CD EF24           		CALL	SD_WRITE_SEC
24AC  E1                		POP	HL
24AD  D1                		POP	DE
24AE  C1                		POP	BC
                        		
24AF                    SD_RS_FORCED
                        	;CALL	PRINTI		;debug
                        	;DB  " Read:",EOS	;debug
                        	;CALL	PUT_BC		;debug
                        	;CALL	PUT_DE		;debug

24AF  21 3DFF           		LD	HL,SEC_PTR
24B2  CD 4427           		CALL	MOV_HL_32	;Save Sector in SEC_PTR
24B5  CD 6D25           		CALL	SET_PARAM	;READ SECTOR, HL=SD_RAM_BUFFER
24B8  06 05             		LD	B,5		;5 Retries to read
24BA  3E 11             SD_RS_LP0	LD	A,17 		;Read Sector Command
24BC  CD 9026           		CALL	SD_CMD
24BF  28 07             		JR Z,	SD_RS_0
24C1  10 F7             		DJNZ	SD_RS_LP0
                        					;Read failed
24C3  05                		DEC	B		;Clear Zero flag
24C4  CD 7826           		CALL	SD_DESELECT	;Deselect card
                        	;CALL	PRINTI	;debug
                        	;DB  " #1",EOS	;debug
24C7  C9                		RET

24C8  06 00             SD_RS_0		LD	B,0		;256 Attempts to recieve the DATASTART
24CA  CD D926           SD_RS_LP1	CALL	SPI_RX
24CD  FE FE             		CP	0FEh		;IS DATASTART?
24CF  28 06             		JR Z,	SD_RS_1
24D1  10 F7             		DJNZ	SD_RS_LP1
24D3  CD 7826           		CALL	SD_DESELECT	;Deselect card
                        	;CALL	PRINTI	;debug
                        	;DB  " #2",EOS	;debug
24D6  C9                		RET

24D7  01 0002           SD_RS_1		LD	BC,0200h
24DA  CD D926           SD_RS_LP2	CALL	SPI_RX		;Fetch 512 Bytes to M(HL)
24DD  77                		LD	(HL),A
24DE  23                		INC	HL
24DF  0D                		DEC	C
24E0  20 F8             		JR NZ,	SD_RS_LP2
24E2  10 F6             		DJNZ	SD_RS_LP2

24E4  CD D926           		CALL	SPI_RX		;BURN 2 BYTES (CRC)
24E7  CD D926           		CALL	SPI_RX		;
24EA  CD 7826           		CALL	SD_DESELECT	;Deselect card
                        	;CALL	PRINTI	;debug
                        	;DB  " #3",EOS	;debug
24ED  AF                		XOR	A
24EE  C9                		RET



                        ;-----------------------------------------------------------------------------------------------------
                        ;Write the SD_RAM_BUFFER to the SD Card at Sector 'SEC_PTR'
                        ;-----------------------------------------------------------------------------------------------------
                        		;Sector in SEC_PTR, H=SD_RAM_BUFFER
24EF  AF                SD_WRITE_SEC	XOR	A
24F0  D3 C6             		OUT	(GREEN_LED),A
24F2  CD 6D25           		CALL	SET_PARAM
24F5  3E 18             		LD	A,24 	;Write Sector Command
24F7  CD 9026           		CALL	SD_CMD
24FA  3E 01             		LD	A,1 	;Error Code
24FC  C2 5225           		JP NZ,	SD_WR_FAIL

24FF  3E FE             		LD	A,0FEh	;DATA START BLOCK
2501  CD DB26           		CALL	SPI_TX
2504  01 0002           		LD	BC,0200h
2507  7E                SD_WR_LP	LD	A,(HL)
2508  23                		INC	HL
2509  CD DB26           		CALL	SPI_TX
250C  0D                		DEC	C
250D  C2 0725           		JP NZ,	SD_WR_LP
2510  10 F5             		DJNZ	SD_WR_LP

2512  3E FF             		LD	A,0FFh
2514  CD DB26           		CALL	SPI_TX
2517  00                		NOP
2518  3E FF             		LD	A,0FFh
251A  CD DB26           		CALL	SPI_TX

251D  CD D926           		CALL	SPI_RX
2520  E6 1F             		AND	1Fh
2522  FE 05             		CP	5
2524  3E 02             		LD	A,2 	;Error Code
2526  C2 5225           		JP NZ,	SD_WR_FAIL
2529  CD EF26           		CALL	WAIT_NOT_BUSY
252C  3E 03             		LD	A,3 	;Error Code
252E  DA 5225           		JP C,	SD_WR_FAIL
2531  CD 8825           		CALL	SD_CLEAR_ARG
2534  3E 0D             		LD	A,13		;SEND_STATUS
2536  CD 9026           		CALL	SD_CMD
2539  3E 04             		LD	A,4 	;Error Code
253B  C2 5225           		JP NZ,	SD_WR_FAIL
253E  CD D926           		CALL	SPI_RX
2541  B7                		OR	A
2542  3E 05             		LD	A,5 	;Error Code
2544  C2 5225           		JP NZ,	SD_WR_FAIL

2547  AF                		XOR	A		;A should be zero
2548  32 0FFF           		LD	(DIRTY_DATA), A

254B  CD 8B26           		CALL	SD_DELAY

254E  CD 7826           		CALL	SD_DESELECT	;Deselect card
2551  C9                		RET

2552  CD 7826           SD_WR_FAIL	CALL	SD_DESELECT	;Deselect card
2555  CD CA0D           		CALL	PRINTI
2558  0D0A2D57 72697465 		DB CR,LF,"-Write Failed:",EOS
2560  20466169 6C65643A
2568  00
2569  CD F60D           		CALL	PUT_BYTE
256C  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
                        ;Input:	Sector in 32 bit register BCDE
256D  3A 10FF           SET_PARAM	LD	A, (SD_CARD_TYPE)	;IF CARD_TYPE <> 3 THEN SHIFT SECTOR << 9 Bits
2570  FE 03             		CP	3
2572  CA 7E25           		JP Z,	SP_RET

2575  79                		LD	A,C
2576  EB                		EX	DE, HL	
2577  29                		ADD	HL,HL
2578  17                		RLA
2579  47                		LD	B,A
257A  4C                		LD	C,H
257B  55                		LD	D,L
257C  1E 00             		LD	E,0

257E  21 12FF           SP_RET		LD	HL,SD_PARAM
2581  CD 4427           		CALL	MOV_HL_32		;Save Parameter
2584  21 00FC           		LD	HL,SD_RAM_BUFFER	;Set buffer space
2587  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
2588  AF                SD_CLEAR_ARG	XOR	A
2589  32 12FF           		LD	(SD_PARAM),A
258C  32 13FF           		LD	(SD_PARAM+1),A
258F  32 14FF           		LD	(SD_PARAM+2),A
2592  32 15FF           		LD	(SD_PARAM+3),A
2595  C9                		RET


                        ;=====================================================================================================
                        ;SD Memory Car Routines, Low Level, INIT CARD, Send/Recieve Data, Send Commands
                        ;=====================================================================================================
                        ;-------------------------------- INIT SDCARD --------------------------------
2596  CD 7826           INIT_SDCARD	CALL	SD_DESELECT	;Deselect and clock the card many cycles
2599  06 80             		LD	B,080H
259B  3E FF             ISD_0		LD	A,0FFH
259D  32 10FF           		LD	(SD_CARD_TYPE),A
25A0  CD DB26           		CALL	SPI_TX		;CLOCK many cycles
25A3  10 F6             		DJNZ	ISD_0		;256 Clocks
25A5  CD 8326           		CALL	SD_SELECT

25A8  CD CA0D           		CALL 	PRINTI		;
25AB  0D0A496E 69742053 		DB	CR,LF,"Init SD",EOS
25B3  4400

25B5  CD 8825           		CALL	SD_CLEAR_ARG	;Fetch the 01 response
25B8  06 00             		LD	B,0		;256 retries
25BA  3E 00             ISD_LP1		LD	A,0		;CMD 0
25BC  CD 9026           		CALL	SD_CMD
                        		;CALL	PUT_BYTE
25BF  FE 01             		CP	1		;Test 01 response
25C1  28 13             		JR  Z,	ISD_1
25C3  10 F5             		DJNZ	ISD_LP1
                        		
25C5  CD CA0D           INIT_FAIL	CALL 	PRINTI		;
25C8  2D464149 4C454400 		DB	"-FAILED",EOS
25D0  CD 7826           		CALL	SD_DESELECT
25D3  AF                		XOR	A		;Return Zero Flag cleared = Failure
25D4  3D                		DEC	A
25D5  C9                		RET

25D6  CD CA0D           ISD_1		CALL 	PRINTI		;
25D9  20547970 652300   		DB	" Type#",EOS
25E0  21 AA01           		LD	HL,01AAh	;Deterimine Card Type
25E3  22 12FF           		LD	(SD_PARAM),HL
25E6  3E 08             		LD	A,8		;CMD 8
25E8  CD 9026           		CALL	SD_CMD
25EB  E6 04             		AND	4
25ED  28 08             		JR   Z,	ISD_2
25EF  3E 01             		LD	A,1		;If CMD8 is Illegal Cmd, CARD_TYPE=1
25F1  32 10FF           		LD	(SD_CARD_TYPE),A
25F4  C3 1126           		JP	ISD_3

25F7  CD D926           ISD_2		CALL	SPI_RX
25FA  CD D926           		CALL	SPI_RX
25FD  CD D926           		CALL	SPI_RX
2600  CD D926           		CALL	SPI_RX
2603  32 11FF           		LD	(SDC_STATUS),A
2606  FE AA             		CP	0AAh
2608  3E AA             		LD	A,0AAh		;Error code
260A  20 B9             		JR  NZ,	INIT_FAIL
260C  3E 02             		LD	A,2
260E  32 10FF           		LD	(SD_CARD_TYPE),A

2611  CD 090E           ISD_3		CALL	PUT_HEX
2614  CD CA0D           		CALL 	PRINTI		;
2617  2041434D 44343100 		DB	" ACMD41",EOS
261F  CD 8825           		CALL	SD_CLEAR_ARG

2622  06 00             		LD	B,0
2624  3E 37             ISD_LP2		LD	A,55		;CMD 55 (ACMD)
2626  CD 9026           		CALL	SD_CMD
2629  3E 29             		LD	A,41		;CMD 41
262B  CD 9026           		CALL	SD_CMD
262E  FE 00             		CP	0
2630  28 08             		JR Z,	ISD_4
2632  AF                		XOR	A		;256 ~= 2mSec Delay
2633  CD 8B26           		CALL	SD_DELAY
2636  10 EC             		DJNZ	ISD_LP2
2638  18 8B             		JR	INIT_FAIL

263A  CD CA0D           ISD_4		CALL 	PRINTI		;
263D  2B00              		DB	"+",EOS
263F  3A 10FF           		LD	A,(SD_CARD_TYPE)
2642  FE 02             		CP	2
2644  20 2D             		JR  NZ,	ISD_6
2646  3E 3A             		LD	A,58		;CMD 58
2648  CD 9026           		CALL	SD_CMD
264B  FE 00             		CP	0
264D  C2 C525           		JP  NZ,	INIT_FAIL
2650  CD D926           		CALL	SPI_RX
2653  E6 C0             		AND	0C0h
2655  FE C0             		CP	0C0h
2657  C2 6A26           		JP NZ,	ISD_5
265A  3E 03             		LD	A,3
265C  32 10FF           		LD	(SD_CARD_TYPE),A
265F  CD CA0D           		CALL 	PRINTI		;
2662  20547970 65233300 		DB	" Type#3",EOS
266A  CD D926           ISD_5		CALL	SPI_RX
266D  CD D926           		CALL	SPI_RX
2670  CD D926           		CALL	SPI_RX

2673  CD 7826           ISD_6		CALL	SD_DESELECT
2676  AF                		XOR	A		;Set Zero Flag = Success
2677  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
2678  F5                SD_DESELECT	PUSH	AF
2679  3E 01             		LD	A,1
267B  D3 C4             		OUT	(SDCS),A
267D  D3 C0             		OUT	(SDCLK),A
267F  D3 C6             		OUT	(GREEN_LED),A
2681  F1                		POP	AF
2682  C9                		RET
                        		
                        ;-----------------------------------------------------------------------------------------------------
2683  F5                SD_SELECT	PUSH	AF
2684  AF                		XOR	A
2685  D3 C4             		OUT	(SDCS),A
2687  F1                		POP	AF
2688  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
2689  3E 0D             SD_DELAY100	LD	A,13	 ;Small delay after selecting card
268B  3D                SD_DELAY	DEC	A	 ;5
268C  C2 8B26           		JP NZ,	SD_DELAY ;10    15*13 ~= 200 ~= 100uSec
268F  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
                        ;Send command to SD card
2690  C5                SD_CMD		PUSH	BC
2691  CD 8326           		CALL	SD_SELECT
2694  CD EF26           		CALL	WAIT_NOT_BUSY

2697  06 FF             		LD	B,0FFh	;Default CRC
2699  FE 00             		CP	0
269B  C2 A026           		JP NZ,	SDC_1
269E  06 95             		LD	B,095h	;If CMD=0 THEN CRC=95
26A0  FE 08             SDC_1		CP	8
26A2  C2 A726           		JP NZ,	SDC_2
26A5  06 87             		LD	B,087h
26A7                    SDC_2

26A7  F6 40             		OR	040H	;All Commands start with 40h
26A9  CD DB26           		CALL	SPI_TX
26AC  3A 15FF           		LD	A,(SD_PARAM+3)
26AF  CD DB26           		CALL	SPI_TX
26B2  3A 14FF           		LD	A,(SD_PARAM+2)
26B5  CD DB26           		CALL	SPI_TX
26B8  3A 13FF           		LD	A,(SD_PARAM+1)
26BB  CD DB26           		CALL	SPI_TX
26BE  3A 12FF           		LD	A,(SD_PARAM)
26C1  CD DB26           		CALL	SPI_TX
26C4  78                		LD	A,B
26C5  CD DB26           		CALL	SPI_TX

26C8  06 00             		LD	B,0
26CA  CD D926           SDC_LP		CALL	SPI_RX	;Read Respsonse?
26CD  32 11FF           		LD	(SDC_STATUS),A
26D0  B7                		OR	A
26D1  F2 D726           		JP P,	SDC_RET	;If Positive Response, EXIT
26D4  10 F4             		DJNZ	SDC_LP	;Else Read next Response
26D6  B7                		OR	A
26D7  C1                SDC_RET		POP	BC
26D8  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
                        ;------------------------------- Receive a byte from SPI
26D9  3E FF             SPI_RX		LD	A,0FFH	;Read Respsonse, send a byte to get a byte...

26DB  C5                SPI_TX		PUSH	BC
26DC  4F                		LD	C,A	;Save Byte to send in C
26DD  06 08             		LD	B,8	;8 BITS
                        		
26DF  DB CE             SPI_TX_LP	IN	A,(ACE_MSR)	;Fetch RX bit
26E1  17                		RLA			;Save bit in CY
26E2  CB11              		RL	C		;Move bit into C (and bump next tx bit up)
26E4  17                		RLA			;Get bit to send in lsb
26E5  D3 C5             		OUT	(SDTX),A	;Send bit
26E7  DB C0             		IN	A,(SDCLK)	;Clock the bit
26E9  10 F4             		DJNZ	SPI_TX_LP		
26EB  79                		LD	A,C
26EC  2F                		CPL			;Correct Inversion by ACE
26ED  C1                		POP	BC
26EE  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
                        ;------------------------------- Wait until FF's come back from Card (ie NOT BUSY)
26EF  F5                WAIT_NOT_BUSY	PUSH	AF	;Do not destroy Acc
26F0  C5                		PUSH	BC	;Fetch 1 consecutive FF's to be sure SD card NOT BUSY
26F1  06 00             		LD	B,0
26F3  0E 01             WNB_LP		LD	C,1	;Set count for 1 trys
26F5  CD D926           WNB_LP2		CALL	SPI_RX
26F8  3C                		INC	A
26F9  C2 0527           		JP NZ,	WNB_0	;NOT FF RETURNED, JUMP TO COUNT DOWN TRYS
26FC  0D                		DEC	C	;Count Down Consecutive FF's
26FD  C2 F526           		JP NZ,	WNB_LP2
2700  C1                		POP	BC
2701  F1                		POP	AF
2702  37                		SCF		;Return NOT BUSY (Clear Carry)
2703  3F                		CCF
2704  C9                		RET

2705  AF                WNB_0		XOR	A
2706  CD 8B26           		CALL	SD_DELAY
2709  10 E8             		DJNZ	WNB_LP	;Count Down Trys
270B  C1                		POP	BC
270C  F1                		POP	AF
270D  37                		SCF		;Return STILL BUSY (Set Carry)
270E  C9                		RET



                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_16	General Support Routines, 32 Bit stuff and other math
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;

                        ;-----------------------------------------------------------------------------------------------------
                        ;Maximum number to divide is Logical Sector 2001/4 = 500
                        ;If dividing by powers of 2, then we can shift the number for fast divide
270F  3A 21FF           DIV16BY8SPC	LD	A, (SEC_PER_CLUS)
                        ;Input:	DE=Dividend, A=Divisor
                        ;Out:	DE=Result, A=Remainder
2712  EB                DIV16BY8	EX	DE, HL	; HL = Dividend
2713  1E 00             		LD	E,00	; Quotient = 0
2715  4F                		LD	C, A	; Store        Divisor
2716  06 08             		LD	B, 08	; Count = 8
2718  29                DIV16BY8_LP	ADD	HL,HL	; Dividend = Dividend x 2
2719  CB03              		RLC	E	; Quotient = Quotient x 2
271B  7C                		LD	A, H
271C  91                		SUB	C	; Is most significant byte of Dividend > divisor
271D  38 02             		JR C,	DIV16BY8_SK	; No, go to Next step
271F  67                		LD	H, A	; Yes, subtract divisor
2720  1C                		INC	E	; and Quotient = Quotient + 1
2721  10 F5             DIV16BY8_SK	DJNZ 	DIV16BY8_LP ; Count = Count - 1
2723  7C                		LD	A, H
2724  16 00             		LD	D,0	; Quotient in DE
2726  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
2727  3A 54FF           DIVBYSHIFT	LD	A, (DF_SHIFTCNT)	; DE = Dividend
272A  47                		LD	B,A
272B  05                DBS_LP		DEC	B
272C  C8                		RET Z
272D  CB3A              		SRL	D
272F  CB1B              		RR	E
2731  C3 2B27           		JP	DBS_LP

                        ;-----------------------------------------------------------------------------------------------------
2734  3A 58FF           MODBYMASK	LD	A, (MODMASK)
2737  A3                		AND	E
2738  C9                		RET

                        ;------------------------- Move (HL) to 32 bit register BCDE
2739  5E                MOV_32_HL	LD	E,(HL)
273A  23                		INC	HL
273B  56                		LD	D,(HL)
273C  23                		INC	HL
273D  4E                		LD	C,(HL)
273E  23                		INC	HL
273F  46                		LD	B,(HL)
2740  2B                		DEC	HL
2741  2B                		DEC	HL
2742  2B                		DEC	HL
2743  C9                		RET

                        ;------------------------- Move 32 bit register BCDE to (HL)
2744  73                MOV_HL_32	LD	(HL),E
2745  23                		INC	HL
2746  72                		LD	(HL),D
2747  23                		INC	HL
2748  71                		LD	(HL),C
2749  23                		INC	HL
274A  70                		LD	(HL),B
274B  2B                		DEC	HL
274C  2B                		DEC	HL
274D  2B                		DEC	HL
274E  C9                		RET

                        ;------------------------- ADD (HL) to 32 bit register BCDE - (Must return with HL changed to last byte)
274F  7B                ADD_32_HL	LD	A,E
2750  86                		ADD	A,(HL)
2751  5F                		LD	E,A
2752  23                		INC	HL
2753  7A                		LD	A,D
2754  8E                		ADC	A,(HL)
2755  57                		LD	D,A
2756  23                		INC	HL
2757  79                		LD	A,C
2758  8E                		ADC	A,(HL)
2759  4F                		LD	C,A
275A  23                		INC	HL		
275B  78                		LD	A,B
275C  8E                		ADC	A,(HL)
275D  47                		LD	B,A
275E  23                		INC	HL		;(Must return with HL advanced past 32 bits)
275F  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
2760  13                INC_32		INC	DE
2761  7A                		LD	A,D
2762  B3                		OR	E
2763  C0                		RET NZ
2764  03                		INC	BC
2765  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
2766  7A                DEC_32		LD	A,D
2767  B3                		OR	E
2768  C2 6C27           		JP NZ,	DEC_32NB
276B  0B                		DEC	BC
276C  1B                DEC_32NB	DEC	DE
276D  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
276E  7A                TSTZ_32		LD	A,D
276F  B3                		OR	E
2770  B1                		OR	C
2771  B0                		OR	B
2772  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
                        ;Compare BCDE with 32bit word at HL
2773  23                CMP_HL_32	INC	HL		;Point to MSB
2774  23                		INC	HL
2775  23                		INC	HL
2776  78                		LD	A,B		;Compare with B
2777  BE                		CP	(HL)
2778  20 0E             		JR NZ,	CH3_R1
277A  2B                		DEC	HL
277B  79                		LD	A,C
277C  BE                		CP	(HL)
277D  20 0A             		JR NZ,	CH3_R2
277F  2B                		DEC	HL
2780  7A                		LD	A,D
2781  BE                		CP	(HL)
2782  20 06             		JR NZ,	CH3_R3
2784  2B                		DEC	HL
2785  7B                		LD	A,E
2786  BE                		CP	(HL)
2787  C9                		RET
2788  2B                CH3_R1		DEC	HL
2789  2B                CH3_R2		DEC	HL
278A  2B                CH3_R3		DEC	HL
278B  C9                		RET

                        ;------------------------- COMPARE DE WITH HL
278C  7A                CMP_DE_HL	LD	A,D		;Compare the MSB first
278D  BC                		CP	H
278E  C0                		RET NZ
278F  7B                		LD	A,E
2790  BD                		CP	L
2791  C9                		RET



                        ;=====================================================================================================
                        ;General Support Routines, Strings
                        ;=====================================================================================================
                        ;	OUTPUT: STRING ENTERED @M(HL), C=0
                        ;		<ESC> PRESSED C=1
                        ;-----------------------------------------------------------------------------------------------------
2792  CD DC13           GET_STRING:	CALL	GET_CHAR
2795  FE 1B             		CP	27
2797  37                		SCF			;Set Carry to indicate Abort
2798  C8                		RET Z
2799  FE 0D             		CP	13		;Exit on <CR>
279B  C8                		RET Z
279C  B9                		CP	C		;Exit on Selectable Char (dot for file input)
279D  C8                		RET Z
279E  CD AD27           		CALL	TO_UPPER
27A1  FE 21             		CP	' '+1		;Test if ACC is Control or Space
27A3  38 ED             		JR C,	GET_STRING	;Skip such characters
27A5  05                		DEC	B
27A6  04                		INC	B		;Exit if B characters are already inputed
27A7  C8                		RET Z			;Exit if no more characters allowed
27A8  77                		LD	(HL),A
27A9  23                		INC	HL
27AA  05                		DEC	B
27AB  18 E5             		JR	GET_STRING

                        ;-----------------------------------------------------------------------------------------------------
27AD  FE 61             TO_UPPER	CP	'a'
27AF  D8                		RET C		;Return if ACC < 'a'
27B0  FE 7B             		CP	'z'+1
27B2  D0                		RET NC		;Return if ACC > 'z'
27B3  E6 5F             		AND	5Fh	;Convert to upper case
27B5  C9                		RET

                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
27B6  FE 41             IS_LETTER	CP	'A'
27B8  D8                		RET C
27B9  FE 5B             		CP	'Z'+1
27BB  3F                		CCF
27BC  C9                		RET

                        ;-----------------------------------------------------------------------------------------------------
                        ;ASCII TO BINARY
                        ;INPUT:	HL Points to a 2 character String of ASCII
                        ;	DE Points to a memory location to receive the Binary value
                        ;OUTPUT: CY=0 if successful (both ASCII characters were a valid HEX digit (0-9,A-F,a-f)
                        ;	 (DE) = Binary value of (HL) and (HL+1)
                        ;	eg:
                        ;	Before Call: HL=1000, DE=2000, M(1000)='A', M(1001)='B', M(2000)=xx, CY=?
                        ;	After  Call: HL=1002, DE=2000, M(1000)='A', M(1001)='B', M(2000)=AB, CY=0
                        ;	
                        ;	CY=1 if invalid hex char encountered, a partial output may appear at (DE)
                        ;	eg:
                        ;	Before Call: HL=1000, DE=2000, M(1000)='J', M(1001)='B', M(2000)=12, CY=?
                        ;	After  Call: HL=1000, DE=2000, M(1000)='J', M(1001)='B', M(2000)=12, CY=1
                        ;	eg:
                        ;	Before Call: HL=1000, DE=2000, M(1000)='A', M(1001)='J', M(2000)=12, CY=?
                        ;	After  Call: HL=1001, DE=2000, M(1000)='A', M(1001)='J', M(2000)=2A, CY=1
                        ;
                        ;DESTROYS: AF
                        ;
27BD  CD C127           ASC2BIN		CALL	ABF1		;Convert 2 chars to HEX @(DE)
27C0  D8                		RET	C		;Exit on error CY=1
27C1  7E                ABF1		LD	A,(HL)
27C2  CD 980D           		CALL	ASC2HEX	;(non-hex) char when CY=1
27C5  D8                		RET	C
27C6  EB                ABF_GOODHEX	EX	DE,HL
27C7  ED6F              		RLD
27C9  EB                		EX	DE,HL
27CA  23                		INC	HL
27CB  C9                		RET		

27CC  32 B2FF           BEEP		LD	(BEEP_TO),A
27CF  C9                		RET

27D0  32 F2FF           SET_ECHO	LD	(ECHO_STATE),A	;TURN ON/OFF ECHO
27D3  C9                		RET

27D4  32 C0FF           LED_UPDATE	LD	(IK_TIMER),A	;0 = Cancel any monitor time outs
27D7  21 3818           		LD	HL,ISET_PRESSED
27DA  22 BEFF           		LD	(KEY_EVENT),HL
27DD  21 DF17           		LD	HL,IDISP_RET
27E0  22 BCFF           		LD	(DISPMODE),HL
27E3  C9                		RET

27E4  3A C8FF           LED_GET_POS	LD	A,(LED_CURSOR)
27E7  E6 07             		AND	7
27E9  C9                		RET
                        		
27EA  E6 07             LED_SET_POS	AND	7
27EC  F6 E0             		OR	LOW LED_DISPLAY
27EE  32 C8FF           		LD	(LED_CURSOR),A
27F1  C9                		RET
                        		
27F2  E5                LED_RIGHT	PUSH	HL
27F3  C5                		PUSH	BC
27F4  21 E0FF           		LD	HL,LED_DISPLAY
27F7  22 C8FF           		LD	(LED_CURSOR),HL
27FA  06 07             		LD	B,7
27FC  3E 80             		LD	A,0x80				
27FE  4E                LEDR_LP		LD	C,(HL)
27FF  77                		LD	(HL),A
2800  79                		LD	A,C
2801  23                		INC	HL
2802  10 FA             		DJNZ	LEDR_LP
2804  C1                		POP	BC
2805  E1                		POP	HL				
2806  C9                		RET

2807  E5                LED_LEFT	PUSH	HL
2808  C5                		PUSH	BC
2809  21 E6FF           		LD	HL,LED_DISPLAY+6
280C  22 C8FF           		LD	(LED_CURSOR),HL
280F  06 07             		LD	B,7
2811  3E 80             		LD	A,0x80				
2813  4E                LEDL_LP		LD	C,(HL)
2814  77                		LD	(HL),A
2815  79                		LD	A,C
2816  2B                		DEC	HL
2817  10 E5             		DJNZ	LEDR_LP
2819  C1                		POP	BC
281A  E1                		POP	HL
281B  C9                		RET


                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Chapter_17	High RAM routines
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;These routines cause bank memory switches between RAM/ROM and must be in HIGH RAM to execute.
                        ;They will be loaded into HIGH RAM

281C  21 2828           LOAD_HIGH_RAM	LD	HL,ROM_CODE	;Copy ISR Dispatch & Return to Upper RAM
281F  11 2AFB           		LD	DE,HRAM_CODE
2822  01 2900           		LD	BC,ROM_CODE_LEN
2825  EDB0              		LDIR
2827  C9                		RET

                        ;FOLLOWING IS THE ISR DISPATCH ROUTINE  ISR_DISPATCH (IN HIGH RAM)
                        ;
                        ;ISR_DISPATCH:
2828  AF                ROM_CODE	XOR	A		;4
2829  D3 C1             		OUT	(RAMROM),A	;11 SELECT ROM
282B  DB 40             		IN	A,(Port40)	;11	
282D  07                		RLCA			;4
282E  D2 3716           		JP NC,	ISR_RXD		;10	Jump ASAP if RS-232 start bit coming in (2 Stack Words)
2831  07                		RLCA			;4
2832  DA A816           		JP C,	ISR_TIMER	;10 (st=50) Jump if Timer interrupt   		(7 Stack Words)
2835  3E 80             		LD	A,0x80		;	Otherwise, unknown interrupt (RS-232 noise?)
2837  D3 40             		OUT	(Port40),A	;11	Just reset Timer interrupt, just incase?
                        		;JP	ISR_RET

      = 0011            ISR_RET_OFF	EQU	$-ROM_CODE
2839  3A D9FF           		LD	A,(RRSTATE)	;Restore RAM/ROM selection
283C  D3 C1             		OUT	(RAMROM),A
283E  08                		EX	AF,AF'		;Restore swapped Registers
283F  D9                		EXX
2840  FB                		EI
2841  ED4D              		RETI			;Return to Mainline code
                        		
      = 001B            GET_MEM_OFF	EQU	$-ROM_CODE
2843  3A DBFF           		LD	A,(READ_RAMROM)	;Bit 0 is RAM/ROM
2846  F3                		DI
2847  D3 C1             		OUT	(RAMROM),A	;Select RAM/ROM
2849  7E                		LD	A,(HL)		;Fetch from RAM/ROM
284A  08                		EX	AF,AF'
284B  AF                		XOR	A		;Return to ROM
284C  D3 C1             		OUT	(RAMROM),A
284E  08                		EX	AF,AF'
284F  FB                		EI		
2850  C9                		RET
                        		
                        ;Alternative way to Get Mem and minimize the Interrupt mask black out
                        ;HR_GET_MEM	PUSH	BC
                        ;		LD	B,0
                        ;		LD	C,RAMROM
                        ;		LD	A,(READ_RAMROM)
                        ;		DI
                        ;		OUT	(C),A
                        ;		LD	A,(HL)		;Fetch from RAM/ROM
                        ;		OUT	(C),B
                        ;		EI
                        ;		POP	BC
                        ;		RET
                        		
                        		
      = 0029            ROM_CODE_LEN	equ	$-ROM_CODE


                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Appendix_A	LED FONT
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;


                        ; **         *********  *******        *********    *****    **     **  *********
                        ; **         *********  ********       *********   *******   ***    **  *********
                        ; **         **         **    ***      **         ***   ***  ****   **     ***
                        ; **         **         **     **      **         **     **  *****  **     ***
                        ; **         *********  **     **      *********  **     **  ** *** **     ***
                        ; **         *********  **     **      *********  **     **  **  *****     ***
                        ; **         **         **     **      **         **     **  **   ****     ***
                        ; **         **         **    ***      **         ***   ***  **    ***     ***
                        ; *********  *********  ********       **          *******   **     **     ***
                        ; *********  *********  *******        **           *****    **     **     ***

                        ;	0 = Segment D OR LED7       --4--
                        ;	1 = Segment E OR LED6      2|   |3
                        ;	2 = Segment F OR LED5       |   |
                        ;	3 = Segment B OR LED4       --5--
                        ;	4 = Segment A OR LED3      1|   |6
                        ;	5 = Segment G OR LED2       |   |
                        ;	6 = Segment C OR LED1       --0--


2900                    		ORG  ($ & 0xFF00) + 0x100
2900  DFC8BBF9 ECF5F7D8 LED_HEX	DB	%11011111, %11001000, %10111011, %11111001, %11101100, %11110101, %11110111, %11011000	;00-07 01234567
2908  FFFCFEE7 97EBB7B6 	DB	%11111111, %11111100, %11111110, %11100111, %10010111, %11101011, %10110111, %10110110	;08-0F 89ABCDEF


2920                    		ORG  ($ & 0xFF00) + 0x20
                        ;	**** 	; CGABFED,   CGABFED,   CGABFED,   CGABFED,   CGABFED,   CGABFED,   CGABFED,   CGABFED	;HEX	Character
2920  80868CBC D5A8A984 LED_FONT DB	%10000000, %10000110, %10001100, %10111100, %11010101, %10101000, %10101001, %10000100 	;20-27  !"#$%&'
2928  97D994A6 C1A081AA 	DB	%10010111, %11011001, %10010100, %10100110, %11000001, %10100000, %10000001, %10101010	;28-2F ()*+,-./
2930  DFC8BBF9 ECF5F7D8 	DB	%11011111, %11001000, %10111011, %11111001, %11101100, %11110101, %11110111, %11011000	;30-37 01234567
2938  FFFC91D1 83A1C1BA 	DB	%11111111, %11111100, %10010001, %11010001, %10000011, %10100001, %11000001, %10111010	;38-3F 89:;<=>?
2940  FBFEE797 EBB7B6D7 	DB	%11111011, %11111110, %11100111, %10010111, %11101011, %10110111, %10110110, %11010111	;40-47 @ABCDEFG
2948  EEC8CBAE 87EADEDF 	DB	%11101110, %11001000, %11001011, %10101110, %10000111, %11101010, %11011110, %11011111	;48-4F HIJKLMNO
2950  BEFCA2F5 96CFCFCF 	DB	%10111110, %11111100, %10100010, %11110101, %10010110, %11001111, %11001111, %11001111	;50-57 PQRSTUVW
2958  E0ED9B97 E4D99C81 	DB	%11100000, %11101101, %10011011, %10010111, %11100100, %11011001, %10011100, %10000001	;58-5F XYZ[\]^_
2960  88FBE7A3 EBBFB6FD 	DB	%10001000, %11111011, %11100111, %10100011, %11101011, %10111111, %10110110, %11111101	;60-67 `abcdefg
2968  E6C0CBAE 86EAE2E3 	DB	%11100110, %11000000, %11001011, %10101110, %10000110, %11101010, %11100010, %11100011	;68-6F hijklmno
2970  BEFCA2F5 A7C3C3C3 	DB	%10111110, %11111100, %10100010, %11110101, %10100111, %11000011, %11000011, %11000011	;70-77 pqrstuvw
2978  E0ED9B97 86D990EB 	DB	%11100000, %11101101, %10011011, %10010111, %10000110, %11011001, %10010000, %11101011	;78-7F xyz{|}~





2A00                    		ORG  ($ & 0xFF00) + 0x100
2A00                    GO_BASIC
2A00                    	INCLUDE	BASICZ80.ASM
                        ;	TITLE	MICRO BASIC
                        ;*************************************************************
                        ;                       MICRO-BASIC                          *
                        ;------------------------------------------------------------*
                        ;   A SMALL INTEGER BASIC INTERPRETER FOR THE 8080/8085/Z80  *
                        ;                                D.F. DUNFIELD  JAN 25/1983  *
                        ;------------------------------------------------------------*
                        ;Translated to Z80 code for use with Lee Hart's Z80
                        ;Membership Card.  April 1, 2017 by Josh Bensadon.
                        ;
                        ;------------------------------------------------------------*
                        ;                      BASIC COMMANDS                        *
                        ;                                                            *
                        ;  CLEAR,    DATA,     DIM,      END,      BEXIT,     FOR,    *
                        ;  GOSUB,    GOSUB(N), GOTO,     GOTO(N),  IF/THEN,  INPUT,  *
                        ;  LET,      LIF/THEN, LIST,     LOAD,     NEW,      NEXT,   *
                        ;  ORDER,    PLOT,     PRINT,    READ,     REM,      RETURN, *
                        ;  RUN,      SAVE,     SIZE,     STOP,     USR,      <EDIT>  *
                        ;------------------------------------------------------------*
                        ;                     BASIC OPERATORS                        *
                        ;                                                            *
                        ; NUMERIC:     + - * % / \ & | ; ( ) < = > == -= <= >=       *
                        ; CHARACTER:   + = == -=                                     *
                        ; OTHER:       : # $ @ ? [ ] ( )                             *
                        ;------------------------------------------------------------*
                        ;                      BASIC VARIABLES                       *
                        ;                                                            *
                        ;     A - Z ......... 16 BIT SIMPLE INTEGER VARIABLES.       *
                        ;     A$ - Z$ ....... SIMPLE CHARACTER VARIABLES. < 36 CHARS *
                        ;     A[N] - Z[N] ... 16 BIT INTEGER ARRAYS.                 *
                        ;     @[N] .......... PSEUDO MEMORY REFERENCE ARRAY.         *
                        ;     @[N]$ ......... NUMERIC TO CHARACTER CONVERSION.(CHR$) *
                        ;     ? ............. PSEUDO RANDOM NUMBER GENERATOR.        *
                        ;------------------------------------------------------------*
                        ;                        MEMORY MAP                          *
                        ;                                                            *
                        ;    0000-03FF     1K SYSTEM MONITOR (IN ROM).               *
                        ;    0400-0FFF     3K BASIC INTERPRETER (IN ROM).            *
                        ;    1000-13FF     1K MEMORY MAPPED 64*16 VIDEO DISPLAY      *
                        ;    1400-15FF     0.5K POINTERS, STACKS, BUFFERS.           *
                        ;    1600-19FF     1K VARIABLES AND POINTERS.                *
                        ;    1A00-FFFF     PROGRAM AND ARRAY STORAGE.                *
                        ;*************************************************************
                        ;	PAGE
                        ;
                        ;*************************************************************
                        ;                   CONSTANTS AND EQUATES
                        ;*************************************************************
                        ;
                        ; MONITOR ROUTINES
                        ;
      = 0051            BINCHR	EQU	0x51		;INPUT ROUTINE ADDRESS
      = 0045            BPUTCHR EQU	0x45		;OUTPUT ROUTINE ADDRESS
                        ;CTRLC	EQU	0x27E		;CONTROL-C TEST ROUTINE ADDRESS
      = 0042            BEXIT	EQU	0x42		;TERMINATION RETURN ADDRESS
                        ;GETR	EQU	0x2EB		;ROUTINE TO LOAD INTEL HEX FORMAT
                        ;TDUMP	EQU	0xD6		;ROUTINE TO DUMP IN INTEL HEX FORMAT
                        ;TON	EQU	0x396		;ROUTINE TO START TAPE
                        ;TOFF	EQU	0x3A6		;ROUTINE TO STOP TAPE
                        ;CURPOS	EQU	0x37E		;ROUTINE TO POSITION CURSOR
      = 007D            BPUTSP	EQU	0x7D		;DISPLAY SPACE ON CONSOLE
      = 0080            BPUTNL	EQU	0x80		;ROUTINE TO PRINT A <LF>, <CR> ON TERMINAL
      = 0057            PRINTM	EQU	0x57		;DISPLAY'S MSGM UP TO ZERO OR <CR>
                        ;CR	EQU	0x0D
                        ;LF	EQU	0x0A


                        ; MEMORY ALLOCATION
      = 8000            BUFF	EQU	0x8000		;START OF RAM, INPUT BUFFER
      = 80FF            IOCON	EQU	BUFF+0xFF	;INPUT/OUTPUT CONFIGURATION
      = 80FD            USROUT	EQU	IOCON-2		;USER SUPPLIED OUTPUT DEVICE VECTOR
      = 80FB            CURSOR	EQU	USROUT-2	;CURSOR POSITION
      = 80F9            LSTCHR	EQU	CURSOR-2	;CHARACTER UNDER CURSOR
      = 80F7            STACK	EQU	LSTCHR-2	;MACHINE STACK
      = 8032            TB	EQU	BUFF+50		;TEMPORARY TEXT BUFFER
      = 8064            XBF	EQU	TB+50		;EXTRA TEXT BUFFER
      = 8100            EDBUF	EQU	BUFF+256	;EDIT BUFFER
      = 81FA            CS	EQU	EDBUF+0xFA	;CONTROL STACK SPACE
      = 81FB            CSP	EQU	CS+1		;CONTROL STACK POINTER
      = 81FD            ARYLOC	EQU	CSP+2		;LOCATION OF ARRAYS
      = 81FE            SEED	EQU	ARYLOC+1	;RANDOM NUMBER SEED
      = 8200            VARS	EQU	SEED+2		;VARIABLE SPACE
      = 8234            RFLAG	EQU	VARS+52		;PROGRAM RUNNING FLAG
      = 8235            IFLAG	EQU	RFLAG+1		;INPUTTING FLAG
      = 8236            P	EQU	IFLAG+1		;POINTER TO END OF EXPRESSION
      = 8237            EFLAG	EQU	P+1		;ASSIGNMENT FLAG
      = 8238            DATA	EQU	EFLAG+1		;READ/DATA POINTER
      = 823A            LAST	EQU	DATA+2		;LAST FREE ARRAY SPACE
      = 823C            SIGT	EQU	LAST+2		;SIGNATURE TO PREVENT CLEARING OF PROGRAM
      = 823E            TEMP	EQU	SIGT+2		;TEMPORARY STORAGE
      = 8600            TEXT	EQU	VARS+1024	;PROGRAM AND ARRAY STORAGE
      = 007F            DELETE	EQU	0x7F		;DELETE CHARACTER

                        ;	PAGE
                        ;
                        ;*******************************************************************
                        ; START OF MAIN PROGRAM, FIRST INITIALIZE, INSURING WE DON'T THINK *
                        ; WE HAVE A VALID PROGRAM, ALSO CLEAR OUT HIS VARIABLES AND ARRAYS *
                        ;*******************************************************************
                        ;

                        ;	ORG	0x8000		;FOLLOW MONITOR
2A00  21 0036           BASIC	LD	HL,INTRO	;ADDRESS OF 'INTRO' MESSAGE
2A03  CD 5700           	CALL	PRINTM		;TELL HIM WHO WROTE THIS!
2A06  2A 3C82           	LD	HL,(SIGT)	;CHECK IF RAM IS SIGNED
2A09  11 6913           	LD	DE,0x1369
2A0C  AF                	XOR	A
2A0D  ED52              	SBC	HL,DE
2A0F  28 0C             	JR Z,	INIT		;JUMP IF SIGNATURE, IE DON'T INIT TEXT SPACE
                        	
2A11  ED53 3C82         	LD	(SIGT),DE	;SIGN RAM FOR NEXT TIME

2A15  3E FF             NEW	LD	A,0xFF		;INDICATES END OF PROGRAM
2A17  32 0086           	LD	(TEXT), A	;INITIALIZE TO NO PROGRAM
2A1A  CD AF2C           RESV	CALL	CLEAR		;CLEAR OUT HIS VARIABLES

                        ; RESET FLAGS, AND PROMPT WITH 'READY', SO HE WILL KNOW WE ARE LISTENING
2A1D  21 0000           INIT	LD	HL,0		;GET DOUBLE BYTE ZERO
2A20  22 3482           	LD	(RFLAG), HL	;INDICATE NOT RUNNING, AND NOT INPUT
2A23  22 3682           	LD	(P), HL		;INDICATE NO ASSIGNMENT DONE
2A26  21 3036           	LD	HL,RDY		;ADDRESS OF 'READY' MESSAGE
2A29  CD 5700           	CALL	PRINTM		;TELL HIM WE ARE READY

                        ; GET A LINE FROM CONSOLE, AND SEE WHAT HE WANTS
2A2C  31 F780           TOP	LD	SP,STACK	;FIX UP STACK IN CASE WE ABORTED SOMETHING
                        	
2A2F  21 80FF           	LD	HL,RC_TYPE	;Check Auto Boot
2A32  CB7E              	BIT	7,(HL)
2A34  CBBE              	RES	7,(HL)
2A36  C2 EC2C           	JP  NZ,	RUN
                        	
2A39  CD D02A           	CALL	GLINE		;LET HIM GIVE US A LINE
2A3C  FE 0D             	CP	CR		;DID HE ONLY PRESS RETURN
2A3E  CA 2C2A           	JP Z,	TOP		;NOT GOOD ENOUGH, MAKE HIM TRY AGAIN
2A41  CD C62A           	CALL	NUM		;DID HIS LINE START WITH A NUMBER
2A44  D2 AF2B           	JP NC,	EDIT		;IF SO, HE IS WRITING A PROGRAM!!!

                        ; LOOK UP COMMAND AND EXECUTE
2A47  01 1D2A           	LD	BC,INIT		;ADDRESS TO RETURN TO
2A4A  C5                	PUSH	BC		;SAVE SO WE CAN RETURN
2A4B  21 2135           	LD	HL,KTAB-1	;POINT TO COMMAND TABLE
                        ;
                        ; LOCATES COMMAND POINTED TO BY D-E IN THE COMMAND TABLE POINTED TO BY H-L
                        ; AND CHAINS TO THE COMMAND PROCESSING CODE FOR THAT COMMAND
                        ;
2A4E  CD 0431           CMD	CALL	PARSE1		;ADVANCE TO NEXT CHARACTER
2A51  D5                TLP0	PUSH	DE		;SAVE POINTER TO START OF COMMAND
2A52  23                CMDL	INC	HL		;ADVANCE IN TABLE
2A53  1A                	LD	A, (DE)		;GET DATA FROM COMMAND
2A54  BE                	CP	(HL)		;COMPARE WITH TABLE CONTENTS
2A55  13                	INC	DE		;ADVANCE IN COMMAND
2A56  CA 522A           	JP Z,	CMDL		;IF SAME, KEEP TESTING

                        ; DIDN'T MATCH, SEE IF IT'S END OF WORD (HIGH BIT SET)
2A59  F6 80             	OR	0x80		;ARE WE AT END?
2A5B  BE                	CP	(HL)		;AND IS IT THIS ONE?
2A5C  CA 6F2A           	JP Z,	GOTCMD		;IF SO, WE HAVE IT

                        ; WASN'T THAT ENTRY, KEEP LOOKING
2A5F  97                	SUB	A		;SEE IT THIS IS END OF TABLE
2A60  BE                	CP	(HL)		;ARE WE AT END?
2A61  CA 6E2A           	JP Z,	GOTDEF		;IF SO, WE WILL SAY WE FOUND
2A64  D1                	POP	DE		;RESTORE POINTER TO COMMAND
2A65  B6                CMD1	OR	(HL)		;TEST FOR AT END OF TABLE ENTRY
2A66  23                	INC	HL		;POINT TO NEXT
2A67  F2 652A           	JP P,	CMD1		;IF NO, KEEP LOOKING
2A6A  23                	INC	HL		;SKIP FIRST ADDRESS BYTE
2A6B  C3 512A           	JP	TLP0		;TEST THIS ENTRY

                        ; WE HIT THE END OF THE TABLE, ASSUME THE DEFAULT ADDRESS (LET)
2A6E  1B                GOTDEF	DEC	DE		;BACKUP TO START OF WORD

                        ; WE MATCHED ALL THE WAY TO THE END OF A COMMAND WORD, GET IT'S ADDRESS
2A6F  23                GOTCMD	INC	HL		;POINT TO ADDRESS BYTE
2A70  4E                	LD	C,(HL)		;SAVE TEMPORARY
2A71  23                	INC	HL		;POINT TO NEXT ADDRESS BYTE
2A72  66                	LD	H,(HL)		;GET LOW ADDRESS
2A73  69                	LD	L,C		;GET HIGH ADDRESS
2A74  E3                	EX	(SP), HL	
2A75  C3 0431           	JP	PARSE1		;SKIP TO NEXT NON-BLANK, AND CHAIN TO CODE
                        ;
                        ;***************************************************************
                        ;              ERROR CHECKING AND HANDLING CODE
                        ;***************************************************************
                        ;
                        ; VCHAR... TESTS FOR A VALID VARIABLE, SYNTAX ERROR IF NOT
                        ;
2A78  CD FC30           VCHAR	CALL	CHAR		;TEST VARIABLE
2A7B  D0                	RET NC			;IF OK, GO BACK
                        ;
                        ; SYNTAX ERROR... HE'S NOT MAKEING ANY SENSE AT ALL
                        ; ISSUE NASTY MESSAGE TO STRAIGHTEN HIM OUT
                        ;
2A7C  21 EA35           SYNT	LD	HL,SYN		;GET NASTY 'SYNTAX' MESSAGE
2A7F  1B                	DEC	DE		;BACK UP IN SOURCE SO WE DONT SAY WRONG LINE
                        ;
                        ; ERROR STUFF... SOMETHING HAS GONE WRONG... TELL HIM THE BAD NEWS AND
                        ; QUIT ANYTHING THAT WE MAY HAVE STARTED, SO THAT THINGS CAN'T GET WORSE
                        ; ALSO, IF WE WERE RUNNING, GIVE HIM THE LINE NUMBER AS A CLUE
                        ;
2A80  3E 3F             ERR	LD	A,'?'		;PRECEDE ERROR MESSAGE BY '?'
2A82  CD 4500           	CALL	BPUTCHR	;DISPLAY ON TERMINAL
2A85  3A 3582           	LD	A, (IFLAG)	;WERE WE TRYING TO 'INPUT' SOMETHING)
2A88  A7                	AND	A		;IF WE WERE, THEN ..
2A89  C2 312F           	JP NZ,	INERR		;SPECIAL MESSAGE + HANDLEING
                        ; NOW THAT WE HAVE FIGURED OUT WHAT'S GOING ON, LET HIM IN ON IT
2A8C  CD 5700           	CALL	PRINTM		;PRINT ERROR MESSAGE
2A8F  21 3D36           	LD	HL,EM		;FOLLOWED BY..
                        ; PRINT MESSAGE FOLLOWED BY LINE NUMBER (ALSO USED BY 'STOP IN LINE XXXX')
2A92  CD 5700           PERR	CALL	PRINTM		;THE ' ERROR ' PART
2A95  3A 3482           	LD	A, (RFLAG)	;WERE WE RUNNING..
2A98  A7                	AND	A		;IF NOT,
2A99  CA BD2A           	JP Z,	INLF		;THEN THATS ALL WE HAVE TO DO
                        ; DISPLAY LINE NUMBER OF RUNNING PROGRAM
2A9C  21 E035           	LD	HL,INL		;ADDRESS OF 'IN LINE ' MESSAGE
2A9F  CD 5700           	CALL	PRINTM		;DISPLAY FOR HIM
                        ; FIND START OF OUR LINE, AND DISPLAY LINE NUMBER
2AA2  1B                FSOL	DEC	DE		;BACK UP IN SOURCE
2AA3  7A                	LD	A,D		;GET HIGH BYTE OF ADDRESS
2AA4  FE 86             	CP	HIGH TEXT	;TEST FOR BEYOND BEGINNING
2AA6  DA AF2A           	JP C,	STLIN		;AT START OF LINE
2AA9  1A                	LD	A, (DE)		;GET CHARACTER FROM BUFER
2AAA  FE 0D             	CP	CR		;TEST FOR CARRIAGE RETURN
2AAC  C2 A22A           	JP NZ,	FSOL		;IF NOT, KEEP LOOKING
2AAF  13                STLIN	INC	DE		;ADVANCE IN SOURCE
2AB0  EB                	EX	DE, HL	
2AB1  CD 512C           	CALL	PNUM		;PRINT AND BUFFER LINE NUMBER
                        ; COPY LINE WITH ERROR INTO OLD LINE EDIT BUFFER, INCASE HE WANTS TO FIX IT
2AB4  23                FIXIT	INC	HL		;SKIP LENGTH BYTE, ADVANCE TO NEXT IN SOURCE
2AB5  7E                	LD	A,(HL)		;GET CHARACTER FROM LINE
2AB6  12                	LD	(DE), A		;SAVE IN BUFFER
2AB7  13                	INC	DE		;ADVANCE TO NEXT IN BUFFER
2AB8  FE 0D             	CP	CR		;TEST FOR END-OF-LINE
2ABA  C2 B42A           	JP NZ,	FIXIT		;IF NOT, KEEP COPYING
                        ; WAIT FOR CONSOLE INPUT, ON A NEW LINE
2ABD  CD 8000           INLF	CALL	BPUTNL		;ADVANCE A LINE ON HIS TERMINAL
2AC0  CD DF2C           	CALL	RESET		;RESET DATA POINTER AND CONTROL-STACK
2AC3  C3 1D2A           	JP	INIT		;GET NEXT COMMAND
                        ;
                        ; SUBROUTINE TEST FOR VALID ASCII DIGIT (0-9), RETURNS WITH C=1 IF NOT
                        ;
2AC6  FE 30             NUM	CP	'0'		;TEST FOR < '0'
2AC8  D8                	RET C			;IF SO, BAD DIGIT
2AC9  FE 3A             	CP	'9'+1		;TEST FOR >'9'
2ACB  3F                	CCF			;INVERT LOGIC, C=1 IF BAD
2ACC  C9                	RET
                        ;
                        ;***************************************************************
                        ;                    TEXT EDITING ROUTINES
                        ;***************************************************************
                        ;
                        ; SUBROUTINE TO GET AND EDIT COMMAND LINE FROM TERMINAL
                        ;
2ACD  CD 8000           BADLN	CALL	BPUTNL		;ADVANCE TO NEW LINE
2AD0  11 0080           GLINE	LD	DE,BUFF		;POINT TO INPUT BUFFER
2AD3  21 0081           	LD	HL,EDBUF	;POINT TO EDIT BUFFER
2AD6  43                	LD	B,E		;CLEAR INSERT FLAG (LOW ADR OF BUFFER IS ZERO)
2AD7  7B                LOOP1	LD	A,E		;GET LOW ADDRESS OF OUR POSITION
2AD8  A7                	AND	A		;TEST FOR NEGATIVE
2AD9  FA CD2A           	JP M,	BADLN		;IF SO, HE'S DELETED BEYOND START OF BUFFER
2ADC  CD ED34           	CALL	BGETCHR		;GET A CHARACTER
2ADF  FE 03             	CP	3		;TEST FOR CONTROL-C (CANCEL)
2AE1  CA BD2A           	JP Z,	INLF		;IF SO, ABORT BACK TO COMMAND HANDLER
2AE4  FE 06             	CP	6		;TEST FOR CONTROL-F (FIND COMMAND)
2AE6  CA 672B           	JP Z,	GFIND		;EXECUTE FIND
2AE9  FE 01             	CP	1		;TEST FOR CONTROL-A (ADVANCE COMMAND)
2AEB  CA 492B           	JP Z,	GADV		;EXECUTE ADVANCE
2AEE  FE 09             	CP	9		;TEST FOR CONTROL-I (TOGGLE INSERT MODE)
2AF0  CA 8A2B           	JP Z,	GINST		;TOGGLE INSERT MODE
2AF3  FE 04             	CP	4		;TEST FOR CONTROL-D (DELETE CHARACTER.)
2AF5  CA 582B           	JP Z,	GRUB		;ERASE CHARACTER
2AF8  FE 20             	CP	' '		;TEST FOR CONTROL-CHARACTER
2AFA  D2 072B           	JP NC,	OKPRT		;IF NOT, OK TO PROCESS
2AFD  FE 0D             	CP	CR		;CARRIAGE RETURN IS OK,
2AFF  CA 072B           	JP Z,	OKPRT		;SO PROCESS IT
2B02  FE 08             	CP	8		;SO IS A BACKSPACE
2B04  C2 D72A           	JP NZ,	LOOP1		;ANYTHING ELSE SHOULD BE IGNORED
                        ; WE HAVE GOTTEN A VALID CHARACTER
2B07  FE 7F             OKPRT	CP	DELETE		;TEST FOR DELETE CHARACTER
2B09  C2 0E2B           	JP NZ,	RECT		;IF IT IS A DELETE,
2B0C  3E 08             	LD	A,8		;MAKE IT INTO A BACKSPACE
2B0E  4F                RECT	LD	C,A		;COPY INTO C
2B0F  CD 4500           	CALL	BPUTCHR		;DISPLAY ON TERMINAL
2B12  1B                	DEC	DE		;ASSUME DELETE (BACKSPACE)
                        ; DON'T DELETE CHARS FROM OLD LINE BUFFER IF WE ARE INSERTING
2B13  B0                	OR	B		;TEST INSERT FLAG
2B14  FA 182B           	JP M,	IND		;IF NOT, WE ARE INSERTING
2B17  2B                	DEC	HL		;REDUCE OLD BUFFER POSITION
2B18  79                IND	LD	A,C		;GET CHARACTER BACK
2B19  FE 08             	CP	8		;TEST FOR DELETE (BACKSPACE)
2B1B  CA D72A           	JP Z,	LOOP1		;IF SO, WE WERE RIGHT, GET NEXT CHARACTER
2B1E  13                	INC	DE		;FIX OUR MISTAKE (NOT DELETE)
2B1F  12                	LD	(DE), A		;SAVE CHARACTER IN BUFFER)
                        ; DON'T MOVE OLD LINE POINTER IF WE ARE INSERTING
2B20  B0                	OR	B		;TEST INSERT FLAG
2B21  FA 2C2B           	JP M,	INOK		;IF SO, DON'T INCREMENT
2B24  23                	INC	HL		;ADVANCE IN OLD LINE BUFFER
2B25  7E                	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
2B26  FE 0D             	CP	CR		;TEST FOR END OF OLD LINE
2B28  CA 2C2B           	JP Z,	INOK		;IF SO, DON'T GO PAST IT
2B2B  23                	INC	HL		;ADVANCE TO NEXT CHARACTER OF OLD LINE
2B2C  79                INOK	LD	A,C		;GET CHARACTER BACK
2B2D  13                	INC	DE		;ADVANCE POINTER IN NEW LINE
2B2E  FE 0D             	CP	CR		;TEST FOR CARRAIGE RETURN (END OF LINE)
2B30  C2 D72A           	JP NZ,	LOOP1		;IF NOT, KEEP GETTING CHARACTERS
2B33  CD 8000           	CALL	BPUTNL		;PRINT LINE-FEED CARRIAGE RETURN
                        ; COPY NEW LINE INTO OLD LINE BUFFER (MAKEING IT THE 'NEW' OLD LINE)
2B36  11 0080           	LD	DE,BUFF		;POINT BACK TO NEW LINE BUFFER
2B39  D5                	PUSH	DE		;SAVE BUFFER ADDRESS
2B3A  21 0081           	LD	HL,EDBUF	;POINT TO OLD LINE BUFFER
2B3D  1A                MOVL	LD	A, (DE)		;GET CHARACTER FROM NEW LINE
2B3E  77                	LD	(HL),A		;SAVE IN OLD LINE BUFFER
2B3F  23                	INC	HL		;POINT TO NEXT
2B40  13                	INC	DE		;POINT TO NEXT
2B41  FE 0D             	CP	CR		;TEST FOR END OF LINE
2B43  C2 3D2B           	JP NZ,	MOVL		;IF NOT, KEEP MOVEING
2B46  D1                	POP	DE		;RESTORE BUFFER ADDRESS
2B47  1A                	LD	A, (DE)		;AND FIRST CHARACTER FROM IT
2B48  C9                	RET
                        ; COPY ONE CHARACTER FROM OLD LINE TO NEW LINE
2B49  7E                GADV	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
2B4A  FE 0D             	CP	CR		;INSURE ITS NOT THE END
2B4C  CA D72A           	JP Z,	LOOP1		;IF SO, IGNORE COMMAND
2B4F  B0                	OR	B		;TEST INSERT FLAG
2B50  7E                	LD	A,(HL)		;GET CHARACTER BACK
2B51  F2 0E2B           	JP P,	RECT		;IF NO INSERT, OK
2B54  23                	INC	HL		;ADVANCE TO NEXT
2B55  C3 0E2B           	JP	RECT		;PASS CHARACTER TO INPUT ROUTINE
                        ; RUB OUT ONE CHARACTER FROM THE OLD LINE
2B58  7E                GRUB	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
2B59  FE 0D             	CP	CR		;TEST FOR END OF LINE
2B5B  CA D72A           	JP Z,	LOOP1		;IF SO, IGNORE COMMAND
2B5E  3E 2A             	LD	A,'*'		;INDICATE RUBBED OUT CHARACTER WITH '*'
2B60  CD 4500           	CALL	BPUTCHR	;PRINT  IT TO SHOW WHAT WE ARE DOING
2B63  23                	INC	HL		;ADVANCE PASSED CHARACTER (RUBBING IT OUT)
2B64  C3 D72A           	JP	LOOP1		;RETURN FOR NEXT CHARACTER
                        ; FIND NEXT CHARACTER IN NEW LINE
2B67  CD ED34           GFIND	CALL	BGETCHR		;GET A CHARACTER
2B6A  4F                	LD	C,A		;SAVE IN C (TO COMPARE AGAINST.)
2B6B  E5                	PUSH	HL		;SAVE POSITION IN OLD LINE
                        ; FIND OUT IF IT IS THERE..
2B6C  7E                GF1	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
2B6D  FE 0D             GF0	CP	CR		;TEST FOR END OF LINE
2B6F  CA 862B           	JP Z,	ABFND		;IF SO, WE DIDN'T FIND IT
2B72  23                	INC	HL		;ADVANCE TO NEXT CHARACTER
2B73  7E                	LD	A,(HL)		;GET CHARACTER
2B74  B9                	CP	C		;TEST FOR CHARACTER WE DESIRE
2B75  C2 6D2B           	JP NZ,	GF0		;IF NOT, KEEP LOOKING
2B78  E1                	POP	HL		;RESTORE POSITION ON OLD LINE
                        ; NOW COPY OLD LINE OVER..
2B79  7E                GF2	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
2B7A  12                GF3	LD	(DE), A		;SAVE IN NEW LINE
2B7B  CD 4500           	CALL	BPUTCHR	;DISPLAY ON TERMINAL
2B7E  23                	INC	HL		;POINT TO NEXT CHAR. IN OLD LINE
2B7F  13                	INC	DE		;POINT TO NEXT CHAR IN NEW LINE
2B80  7E                	LD	A,(HL)		;GET NEXT CHAR FROM NEW LINE
2B81  B9                	CP	C		;TEST FOR CHARACTER WE WANT
2B82  C2 7A2B           	JP NZ,	GF3		;IF NOT, KEEP COPYING
2B85  E5                	PUSH	HL		;FIX UP STACK
2B86  E1                ABFND	POP	HL		;RESTORE POSITION IN OLD LINE
2B87  C3 D72A           	JP	LOOP1		;GET NEXT CHARACTER
                        ; TOGGLE INSERT MODE
2B8A  78                GINST	LD	A,B		;GET INSERT MODE FLAG
2B8B  EE FF             	XOR	0xFF		;COMPLEMENT, SETTING FLAGS
2B8D  47                	LD	B,A		;REAVE IN FLAG REGISTER
2B8E  3E 3C             	LD	A,'<'		;INDICATE ENTERING INSERT MODE
2B90  FA 952B           	JP M,	GIN1		;IF SO, INDICATE SO
2B93  3E 3E             	LD	A,'>'		;INDICATE LEAVING INSERT
2B95  CD 4500           GIN1	CALL	BPUTCHR	;DISPLAY INDICATOR ON TERMINAL
2B98  C3 D72A           	JP	LOOP1		;GET NEXT CHARACTER FROM TERMINAL
                        ;
                        ; GET A PACKED-DECIMAL LINE NUMBER FROM THE COMMAND BUFFER
                        ;
2B9B  21 0000           GETLN	LD	HL,0		;START WITH ZERO
2B9E  1A                ELOOP	LD	A, (DE)		;GET DIGIT FROM COMMAND BUFFER
2B9F  CD C62A           	CALL	NUM		;TEST FOR ASCII DIGIT
2BA2  D8                	RET C			;IF NOT, STOP (WE HAVE IT)
2BA3  13                	INC	DE		;ADVANCE TO NEXT BUFFER POSITION
2BA4  29                	ADD	HL,HL		;MAKE ROOM FOR DIGIT IN BOTTOM..
2BA5  29                	ADD	HL,HL		;OF THE RESULT, BY ..
2BA6  29                	ADD	HL,HL		;ROTATING IT..
2BA7  29                	ADD	HL,HL		;LEFT BY FOUR BITS
2BA8  E6 0F             	AND	0x0F		;CONVERT DIGIT TO BINARY
2BAA  B5                	OR	L		;INSERT INTO LOWER DIGITS OF RESULT
2BAB  6F                	LD	L,A		;AND REPLACE BYTE IN RESULT WITH NEW VALUE
2BAC  C3 9E2B           	JP	ELOOP		;GET NEXT DIGIT
                        ;
                        ; LINE EDITOR, EDITS PROGRAM SOURCE BY LINE NUMBER IN COMMAND BUFFER
                        ;
2BAF  CD 1F2C           EDIT	CALL	LINEF		;LOCATE LINE NUMBER IN SOURCE
2BB2  E5                	PUSH	HL		;SAVE POINTER INTO TEXT
2BB3  C2 C72B           	JP NZ,	INS		;IF NEW LINE, DON'T TRY TO DELETE
                        ; DELETE LINE POINTED TO BY H-L
2BB6  54                DEL	LD	D,H		;COPY POINTER INTO
2BB7  5D                	LD	E,L		;THE D-E PAIR FOR BACKWARDS COPY
2BB8  3E 0D             	LD	A,CR		;WE ARE LOOKING FOR A CARRIAGE RETURN
                        ; FIND START OF NEXT LINE
2BBA  BE                DELNX	CP	(HL)		;TEST FOR END OF LINE TO DELETE
2BBB  23                	INC	HL		;POINT TO NEXT CHARACTER IN SOURCE
2BBC  C2 BA2B           	JP NZ,	DELNX		;IF NOT END OF LINE, KEEP LOOKING
                        ; COPY REST OF PROGRAM BACK OVER DELETED LINE
2BBF  7E                DELLP	LD	A,(HL)		;GET CHARACTER FROM NEXT LINE
2BC0  12                	LD	(DE), A		;SAVE OVER DELETED LINE
2BC1  13                	INC	DE		;POINT TO NEXT IN NEW LINE
2BC2  23                	INC	HL		;POINT TO NEXT IN OLD LINE
2BC3  3C                	INC	A		;TEST FOR END OF FILE
2BC4  C2 BF2B           	JP NZ,	DELLP		;IF NOT, KEEP DELETEING
                        ; INSERT LINE INTO TEXT
2BC7  01 0200           INS	LD	BC,2		;SET LENGTH TO 2 (PACKED DECIMAL NUMBERS ARE 2)
2BCA  11 0080           	LD	DE,BUFF		;POINT TO BUFFER (CONTAINING NEW LINE)
                        ; CALCULATE LENGTH OF LINE
2BCD  CD 9B2B           	CALL	GETLN		;REMOVE NUMBERS AS THEY ARE NOT STORED AS TEXT
2BD0  0C                ILP	INC	C		;INCREMENT LENGTH
2BD1  1A                	LD	A, (DE)		;GET CHARACTER FROM NEW LINE (IN BUFFER)
2BD2  13                	INC	DE		;POINT TO NEXT CHARACTER FROM NEW LINE
2BD3  FE 0D             	CP	CR		;TEST FOR END OF LINE
2BD5  C2 D02B           	JP NZ,	ILP		;IF NOT, KEEP COUNTING
2BD8  79                	LD	A,C		;GET LENGTH
2BD9  E1                	POP	HL		;RESTORE POSITION IN TEXT
2BDA  FE 03             	CP	3		;TEST FOR NULL LINE
2BDC  CA 2C2A           	JP Z,	TOP		;IS SO, DON'T INSERT
                        ; INSERT NEW LINE INTO TEXT
2BDF  54                INLN	LD	D,H		;SET D-E TO POINT TO
2BE0  5D                	LD	E,L		;THE LINE POSITION
2BE1  CD BB30           	CALL	GETEOF		;GET END OF FILE ADDRESS
2BE4  23                	INC	HL		;ADVANCE TO FREE BYTE
2BE5  C5                	PUSH	BC		;SAVE LENGTH
2BE6  E5                	PUSH	HL		;STACK END OF FILE ADDRESS
2BE7  09                	ADD	HL,BC		;ADD LENGTH
2BE8  C1                	POP	BC		;GET END OF FILE ADDRESS
2BE9  23                	INC	HL		;ADVANCE BECAUSE WE DECREMENT
2BEA  2B                IL01	DEC	HL		;REDUCE POINTER INTO NEW POSITION
2BEB  0B                	DEC	BC		;REDUCE POINTER TO OLD POSITION
2BEC  0A                	LD	A, (BC)		;GET BYTE OF OLD DATA
2BED  77                	LD	(HL),A		;SAVE IN NEW POSITION
2BEE  79                	LD	A,C		;GET LOW ADDRESS
2BEF  BB                	CP	E		;TEST AGAINST WHERE WE ARE GOING
2BF0  C2 EA2B           	JP NZ,	IL01		;IF NOT, KEEP COPYING
2BF3  78                	LD	A,B		;GET HIGH ADDRESS
2BF4  BA                	CP	D		;TEST AGAINST DESTINATION
2BF5  C2 EA2B           	JP NZ,	IL01		;IF NOT SAME, KEEP COPYING
2BF8  11 0080           	LD	DE,BUFF		;GET ADDRESS OF NEW LINE
2BFB  CD 9B2B           	CALL	GETLN		;OBTAIN NUMBERS
2BFE  7C                	LD	A,H		;GET HIGH 2 DIGITS
2BFF  02                	LD	(BC), A		;SAVE IN NEW LINE
2C00  03                	INC	BC		;POINT TO NEXT CHARACTER OF NEW LINE
2C01  7D                	LD	A,L		;GET LOW DIGITS
2C02  02                	LD	(BC), A		;SAVE IN NEW LINE
2C03  03                	INC	BC		;ADVANCE TO NEXT CHARACTER IN NEW LINE
2C04  E1                	POP	HL		;RESTORE LENGTH
2C05  7D                	LD	A,L		;GET LENGTH
2C06  C6 10             	ADD	A,0x10		;ADD OFFSET TO MAKE UNIQUE
2C08  02                	LD	(BC), A		;SAVE IN NEW LINE
2C09  03                	INC	BC		;POINT TO NEXT CHARACTER
2C0A  1A                IL02	LD	A, (DE)		;GET CHARACTER FROM NEW LINE IN BUFFER
2C0B  02                	LD	(BC), A		;SAVE IN TEXT
2C0C  03                	INC	BC		;POINT TO NEXT POSITION IN TEXT
2C0D  13                	INC	DE		;ADVANCE IN BUFFER
2C0E  FE 0D             	CP	CR		;TEST FOR END OF LINE
2C10  C2 0A2C           	JP NZ,	IL02		;IF NOT, KEEP LOOKING
                        ; WE ARE INSERTING OR REPLACEING A LINE, SINCE WE DON'T KNOW HOW MUCH
                        ; MEMORY IT WILL REQUIRE, WE MUST CLEAR THE ARRAYS, AS THEY FOLLOW THE
                        ; PROGRAM. WE DO NOT HAVE TO DO THIS WHEN DELETING LINES
2C13  CD CD2C           	CALL	CLRARY		;CLEAR ARRAYS AND RETURN
2C16  C3 2C2A           	JP	TOP		;GO BACK FOR NEXT COMMAND
                        ;
                        ; LOCATE LINE IN TEXT, SYNTAX ERROR IF NOT LINE NUMBER
                        ;
2C19  CD C62A           FNDLIN	CALL	NUM		;IS IT A VALID NUMBER
2C1C  DA 7C2A           	JP C,	SYNT		;IF NOT, IT'S A INVALID
                        ;
                        ; FINDS LINE IN PROGRAM TEXT. RETURNS WITH Z FLAG SET IF LINE EXISTS
                        ; H-L POINTS TO START OF LINE. B-C CONTAINS LINE NUMBER OF ACTUAL
                        ; LINE FOUND. (IF LINE NOT FOUND, POINTS TO FIRST GREATER LINE NUMBER)
                        ;
2C1F  CD 9B2B           LINEF	CALL	GETLN		;GET LINE NUMBER FROM COMMAND BUFFER
2C22  EB                	EX	DE, HL	
2C23  21 0086           	LD	HL,TEXT		;START AT TOP OF PROGRAM
2C26  7E                TRY	LD	A,(HL)		;GET FIRST CHARACTER FROM PROGRAM LINE
2C27  FE FF             	CP	0xFF		;TEST FOR END OF FILE
2C29  CA 4E2C           	JP Z,	EOF		;IF SO, WE DIDN'T FIND
2C2C  23                	INC	HL		;ADVANCE POINTER TO LOW DIGITS
2C2D  BA                	CP	D		;TEST FOR HIGH DIGITS CORRECT
2C2E  DA 392C           	JP C,	NEXTL		;IF LESS, FIND NEXT LINE
2C31  C2 462C           	JP NZ,	NOTFND		;IF GREATER, LINE WASN'T FOUND
2C34  7E                	LD	A,(HL)		;GET LOW DIGITS
2C35  BB                	CP	E		;TEST LOW DIGITS
2C36  D2 462C           	JP NC,	NOTFND		;IF LESS, LINE IS HERE OR DOSN'T EXIST
                        ; ADVANCE TO NEXT LINE IN SOURCE
2C39  23                NEXTL	INC	HL		;POINT TO LINE LENGTH
2C3A  7E                	LD	A,(HL)		;GET LENGTH
2C3B  D6 11             	SUB	0x11		;SUBTRACT OFFSET USED TO MAKE IT UNIQUE
2C3D  85                	ADD	A,L		;ADD TO POINTER
2C3E  6F                	LD	L,A		;AND REPLACE IN POINTER
2C3F  D2 262C           	JP NC,	TRY		;IF NO CARRY, THATS IT
2C42  23                	INC	HL		;BUMP HIGH ADDRESS
2C43  C3 262C           	JP	TRY		;AND TEST THIS LINE
                        ; LINE IS HERE OR BEFORE
2C46  2B                NOTFND	DEC	HL		;BACK UP TO DIGIT
2C47  4F                	LD	C,A		;PLACE LOW ORDER DIGIT IN C
2C48  46                	LD	B,(HL)		;PLACE HIGH ORDER DIGIT IN B
2C49  BB                	CP	E		;TEST FOR LINE FOUND
2C4A  C0                	RET NZ			;IF NOT SAME, RETURN INDICATING SO
2C4B  78                	LD	A,B		;GET HIGH DIGIT
2C4C  BA                	CP	D		;INDICATE IF NUMBERS SAME
2C4D  C9                	RET
                        ; LINE WAS GREATER THAN ALL LINES IN PROGRAM, INDICATE EOF REACHED
2C4E  47                EOF	LD	B,A		;RETURN HIGH LINE NUMBER
2C4F  A7                	AND	A		;INDICATE LINE DOSN'T EXIST
2C50  C9                	RET
                        ;
                        ; PRINTS PACKED-DECIMAL LINE NUMBER ON TERMINAL, AS WELL AS PLACEING
                        ; IT AT THE START OF THE EDIT BUFFER
                        ;
2C51  11 0081           PNUM	LD	DE,EDBUF	;SET UP POINTER TO EDIT BUFFER
2C54  CD 572C           	CALL	HPOUT		;PRINT FIRST TWO DIGITS
2C57  7E                HPOUT	LD	A,(HL)		;GET CONTENTS OF MEMORY
2C58  23                	INC	HL		;AND POINT TO NEXT
2C59  F5                	PUSH	AF
2C5A  0F                	RRCA			;ROTATE
2C5B  0F                	RRCA			;UPPER DIGIT
2C5C  0F                	RRCA			;INTO
2C5D  0F                	RRCA			;LOWER DIGIT
2C5E  CD 622C           	CALL	POUT		;DISPLAY UPPER DIGIT
2C61  F1                	POP	AF
                        ; DISPLAYS ONE DIGIT
2C62  E6 0F             POUT	AND	0x0F		;REMOVE UPPER GARBAGE
2C64  F6 30             	OR	0x30		;CONVERT TO ASCII DIGIT
2C66  12                	LD	(DE), A		;SAVE IN EDIT BUFFER
2C67  13                	INC	DE		;ADVANCE POINTER IN EDIT BUFFER
2C68  C3 4500           	JP	BPUTCHR	;DISPLAY DIGIT ON TERMINAL AND RETURN
                        ;
                        ;*****************************************************************
                        ;                   BASIC COMMAND HANDLERS
                        ;*****************************************************************
                        ;
                        ; IT'S A 'LIST' COMMAND, LETS GIVE HIM A PEEK AT THE SOURCE
                        ; ALSO PLACE LAST LINE LISTED IN BUFFER, INCASE HE WANTS TO EDIT IT
                        ;
2C6B  D5                LIST	PUSH	DE		;SAVE PROGRAM POINTER
2C6C  21 0086           	LD	HL,TEXT		;START AT THE BEGINNING OF THE PROGRAM
2C6F  06 FF             	LD	B,255		;SET ENDING LINE BEYOND END OF TEXT
2C71  1A                	LD	A, (DE)		;GET CHARACTER OF OPERAND
2C72  CD C62A           	CALL	NUM		;TEST FOR A NUMBER
2C75  DA 892C           	JP C,	GO		;IF NOT, LIST WHOLE THING
2C78  CD 9B2B           	CALL	GETLN		;GET LINE NUMBER
2C7B  E5                	PUSH	HL		;SAVE ON STACK
2C7C  13                	INC	DE		;POINT TO NEXT CHARACTER
2C7D  FE 2C             	CP	','		;TEST FOR ENDING NUMBER
2C7F  CC 1F2C           	CALL Z,	LINEF		;IF SO, GET ENDING NUMBER
2C82  23                	INC	HL		;ADVANCE PAST BEGINNING OF LINE
2C83  D1                	POP	DE		;GET STARTING LINE NUMBER BACK
2C84  E5                	PUSH	HL		;SAVE ENDING LINE
2C85  CD 232C           	CALL	LINEF+4		;FIND STARTING LINE ADDRESS
2C88  C1                	POP	BC		;GET ENDING ADDRESS BACK
                        ; LIST TEXT FROM STARTING LINE IN H-L TO ENDING LINE IN B-C
2C89  7E                GO	LD	A,(HL)		;GET CHARACTER FROM START OF LINE
2C8A  3C                	INC	A		;TEST FOR END OF FILE
2C8B  CA AD2C           	JP Z,	LIRET		;IF SO, STOP LISTING
2C8E  CD 512C           	CALL	PNUM		;DISPLAY LINE NUMBER AND BUFFER IT
2C91  23                	INC	HL		;SKIP LENGTH BYTE, AS IT DOSN'T LOOK PRETTY
2C92  7E                PRINS	LD	A,(HL)		;GET CHARACTER FROM LINE
2C93  12                	LD	(DE), A		;PLACE INTO BUFFER
2C94  13                	INC	DE		;ADVANCE IN BUFFER
2C95  CD 4500           	CALL	BPUTCHR	;DISPLAY ON TERMINAL
2C98  23                	INC	HL		;ADVANCE POINTER IN PROGRAM
2C99  FE 0D             	CP	CR		;TEST FOR END OF LINE
2C9B  C2 922C           	JP NZ,	PRINS		;IF NOT, KEEP PRINTING
2C9E  CD 8000           	CALL	BPUTNL		;NEW LINE ON TERMINAL
2CA1  CD 6532           	CALL	COMP		;TEST FOR LAST LINE LISTED
2CA4  D2 AD2C           	JP NC,	LIRET		;IF SO, STOP LISTING
2CA7  CD E734           	CALL	CTRLC		;TEST FOR ABORT FROM TERMINAL
2CAA  C2 892C           	JP NZ,	GO		;KEEP LISTING IF NOT
2CAD  D1                LIRET	POP	DE		;RESTORE PROGRAM POINTER
2CAE  C9                	RET
                        ;
                        ; CLEARS VARIABLES AND ARRAYS. (INITIALIZES THEM) AND INITIALIZES EDIT BUFFER
                        ;
2CAF  21 0082           CLEAR	LD	HL,VARS		;POINT TO VARIABLE SPACE
2CB2  3E 0D             	LD	A,CR		;GET A CARRIAGE RETURN (END OF LINE CHARACTER)
2CB4  32 0081           	LD	(EDBUF), A	;INITIALIZE EDIT BUFFER TO A NULL LINE
2CB7  0E 34             	LD	C,52		;26 VARIABLE TIMES 2 BYTES/VARIABLE
2CB9  36 00             CVLP	LD	(HL),0		;CLEAR INTEGER VARAIBLES TO ZERO
2CBB  23                	INC	HL		;ADVANCE TO NEXT BYTE OF VARIABLE SPACE
2CBC  0D                	DEC	C		;REDUCE COUNT OF VARAIABLES LEFT
2CBD  C2 B92C           	JP NZ,	CVLP		;KEEP GOING TILL ALL INTEGERS ARE ZERO'ED
2CC0  3E 86             	LD	A,HIGH (VARS + 0x400) ;ADDRESS OF END OF VARIABLE TABLE
2CC2  01 0A00           	LD	BC,10		;SKIP AHEAD 10 BYTES
2CC5  09                	ADD	HL,BC		;SO THAT WE DON'T CLOBBER OUR FLAGS
2CC6  36 FF             CVL1	LD	(HL),255	;0xFF IS NULL CHARACTER FOR CHAR. VARS
2CC8  23                	INC	HL		;POINT TO NEXT BYTE IN CHAR. VAR. SPACE
2CC9  BC                	CP	H		;TEST FOR COMPLETE (ALL SET TO NULL STRINGS)
2CCA  C2 C62C           	JP NZ,	CVL1		;KEEP GOING TILL WE DO THEM ALL
                        ; INITIALIZE ARRAYS, RESET ARRAY SPACE TO FIRST PAGE FOLLOWING PROGRAM
2CCD  CD BB30           CLRARY	CALL	GETEOF		;GET ADDRESS OF FIRST FREE PAGE+SET POINTER
2CD0  32 FD81           	LD	(ARYLOC), A	;STASH IN ARRAY TABLE POINTER
2CD3  67                	LD	H,A		;PLACE IN H, SO WE CAN REFERENCE INDERECT
2CD4  2E 34             	LD	L,52		;START AT END OF TABLE
2CD6  22 3A82           	LD	(LAST), HL	;INDICATE FREE SPACE FOR NEXT ARRAY
2CD9  97                	SUB	A		;GET A ZERO
2CDA  2D                CALS	DEC	L		;BACK UP IN TABLE
2CDB  77                	LD	(HL),A		;INITIALIZE TO INDICATE NO ARRAY
2CDC  C2 DA2C           	JP NZ,	CALS		;KEEP GOING TILL TABLE IS CLEARED
                        ; RESET CONTROL STACK AND DATA POINTER
2CDF  21 FA81           RESET	LD	HL,CS		;GET USER STACK POINTER
2CE2  22 FB81           	LD	(CSP), HL	;INITIALZE USER STACK POINTER
2CE5  21 0000           	LD	HL,0		;GET A ZERO (NO DATA POINTER)
2CE8  22 3882           	LD	(DATA), HL	;INSURE NO DATA PRESENT
2CEB  C9                	RET
                        ;
                        ; ** WE'VE GOTTEN A 'RUN' COMMAND, LETS START THE PROGRAM ROLLING **
                        ;
2CEC  3A 0086           RUN	LD	A, (TEXT)	;GET FIRST CHARACTER OF PROGRAM
2CEF  21 D535           	LD	HL,NP		;AND ADDRESS OF 'NO PROGRAM' MESSAGE
2CF2  3C                	INC	A		;TEST FOR EXISTANCE OF PROGRAM
2CF3  CA 802A           	JP Z,	ERR		;IF NOT, POINT OUT HIS MISTAKE
2CF6  CD AF2C           	CALL	CLEAR		;CLEAR VARIABLES AND ARRAYS
2CF9  11 0086           	LD	DE,TEXT		;START INTERPRETING AT THE BEGINNING
2CFC  3E FF             RGON	LD	A,255		;INDICATE THAT WE ARE RUNNING
2CFE  32 3482           	LD	(RFLAG), A	;BY SETTING THIS FLAG
2D01  13                RNEWL	INC	DE		;SKIP PACKED DECIMAL LINE
2D02  13                	INC	DE		;NUMBERS, AND THE LENGTH BYTE,
2D03  13                	INC	DE		;AS THE COMMAND FINDER WON'T LIKE IT
                        ; MAIN 'RUN' INTERPRETING LOOP
2D04  31 F780           RLOOP	LD	SP,STACK	;REPAIR ANY DAMAGE
2D07  CD E734           	CALL	CTRLC		;TEST FOR 'MAGIC' CONTROL-C CHARACTER
2D0A  CA 2C2D           	JP Z,	STOP		;IF SO, FAKE A 'STOP' COMMAND
2D0D  21 F234           	LD	HL,PTAB-1	;POINT TO PROGRAM COMMAND TABLE
2D10  CD 4E2A           	CALL	CMD		;RUN PROGRAM CODE
                        ; ADVANCE TO NEXT STATEMENT
2D13  1A                RNEXT	LD	A, (DE)		;GET CHARACTER FROM SOURCE
2D14  FE 22             	CP	'"'		;TEST FOR A QUOTE
2D16  CC 2931           	CALL Z,	SKPQUO		;IF SO, SEARCH FOR NEXT ONE
2D19  13                	INC	DE		;ADVANCE TO NEXT CHARACTER
2D1A  FE 3A             	CP	':'		;TEST FOR COLON (NEW STATEMENT)
2D1C  CA 042D           	JP Z,	RLOOP		;IF SO, EXECUTE NEXT COMMAND
2D1F  FE 0D             	CP	CR		;TEST FOR CARRIAGE RETURN
2D21  C2 132D           	JP NZ,	RNEXT		;IF NOT, KEEP LOOKING
2D24  1A                	LD	A, (DE)		;GET FIRST CHAR OF NEW LINE
2D25  3C                	INC	A		;TEST FOR 0xFF (END OF FILE)
2D26  CA 1D2A           	JP Z,	INIT		;IF SO, GO BACK TO COMMAND MODE
2D29  C3 012D           	JP	RNEWL		;EXECUTE THIS LINE
                        	
                        ;
                        ; EITHER WE HAVE GOTTEN A 'STOP' COMMAND, OR THE OPERATOR PRESSED
                        ; CONTROL-C, EITHER WAY, PRINT THE MESSAGE AND BEXIT
                        ;
2D2C  21 3836           STOP	LD	HL,STMSG	;ADDRESS OF 'STOP' MESSAGE
2D2F  C3 922A           	JP	PERR		;TREAT IT LIKE AN ERROR
                        ; IT'S A 'THEN', FOLLOWING AN 'IF', LOOK FOR LINE NUMBER OR A STATEMENT
2D32  CD C62A           THEN	CALL	NUM		;IS IT A NUMBER?
2D35  D2 432D           	JP NC,	GOTO		;IF SO, ITS A NUMBER TO 'GOTO'
2D38  C3 042D           	JP	RLOOP		;IF NOT, ITS A STATEMENT TO EXECUTE
                        ;
                        ; IT'S A 'GOSUB' SAVE RETURN ADDRESS, AND PRETEND IT'S 'GOTO'
                        ;
2D3B  CD BD2D           GOSUB	CALL	PUSHD		;SAVE SOURCE POSITION
2D3E  97                	SUB	A		;INDICATE GOSUB ENTRY
2D3F  CD A92D           	CALL	PUSHS		;SAVE ON USER STACK
2D42  1A                	LD	A, (DE)		;RESTORE OPERAND CHARACTER
                        ;
                        ; IT'S A 'GOTO' MAKE THE BIG JUMP
                        ;
2D43  FE 28             GOTO	CP	'('		;TEST FOR COMPUTED GOTO
2D45  C2 5E2D           	JP NZ,	NOON		;IF NO, NOT AN 'ON' STATEMENT
2D48  CD 3531           	CALL	EXPR		;GET VALUE OF INTERNAL EXPRESSION
2D4B  CD 0F31           GLPO	CALL	SKIP		;SKIP TO NEXT EXPRESSION
2D4E  FE 2C             	CP	','		;IF THERE IS NO MORE COMMA'S
2D50  C2 7C2A           	JP NZ,	SYNT		;THEN WE RAN OUT OF OPERANDS
2D53  13                GLPD	INC	DE		;SKIP THE COMMA
2D54  2D                	DEC	L		;REDUCE OUR COUNT
2D55  F2 4B2D           	JP P,	GLPO		;IF IT'S STILL POSITIVE, KEEP SKIPPING
2D58  1A                	LD	A, (DE)		;GET CHARACTER FROM SOURCE
2D59  FE 20             	CP	' '		;TEST FOR BLANKS
2D5B  CA 532D           	JP Z,	GLPD		;AND KEEP GOING TILL WE SKIP THEM
2D5E  D5                NOON	PUSH	DE		;SAVE POSITION (IN CASE WE FAIL)
2D5F  CD 192C           	CALL	FNDLIN		;FIND THE LINE HE WANTS
2D62  D1                	POP	DE		;RESTORE OUR POSITION
2D63  EB                	EX	DE, HL	
2D64  CA FC2C           	JP Z,	RGON		;IF SUCESS, GOTO NEW LINE
2D67  EB                	EX	DE, HL	
                        ;
                        ; OH OH, LOOKS LIKE HE'S TRIED TO GOTO, GOSUB OR ORDER TO A LINE HE FORGOT
                        ; TO TYPE IN, TELL HIM ABOUT IT AND LET HIM TRY TO FIGURE IT OUT
                        ;
2D68  21 C935           BADLIN	LD	HL,LIN		;ADDRESS OF 'LINE NUMBER' MESSAGE
2D6B  C3 802A           	JP	ERR		;HANDLE LIKE ANY ERROR
                        ;
                        ; IT'S A 'RETURN', HOPE SOMEBODY DID A 'GOSUB' SOMEWHERE
                        ;
2D6E  CD B42D           RETURN	CALL	POPS		;GET TYPE OF STACK ENTRY
2D71  A7                	AND	A		;TEST FOR 'GOSUB' ENTRY
2D72  CA C72D           	JP Z,	POPD		;IF SO, GET ADDRESS BACK AND RETURN
                        ;
                        ; HE SCREWED UP THE FOR/NEXT, GOSUB/RETURN NESTING
                        ; LET HIM IN ON IT AND DIE WHILE WE CAN
                        ;
2D75  21 C135           NSTERR	LD	HL,CSTK		;ADDRESS OF 'NESTING' MESSAGE
2D78  C3 802A           	JP	ERR		;HANDLE LIKE ANY ERROR
                        ;
                        ; IT'S A 'FOR' COMMAND, LETS THROW THIS THING FOR A LOOP
                        ;
2D7B  CD 782A           FOR	CALL	VCHAR		;INSURE IT'S A VARIABLE
2D7E  F5                	PUSH	AF
2D7F  1B                	DEC	DE		;BACK UP POINT JUST BEFORE EXPRESSION
2D80  7B                	LD	A,E		;GET LOW ADDRESS
2D81  32 3682           	LD	(P), A		;AND PLACE IN POSITION FLAG
2D84  1A                FINTO	LD	A, (DE)		;GET CHARACTER FROM SOURCE
2D85  FE 0D             	CP	CR		;TEST FOR END OF LINE
2D87  CA 7C2A           	JP Z,	SYNT		;IF SO, HE'S GOOFED
2D8A  13                	INC	DE		;SKIP TO NEXT
2D8B  FE 54             	CP	'T'		;TEST FOR A 'T'
2D8D  C2 842D           	JP NZ,	FINTO		;IF NOT, WE ARN'T THERE YET
2D90  1A                	LD	A, (DE)		;GET NEXT CHARACTER
2D91  FE 4F             	CP	'O'		;IS IT 'TO'
2D93  C2 842D           	JP NZ,	FINTO		;NO, MUST BE VARIABLE 'T'
2D96  D5                	PUSH	DE		;SAVE OUR POSITION
2D97  1B                	DEC	DE		;BACKUP TO THE 'T'
2D98  CD 3E31           	CALL	DOEXP		;EVALUATE EXPRESSION
2D9B  D1                	POP	DE		;RESTORE OUT POSITION
2D9C  13                	INC	DE		;SKIP 'O'
2D9D  CD 3531           	CALL	EXPR		;GET LIMIT EXPRESSION
2DA0  CD BD2D           	CALL	PUSHD		;SAVE OUR POSITION ON STACK
2DA3  EB                	EX	DE, HL	
2DA4  CD BD2D           	CALL	PUSHD		;SAVE ON STACK
2DA7  EB                	EX	DE, HL	
2DA8  F1                	POP	AF
                        ;
                        ; SAVES A SINGLE BYTE ENTRY ON THE USER (CONTROL) STACK
                        ;
2DA9  E5                PUSHS	PUSH	HL		;SAVE H-L
2DAA  2A FB81           	LD	HL, (CSP)	;GET STACK POINTER
2DAD  77                	LD	(HL),A		;SAVE BYTE ON STACK
2DAE  2B                PSH1	DEC	HL		;REDUCE POINTER
2DAF  22 FB81           PSH2	LD	(CSP), HL	;RESAVE STACK POINTER
2DB2  E1                	POP	HL		;RESTORE H-L
2DB3  C9                	RET
                        ;
                        ; POP A SINGLE BYTE ENTRY FROM THE USER (CONTROL) STACK
                        ;
2DB4  E5                POPS	PUSH	HL		;SAVE H-L
2DB5  2A FB81           	LD	HL, (CSP)	;GET STACK POINTER
2DB8  23                	INC	HL		;ADVANCE TO NEXT ENTRY
2DB9  7E                	LD	A,(HL)		;GET BYTE BACK
2DBA  C3 AF2D           	JP	PSH2		;SAVE POINTER AND CONTINUE
                        ;
                        ; PUSHES A DOUBLE BYTE ENTRY ON THE USER (CONTROL) STACK
                        ;
2DBD  E5                PUSHD	PUSH	HL		;SAVE H-L
2DBE  2A FB81           	LD	HL, (CSP)	;GET STACK POINTER
2DC1  72                	LD	(HL),D		;SAVE HIGH BYTE
2DC2  2B                	DEC	HL		;BACK UP
2DC3  73                	LD	(HL),E		;SAVE LOW BYTE
2DC4  C3 AE2D           	JP	PSH1		;SAVE POINTER AND CONTINUE
                        ;
                        ; POPS A DOUBLE BYTE ENTRY FROM THE USER STACK
                        ;
2DC7  E5                POPD	PUSH	HL		;SAVE H-L
2DC8  2A FB81           	LD	HL, (CSP)	;GET STACK POINTER
2DCB  23                	INC	HL		;ADVANCE TO LAST ENTRY
2DCC  5E                	LD	E,(HL)		;GET LOW BYTE
2DCD  23                	INC	HL		;ADVANCE TO HIGH BYTE
2DCE  56                	LD	D,(HL)		;GET HIGH BYTE
2DCF  C3 AF2D           	JP	PSH2		;SAVE AND CONTINUE
                        ;
                        ; LET COMMAND, EVALUATE EXPRESSION
                        ;
2DD2  CD 3531           LET	CALL	EXPR		;EVALUATE EXPRESSION
2DD5  3A 3782           	LD	A, (EFLAG)	;DID HE MAKE AN ASSIGNMENT?
2DD8  A7                	AND	A		;IF NOT..
2DD9  CA 7C2A           	JP Z,	SYNT		;HE'S MADE ANOTHER MISTAKE
2DDC  97                	SUB	A		;RESET THE FLAG
2DDD  32 3782           	LD	(EFLAG), A	;SO WE KNOW WHEN HE SCREW'S UP AGAIN
2DE0  C9                	RET
                        ;
                        ; IT'S A NEXT COMMAND, TEST INDEX AGAINST LIMIT, AND LOOP IF NEEDED
                        ;
2DE1  CD 782A           NEXT	CALL	VCHAR		;TEST FOR VALID VARIABLE
2DE4  47                	LD	B,A		;STASH IN B FOR SAFEKEEPING
2DE5  2A FB81           	LD	HL, (CSP)	;SAVE CONTROL STACK POINTER..
2DE8  22 3E82           	LD	(TEMP), HL	;IN CASE WE NEED TO LOOP AGAIN
2DEB  CD B42D           	CALL	POPS		;GET VARIABLE NAME FROM STACK
2DEE  B8                	CP	B		;TEST FOR WHAT HE GAVE US
2DEF  C2 752D           	JP NZ,	NSTERR		;IF NOT, HE'S SCREWED UP THE NESTING
2DF2  CD F82F           	CALL	LOOK		;GET VARIABLE VALUE
2DF5  D5                	PUSH	DE		;SAVE POSITION
2DF6  CD C72D           	CALL	POPD		;GET LIMIT FROM STACK
2DF9  42                	LD	B,D		;GET LIMIT
2DFA  4B                	LD	C,E		;INTO B-C SO WE CAN 'COMP'
2DFB  CD 6532           	CALL	COMP		;TEST IF INDEX >= LIMIT
2DFE  D2 112E           	JP NC,	NOMORE		;IF SO, DON'T LOOP ANYMORE
2E01  D1                	POP	DE		;GET POSITION BACK
2E02  23                	INC	HL		;INCREMENT LOOP INDEX
2E03  1A                	LD	A, (DE)		;GET VARIABLE NAME BACK
2E04  CD E72F           	CALL	STOR		;SAVE IT AWAY
2E07  CD C72D           	CALL	POPD		;GET NEW POSITION
2E0A  2A 3E82           	LD	HL, (TEMP)	;GET CONTROL-STACK POINTER
2E0D  22 FB81           	LD	(CSP), HL	;AND REPLACE IT (LEAVING STACK UNCHANGED)
2E10  C9                	RET
                        ; WE HAVE HIT THE END OF A FOR NEXT LOOP
2E11  CD C72D           NOMORE	CALL	POPD		;CLEAN UP CONTROL STACK
2E14  D1                	POP	DE		;GET PROGRAM COUNTER BACK
                        ;
                        ; REMARK, DO NOTHING, BUT RETURN, ALLOWING 'RNEXT' TO SKIP THE COMMAND
                        ;
2E15  C9                REM	RET
                        ;
                        ; IT'S AN 'IF' STATEMENT. FIND OUT 'IF' WE DO IT OR NOT
                        ;
2E16  1B                IF	DEC	DE		;BACK UP IN SOURCE
2E17  7B                	LD	A,E		;GET LOW ADDRESS
2E18  32 3682           	LD	(P), A		;SAVE IN POSITION POINTER
2E1B  1A                FTHEN	LD	A, (DE)		;GET CHARACTER FROM SOURCE
2E1C  FE 0D             	CP	CR		;IF IT'S A CARRIAGE RETURN..
2E1E  CA 7C2A           	JP Z,	SYNT		;THEN HE DIDN'T TYPE IN A 'THEN'
2E21  13                	INC	DE		;ADVANCE TO NEXT CHARACTER
2E22  FE 54             	CP	'T'		;IS IT A 'T'?
2E24  C2 1B2E           	JP NZ,	FTHEN		;IF NOT, IT AINT THE START OF 'THEN'
2E27  1A                	LD	A, (DE)		;GET NEXT CHARACTER
2E28  FE 48             	CP	'H'		;TEST FOR NEXT CHARACTER OF 'THEN'
2E2A  C2 1B2E           	JP NZ,	FTHEN		;NO, MUST BE VARIABLE 'T' (OR HE CAN'T SPELL)
2E2D  1B                	DEC	DE		;BACK UP TO 'T'
2E2E  D5                	PUSH	DE		;SAVE POSITION IN SOURCE
2E2F  CD 3E31           	CALL	DOEXP		;EVALUATE CONDITION EXPRESSION
2E32  D1                	POP	DE		;GET POSITION BACK
2E33  7C                	LD	A,H		;GET RESULT AND TEST.
2E34  B5                	OR	L		;IT FOR ZERO (FALSE)
2E35  C8                	RET Z			;IF SO, SKIP THIS STATEMENT
2E36  C3 042D           	JP	RLOOP		;EXECUTE THE 'THEN'
                        ;
                        ; LONG IF, CONTROLS REMAINDER OF ENTIRE LINE
                        ;
2E39  CD 162E           LIF	CALL	IF		;CALCULATE AND PROCESS IF TRUE
2E3C  13                LNXT	INC	DE		;ADVANCE IN SOURCE
2E3D  1A                	LD	A, (DE)		;GET CHARACTER FROM SOURCE
2E3E  FE 0D             	CP	CR		;TEST FOR END OF LINE
2E40  C2 3C2E           	JP NZ,	LNXT		;KEEP LOOKING
2E43  C9                	RET
                        ;
                        ; IT A 'PLOT' COMMAND, (HE'S PLOTTING AGAINST US)
                        ;
2E44  CD 3531           PLOT	CALL	EXPR		;GET X COORDINATE
2E47  DA 7C2A           	JP C,	SYNT		;IF CHARACTER, IT'S NO GOOD
2E4A  E5                	PUSH	HL		;SAVE X COORDINATE
2E4B  13                	INC	DE		;ADVANCE PAST ','
2E4C  CD 3531           	CALL	EXPR		;GET Y COORDINATE
2E4F  C1                	POP	BC		;GET X POSITION IN B-C
2E50  29                	ADD	HL,HL		;MULTIPLY.
2E51  29                	ADD	HL,HL		;Y POSITION.
2E52  29                	ADD	HL,HL		;BY 64.
2E53  29                	ADD	HL,HL		;TO PLACE ADDRESS.
2E54  29                	ADD	HL,HL		;ON PROPER LINE.
2E55  29                	ADD	HL,HL		;OF THE DISPLAY
2E56  09                	ADD	HL,BC		;ADD IN X POSITION
2E57  01 0004           	LD	BC,1024		;TEST AGAINST END OF SCREEN
2E5A  CD 6532           	CALL	COMP		;TO SEE IF WE ARE OVER
2E5D  D2 AF2F           	JP NC,	DIMERR		;IF SO, 'DIMENSION ERROR'
                        	;CALL	CURPOS		;POSITION THE CURSOR
                        ; LOOK FOR END OF LINE, OR OTHER OPERANDS
2E60  CD 0F31           	CALL	SKIP		;GET NEXT SEPERATOR
2E63  FE 2C             	CP	','		;TEST FOR COMMA
2E65  C0                	RET NZ			;IF NOT, WE ARE DONE
2E66  13                	INC	DE		;SKIP ','

                        ; OUT STATEMENT, LET'S OUTPUT SOMETHING TO A PORT
2E67  CD 3531           OUTP	CALL	EXPR		;GET EXPRESSION FOR PORT#
2E6A  DA 7C2A           	JP  C,	SYNT
2E6D  C5                	PUSH	BC
2E6E  4D                	LD	C,L		;SET PORT
2E6F  1A                	LD	A, (DE)		;GET CHARACTER FROM SOURCE
2E70  FE 2C             	CP	','		;TEST FOR COMMA
2E72  C2 7C2A           	JP NZ,	SYNT
2E75  CD 0331           	CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
2E78  CD 3531           	CALL	EXPR		;GET EXPRESSION FOR PORT#
2E7B  DA 7C2A           	JP  C,	SYNT
2E7E  ED69              	OUT	(C),L
2E80  79                	LD	A,C		;IF OUTPUT TO 0x40, THEN WRITE TO SCAN LED
2E81  E6 E0             	AND	0xE0
2E83  FE 40             	CP	0x40
2E85  20 04             	JR  NZ,	OUTPR
2E87  7D                	LD	A,L
2E88  32 F5FF           	LD	(0xFFF5),A	;SCAN_LED ON Z80MC
2E8B  C1                OUTPR	POP	BC
2E8C  C9                	RET

                        ;
                        ; PRINT STATEMENT, LET'S OUTPUT SOMETHING SO HE WON'T GET UPSET
                        ; WHILE STARING AT THE TUBE WONDERING IF WE DIED
                        ;
2E8D  CD 3531           BPRINT	CALL	EXPR		;GET EXPRESSION TO PRINT
2E90  D5                	PUSH	DE		;SAVE BASIC'S PROGRAM COUNTER
2E91  D4 B22E           	CALL NC, DECPRT		;IF NUMERIC, OUTPUT DECIMAL NUMBER
2E94  D1                	POP	DE		;RESTORE BASIC'S PROGRAM COUNTER
2E95  DC A52E           	CALL C,	PV1		;IF CHARACTER, DISPLAY CHARACTER VALUE
2E98  1A                	LD	A, (DE)		;GET CHARACTER FROM SOURCE
2E99  FE 2C             	CP	','		;TEST FOR COMMA
2E9B  C2 8000           	JP NZ,	BPUTNL		;IF NOT, IT'S THE END
2E9E  CD 0331           	CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
2EA1  C2 8D2E           	JP NZ,	BPRINT		;PRINT NEXT EXPRESSION
2EA4  C9                	RET
                        ; PRINT CHARACTER EXPRESSIONS
2EA5  21 6480           PV1	LD	HL,XBF		;EXPRESSION IS IN EXTRA BUFFER
2EA8  7E                PZ	LD	A,(HL)		;GET CHARACTER FROM EXPRESSION
2EA9  23                	INC	HL		;POINT TO NEXT
2EAA  A7                	AND	A		;TEST FOR END OF EXPRESSION
2EAB  F8                	RET M			;IF SO, END IT NOW
2EAC  CD 4500           	CALL	BPUTCHR	;PRINT CHARACTER
2EAF  C3 A82E           	JP	PZ		;KEEP GOING TILL END
                        	
                        ; RECURSIVE ROUTINE OUTPUTS NUMBER IN DECIMAL
2EB2  FE 28             DECPRT	CP	'('		;TEST FOR SPECIAL CASE
2EB4  C4 7D00           	CALL NZ, BPUTSP	;IF NOT, PRECEDE WITH SPACE
2EB7  01 0A00           DECP1	LD	BC,10		;DIVIDE BY 10
2EBA  CD 2932           	CALL	DODIV		;PERFORM DIVISION
2EBD  3E 30             	LD	A,0x30		;TO CONVERT TO ASCII
2EBF  85                	ADD	A,L		;GET DIGIT
2EC0  F5                	PUSH	AF
2EC1  EB                	EX	DE, HL	
2EC2  7C                	LD	A,H		;GET HIGH BYTE
2EC3  B5                	OR	L		;TEST FOR ZERO, (FINISHED)
2EC4  C4 B72E           	CALL NZ, DECP1		;IF NOT, GET NEXT VALUE
2EC7  F1                	POP	AF
2EC8  C3 4500           	JP	BPUTCHR	;DISPLAY AND RETURN
                        ;
                        ; IT'S AN 'INPUT', LETS GIVE HIM A CHANCE TO DO SOME TYPING.. BUT
                        ; KEEP AN EYE ON HIM, IN CASE HE TRY'S TO PUT SOMETHING OVER ON US
                        ;
2ECB  CD A334           INPUT	CALL	CLBF		;CLEAR EXTRA TEXT BUFFER
2ECE  3E 3F             	LD	A,'?'		;GET A QUESTION MARK.
2ED0  32 6480           	LD	(XBF), A	;TO USE AS THE DEFAULT PROMPT
2ED3  1A                	LD	A, (DE)		;GET FIRST CHAR OF OPERAND
2ED4  FE 22             	CP	'"'		;TEST FOR USER SUPPLIED PROMPT
2ED6  C2 DF2E           	JP NZ,	INP1		;IF NOT, DON'T CHANGE EXISTING ONE
2ED9  CD 3531           	CALL	EXPR		;EVALUATE USER SUPPLIED PROMPT
2EDC  CD 0331           	CALL	PARSE		;SKIP TO NEXT NON-BLANK
2EDF  CD 782A           INP1	CALL	VCHAR		;TEST FOR VALID VARIABLE NAME
2EE2  D5                	PUSH	DE		;SAVE SOURCE POSITION
2EE3  13                	INC	DE		;ADVANCE TO NEXT CHARACTER
2EE4  F5                	PUSH	AF
2EE5  1A                	LD	A, (DE)		;GET NEXT CHARACTER
2EE6  FE 24             	CP	'$'		;TEST FOR CHARACTER INPUT
2EE8  CA 0C2F           	JP Z,	GCHR		;IF SO, GET CHARACTER DATA
2EEB  21 0000           	LD	HL,0		;START WITH A ZERO
2EEE  39                	ADD	HL,SP		;AND GET STACK POINTER. IN CASE WE BLOW UP
2EEF  22 3E82           	LD	(TEMP), HL	;SAVE SO WE CAN GET IT BACK LATER
2EF2  CD A52E           RETRY	CALL	PV1		;DISPLAY USER PROMPT
2EF5  97                	SUB	A		;GET A ZERO
2EF6  32 3582           	LD	(IFLAG), A	;AND CLEAR THE INPUT FLAG (IN CASE HE CTRL-C'S)
2EF9  CD D02A           	CALL	GLINE		;GET A LINE FROM THE TERMINAL
2EFC  32 3582           	LD	(IFLAG), A	;SET IFLAG. (SO GET ERROR, WE CAN COME BACK)
2EFF  CD 3531           	CALL	EXPR		;EVALUATE EXPRESSION
2F02  F1                	POP	AF
2F03  CD E72F           	CALL	STOR		;STASH VALUE IN VARIABLE
2F06  D1                	POP	DE		;RESTORE SOURCE POSITION
2F07  97                	SUB	A		;GET A ZERO
2F08  32 3582           	LD	(IFLAG), A	;AND CLEAR IFLAG
2F0B  C9                	RET
                        ; CHARACTER INPUT
2F0C  CD A52E           GCHR	CALL	PV1		;DISPLAY USER PROMPT
2F0F  CD D02A           	CALL	GLINE		;GET A LINE OF INPUT
2F12  F1                	POP	AF
2F13  CD B52F           	CALL	LTA		;GET THE TEXT VARIABLE'S ADDRESS
2F16  06 23             	LD	B,35		;LENGTH IS 35
2F18  1A                Z1	LD	A, (DE)		;GET CHARACTER FROM INPUT BUFFER
2F19  FE 0D             	CP	CR		;TEST FOR END OF BUFFER
2F1B  CA 282F           	JP Z,	Z2		;IF SO, END THE LINE
2F1E  0B                	DEC	BC		;TEST FOR END OF VARIABLE SPACE
2F1F  CA 282F           	JP Z,	Z2		;IF SO, END THE LINE
2F22  77                	LD	(HL),A		;SAVE IN VARIABLE SPACE
2F23  23                	INC	HL		;NEXT CHARACTER IN VARIABLE
2F24  13                	INC	DE		;NEXT CHARACTER IN INPUT BUFFER
2F25  C3 182F           	JP	Z1		;COPY NEXT CHARACTER
2F28  D1                Z2	POP	DE		;RESTORE SOURCE POSITION
2F29  36 FF             Z3	LD	(HL),0xFF	;PAD BUFFER WITH NULL CHARACTERS
2F2B  23                	INC	HL		;NEXT POSITION IN VARIABLE
2F2C  0B                	DEC	BC		;REDUCE COUNT TILL END
2F2D  F2 292F           	JP P,	Z3		;KEEP GOING TILL VARIABLE IS FILLED
2F30  C9                	RET
                        ;
                        ; LOOK'S LIKE HE CAN'T EVEN ENTER A SIMPLE NUMBER, CLEAN UP ANY STACK
                        ; HE MAY HAVE USED, AND LET HIM TAKE ANOTHER BLIND STAB AT THE KEYBOARD
                        ;
2F31  21 AE35           INERR	LD	HL,IERMS	;GET NASTY MESSAGE
2F34  CD 5700           	CALL	PRINTM		;GIVE HIM THE BAD NEWS
2F37  2A 3E82           	LD	HL, (TEMP)	;GET HIS OLD STACK BACK
2F3A  F9                	LD	SP, HL	
2F3B  C3 F22E           	JP	RETRY		;LET HIM TRY AGAIN
                        ;
                        ; DIMENSION, HE WANTS SOME ARRAY SPACE.. I SUPPOSE WE SHOULD GIVE IT TO HIM
                        ;
2F3E  7B                DIM	LD	A,E		;GET ADDRESS OF OUR POSITION
2F3F  32 3682           	LD	(P), A		;SAVE IN POSITION POINTER
2F42  1A                DIM0	LD	A, (DE)		;GET CHARACTER FROM SOURCE
2F43  13                	INC	DE		;ADVANCE TO NEXT
2F44  FE 0D             	CP	CR		;TEST FOR END OF LINE
2F46  CA 7C2A           	JP Z,	SYNT		;IF SO, TELL HIM TO STRAIGHTEN UP
2F49  FE 29             	CP	')'		;TEST FOR START OF ARRAY DIMENSION
2F4B  C2 422F           	JP NZ,	DIM0		;IF NOT, KEEP LOOKING
2F4E  1B                	DEC	DE		;BACK UP FOR EXPRESSION
2F4F  D5                	PUSH	DE		;SAVE BASIC PROGRAM COUNTER
2F50  CD 3E31           	CALL	DOEXP		;EVALUATE ARRAY SIZE
2F53  23                	INC	HL		;ADD ONE ENTRY (ZERO ENTRY DOES EXIST)
2F54  29                	ADD	HL,HL		;DOUBLE BECAUSE THEY ARE 16 BIT'S
2F55  1B                	DEC	DE		;BACK UP TO NAME
2F56  44                	LD	B,H		;COPY SIZE NEEDED
2F57  4D                	LD	C,L		;INTO B AND C
2F58  2A 3A82           	LD	HL, (LAST)	;GET FREE ADDRESS
2F5B  E5                	PUSH	HL		;SAVE FOR TABLE
2F5C  36 00             DLOOP	LD	(HL),0		;ZERO ARRAY BYTE
2F5E  23                	INC	HL		;ADVANCE TO NEXT
2F5F  0B                	DEC	BC		;REDUCE COUNT
2F60  78                	LD	A,B		;GET HIGH BYTE OF REMAINING TO DO
2F61  B1                	OR	C		;TEST FOR NONE LEFT
2F62  C2 5C2F           	JP NZ,	DLOOP		;IF NOT, KEEP ZEROING
2F65  22 3A82           	LD	(LAST), HL	;SAVE NEXT FREE SPACE INDICATOR
2F68  E1                	POP	HL		;GET ADDRESS OF ARRAY BACK
2F69  1A                	LD	A, (DE)		;GET ARRAY NAME
2F6A  CD 7D2F           	CALL	TABENT		;GET TABLE ENTRY
2F6D  7C                	LD	A,H		;GET HIGH ADDRESS
2F6E  02                	LD	(BC), A		;PLACE IN TABLE
2F6F  03                	INC	BC		;ADVANCE IN TABLE
2F70  7D                	LD	A,L		;GET LOW ADDRESS
2F71  02                	LD	(BC), A		;PLACE IN TABLE
2F72  D1                	POP	DE		;GET SOURCE POSITION BACK
2F73  CD 0331           	CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
2F76  C8                	RET Z
2F77  FE 2C             	CP	','		;TEST FOR ANOTHER OPERAND
2F79  CA 3E2F           	JP Z,	DIM		;IF SO, KEEP GOING
2F7C  97                	SUB	A		;CAUSE A SYNTAX ERROR BECAUSE WE ARE BAD
                        ;
                        ; LOCATES TABLE POSITION OF AN ARRAY
                        ;
2F7D  CD 782A           TABENT	CALL	VCHAR		;INSURE IT'S OK
2F80  D6 41             	SUB	'A'		;CONVERT TO BINARY
2F82  87                	ADD	A,A		;X 2 FOR TWO BYTE ENTRIES
2F83  4F                	LD	C,A		;SAVE IN C
2F84  3A FD81           	LD	A, (ARYLOC)	;GET ARRAY PAGE
2F87  47                	LD	B,A		;SAVE IN HIGH ZBYTE
2F88  C9                	RET
                        ; LOOKS UP AN ARRAY VALUE
2F89  CD 3E31           ALOOK	CALL	DOEXP		;CALCULATE INDEX VALUE
2F8C  1B                	DEC	DE		;BACK UP PAST '['
2F8D  1A                	LD	A, (DE)		;GET VARIABLE NAME
2F8E  CD 9E2F           	CALL	LOOKT		;FIND ADDRESS OF ENTRY
2F91  46                	LD	B,(HL)		;GET HIGH BYTE OF ENTRY
2F92  23                	INC	HL		;ADVANCE TO LOW BYTE
2F93  4E                	LD	C,(HL)		;GET LOW BYTE OF ARRAY ENTRY
2F94  60                	LD	H,B		;TRANSFER RESULT TO .
2F95  69                	LD	L,C		;H AND L WHERE THEY ARE EXPECTED
2F96  1A                	LD	A, (DE)		;GET VARIABLE NAME BACK
2F97  FE 40             	CP	'@'		;TEST FOR MAGIC 'PEEK' ARRAY
2F99  C0                	RET NZ			;IF NOT, WE ARE OK
2F9A  6C                	LD	L,H		;SET VALUE TO THAT OF FIRST BYTE
2F9B  26 00             	LD	H,0		;AND ELIMINATE HIGH BYTE
2F9D  C9                	RET
                        ;
                        ; LOCATES ADDRESS OF AN ARRAY ENTRY IN THE ARRAY TABLE. INDEX IN HL
                        ;
2F9E  FE 40             LOOKT	CP	'@'		;TEST FOR SPECIAL CASE
2FA0  C8                	RET Z			;IF SO, PEEK AT ADDRESS
2FA1  CD 7D2F           	CALL	TABENT		;LOCATE TABLE ENTRY
2FA4  D5                	PUSH	DE		;SAVE BASIC PROGRAM COUNTER
2FA5  0A                	LD	A, (BC)		;GET FIRST BYTE
2FA6  57                	LD	D,A		;COPY TO HIGH BYTE
2FA7  03                	INC	BC		;ADVANCE TO NEXT
2FA8  0A                	LD	A, (BC)		;GET LOW BYTE
2FA9  5F                	LD	E,A		;COPY TO D
2FAA  29                	ADD	HL,HL		;X TWO FOR TWO BYTE ENTRIES
2FAB  19                	ADD	HL,DE		;ADD IN OFFSET FOR START OF ARRAY
2FAC  B2                	OR	D		;TEST FOR ADDRESS OF ZERO, = NOT DIMENSIONED
2FAD  D1                	POP	DE		;RESTORE PROGRAM COUNTER
2FAE  C0                	RET NZ			;NOT A DIMENSION ERROR, GO BACK
                        ;
                        ; EITHER HE'S TRIED TO INDEX A NON-ARRAY VARIABLE, TRIED TO INDEX A CHARACTER
                        ; VARIABLE WITH A VALUE GREATER THEN 34, OR HE'S PLOTTED OUTSIDE OF THE SCREEN
                        ; NO MATTER WHAT HE'S DONE, GIVE HIM A NASTY MESSAGE SO HE WON'T DO IT AGAIN
                        ;
2FAF  21 F635           DIMERR	LD	HL,OVM		;ADDRESS OF NASTY MESSAGE
2FB2  C3 802A           	JP	ERR		;GIVE IT TO HIM
                        ; LOCATES THE ADDRESS OF A CHARACTER (TEXT) VARIABLE
2FB5  D6 41             LTA	SUB	0x41		;REDUCE TO SIMPLE BINARY
2FB7  FE 1A             	CP	26		;TEST FOR VALID VARIABLE
2FB9  D2 7C2A           	JP NC,	SYNT		;IF NOT, GET MAD
2FBC  21 1982           	LD	HL,VARS+25	;START OF CHARACTER VARIABLES (-37)
2FBF  01 2500           	LD	BC,37		;LENGTH OF CHARACTER VARIABLES
2FC2  09                V1	ADD	HL,BC		;OFFSET INTO TABLE
2FC3  3D                	DEC	A		;REDUCE VARIABLES WE HAVE TO GO
2FC4  F2 C22F           	JP P,	V1		;IF NOT FINISHED, KEEP OFFSETING
2FC7  C9                	RET
                        ;
                        ; IT'S A 'USR' COMMAND, FIND OUT WHAT HE WANT'S, PASS CONTROL  TO
                        ; HIS MACHINE LANGUAGE ROUTINE, AND GOD HELP HIM IF HE SCREW'S UP
                        ; BECAUSE WE CAN'T DO ANYTHING FOR HIM UNTIL HE RETURNS
                        ;
2FC8  21 DD2F           USR	LD	HL,URET		;GET ON STACK (SO HE CAN 'RET' TO IT)
2FCB  E5                	PUSH	HL		;SAVE IN MACHINE STACK
2FCC  CD 3531           	CALL	EXPR		;EVALUATE ADDRESS
2FCF  E5                	PUSH	HL		;SAVE ON STACK (SO WE CAN 'RET' TO IT)
2FD0  1A                	LD	A, (DE)		;GET NEXT CHARACTER
2FD1  FE 2C             	CP	','		;TEST FOR MORE PARAMETERS
2FD3  C2 DA2F           	JP NZ,	CSAV		;IF NOT, DONT EVALUATE
2FD6  13                	INC	DE		;SKIP THE ','
2FD7  CD 3531           	CALL	EXPR		;EVALUATE PARAMETER TO PASS
                        ; WHEN 'PUSHD' RETURNS, IT WILL EFFECT A JUMP TO HIS CODE
2FDA  C3 BD2D           CSAV	JP	PUSHD		;SAVE PROGRAM POSITION
                        ; IF WE GET HERE, HE MADE IT BACK IN ONE PIECE
2FDD  CD C72D           URET	CALL	POPD		;GET PROGRAM COUNTER BACK
2FE0  1A                	LD	A, (DE)		;GET CHARACTER FROM SOURCE
2FE1  FE 2C             	CP	','		;TEST FOR VARIABLE TO RECEIVE H-L
2FE3  C0                	RET NZ			;IF NOT, WE ARE DONE
2FE4  CD 0331           	CALL	PARSE		;KEEP LOOKING
                        ;
                        ; STORES H-L INTO A INTEGER VARIABLE PASSED IN A
                        ;
2FE7  06 82             STOR	LD	B,HIGH VARS	;GET ADDRESS OF VARIABLE TABLE
2FE9  D6 41             	SUB	0x41		;CONVERT TO BINARY
2FEB  FE 1A             	CP	26		;TEST FOR VALID VARIABLE NAME
2FED  D2 7C2A           	JP NC,	SYNT		;IF NOT, IT'S INVALID
2FF0  87                	ADD	A,A		;DOUBLE BECAUSE THEY ARE 16 BIT ENTRIES
2FF1  4F                	LD	C,A		;PLACE IN C, MAKING COMPLETE ADDRESS
2FF2  7D                	LD	A,L		;GET LOW VALUE TO SAVE
2FF3  02                	LD	(BC), A		;SAVE IN VARIABLE
2FF4  03                	INC	BC		;NEXT BYTE OF VARIABLE
2FF5  7C                	LD	A,H		;GET HIGH BYTE
2FF6  02                	LD	(BC), A		;SAVE IN VARIABLE
2FF7  C9                	RET
                        ;
                        ; RETERIVES CONTENTS OF A VARIABLE
                        ;
2FF8  06 82             LOOK	LD	B,HIGH VARS	;ADDRESS OF VARIABLES
2FFA  D6 41             	SUB	'A'		;CONVERT NAME TO BINARY
2FFC  87                	ADD	A,A		;DOUBLE FOR 16 BIT ENTRIES
2FFD  4F                	LD	C,A		;MAKE COMPLETE ADDRESS
2FFE  0A                	LD	A, (BC)		;GET LOW BYTE
2FFF  6F                	LD	L,A		;PLACE IN L
3000  03                	INC	BC		;NEXT BYTE OF VARIABLE
3001  0A                	LD	A, (BC)		;GET HIGH BYTE
3002  67                	LD	H,A		;PLACE IN H
3003  C9                	RET
                        ;
                        ; IT'S AN 'ORDER', (HE THINKS HE KNOWS WHERE THERE IS SOME DATA)
                        ;
3004  D5                ORDER	PUSH	DE		;SAVE OUR SOURCE POSITION
3005  CD 192C           	CALL	FNDLIN		;GET ADDRESS OF THE LINE HE WANTS
3008  D1                	POP	DE		;RESTORE OUR POSITION
3009  D5                	PUSH	DE		;AND RESAVE OUR POSITION
300A  C2 682D           	JP NZ,	BADLIN		;IF IT DOSN'T EXIST, THEN FORGET IT
300D  23                	INC	HL		;SKIP FIRST TWO DIGITS OF LINE NUMBER
300E  23                	INC	HL		;SKIP LAST TWO DIGITS OF LINE NUMBER
300F  23                	INC	HL		;SKIP LENGTH BYTE
3010  EB                	EX	DE, HL	
3011  CD 9430           	CALL	VERDAT		;GET STATEMENT FROM LINE
3014  22 3882           	LD	(DATA), HL	;SAVE DATA POINTER
3017  D1                	POP	DE		;RESTORE OUR LINE, (SO WE CAN TELL HIM)
3018  C8                	RET Z
                        ;
                        ; DATA ERROR... ATTEMPT TO READ FROM A LINE WITHOUT 'DATA' OR
                        ; ATTEMPT TO READ THE WRONG DATA TYPE. LET HIM IN ON IT
                        ;
3019  21 F135           DERR	LD	HL,DTXT		;ADDRESS OF 'DATA' MESSAGE
301C  C3 7F2A           	JP	SYNT+3		;DISPLAY IT
                        ;
                        ; IT'S A READ. (HE WANTS TO KNOW WHATS IN THAT DATA WE FOUND)
                        ;
301F  CD 782A           READ	CALL	VCHAR		;IS IT A VALID VARIABLE
3022  F5                	PUSH	AF
3023  13                	INC	DE		;ADVANCE TO NEXT CHARACTER
3024  1A                	LD	A, (DE)		;GET NEXT CHARACTER
3025  FE 24             	CP	'$'		;IS IT A CHARACTER VARIABLE?
3027  CA 3730           	JP Z,	CDAT		;IF SO, LOOK FOR CHARACTER DATA
                        ; NUMERIC DATA, FOR NUMERIC VARIABLE
302A  CD 5D30           	CALL	GETDAT		;GET NUMERIC DATA
302D  DA 1930           	JP C,	DERR		;IF CHARACTER, IT A DATA TYPE ERROR
3030  F1                	POP	AF
3031  CD E72F           	CALL	STOR		;STASH VALUE IN IT
3034  C3 5130           	JP	MORDAT		;SEE IF HE WANT'S MORE DATA
                        ; CHARACTER DATA, FOR CHARACTER VARIABLE
3037  13                CDAT	INC	DE		;SKIP DOLLAR SIGN
3038  CD 5D30           	CALL	GETDAT		;GET DATA
303B  D2 1930           	JP NC,	DERR		;IF NUMERIC, IT'S BAD
303E  F1                	POP	AF
303F  CD B52F           	CALL	LTA		;FIND IT'S ADDRESS
3042  01 6480           	LD	BC,XBF		;DATA IS IN EXTRA BUFFER
3045  D5                	PUSH	DE		;SAVE SOURCE POSITION
3046  1E 23             	LD	E,35		;MOVE 35 CHARACTERS
3048  0A                SL1	LD	A, (BC)		;GET CHARACTER FROM BUFFER. (DATA)
3049  77                	LD	(HL),A		;STASH IT IN THE VARIABLE
304A  03                	INC	BC		;SKIP TO THE NEXT CHARACTER IN THE BUFFER
304B  23                	INC	HL		;SKIP TO THE NEXT POSITION IN VARIABLE
304C  1D                	DEC	E		;REDUCE COUNT OF HOW MANY TO MOVE
304D  C2 4830           	JP NZ,	SL1		;IF NOT FINISHED, KEEP COPYING
3050  D1                	POP	DE		;RESTORE SOURCE POSITION
                        ; LOOK FOR MORE VARIABLES (OPERANDS) IN THE 'READ' STATEMENT
3051  CD 0431           MORDAT	CALL	PARSE1		;FIND NEXT NON-BLANK
3054  FE 2C             	CP	','		;IF COMMA..
3056  C0                	RET NZ			;IF NOT, WE HAVE ALL THERE IS
3057  CD 0331           	CALL	PARSE		;SKIP COMMA AND FIND VARIABLE NAME
305A  C3 1F30           	JP	READ		;GET MORE DATA FOR FOLLOWING VARIABLE
                        ; GETS DATA FROM THE DATA STATEMENTS, POINTED TO BY THE CURRENT READ POINTER
305D  2A 3882           GETDAT	LD	HL, (DATA)	;GET DATA POINTER
3060  7C                	LD	A,H		;SEE IF IT IS ZERO.
3061  B5                	OR	L		;WHICH INDICATES THAT IT WASN'T INITIALIZED
3062  CA 1930           	JP Z,	DERR		;IF SO, IT'S A DATA ERROR
3065  D5                	PUSH	DE		;SAVE SOURCE POSIITION
3066  EB                	EX	DE, HL	
3067  CD 3531           	CALL	EXPR		;EVALUATE THE DATA EXPRESSION
306A  F5                	PUSH	AF
306B  1A                ENDAT	LD	A, (DE)		;GET NEXT CHARACTER FROM THE SOURCE
306C  FE 2C             	CP	','		;TEST FOR MORE DATA
306E  CA 8B30           	JP Z,	COMA		;IF SO, WE ARE OK
3071  FE 3A             	CP	':'		;TEST FOR END OF STATEMENT
3073  CA 7E30           	JP Z,	DAT1		;GO TO NEXT DATA STATEMENT
3076  13                	INC	DE		;ADVANCE ONE CHARACTER
3077  FE 0D             	CP	CR		;CARRIAGE RETURN?
3079  C2 6B30           	JP NZ,	ENDAT		;KEEP LOOKING IF NOT
                        ; HIT THE END OF A LINE, SKIP TO NEXT DATA STATEMENT
307C  13                	INC	DE		;SKIP FIRST TWO DIGITS
307D  13                	INC	DE		;SKIP SECOND TWO DIGITS
307E  13                DAT1	INC	DE		;SKIP LENGTH (OR ':' IF STMT)
307F  E5                	PUSH	HL		;SAVE H-L REG
3080  CD 9430           	CALL	VERDAT		;CHECK FOR DATA STATEMENT
3083  EB                	EX	DE, HL	
3084  E1                	POP	HL		;RESTORE REGISTERS
3085  CA 8C30           	JP Z,	GDEND		;RETURN, WITH NEW DATA POINTER
3088  11 FFFF           	LD	DE,0xFFFF	;INDICATE NO MORE DATA STATEMENTS
308B  13                COMA	INC	DE		;SKIP THE COMMA
308C  EB                GDEND	EX	DE, HL	
308D  22 3882           	LD	(DATA), HL	;SAVE IN POINTER
3090  EB                	EX	DE, HL	
3091  F1                	POP	AF
3092  D1                	POP	DE		;GET SOURCE POSITION BACK
3093  C9                	RET
                        ;
                        ; VERIFY THAT COMMAND WAS 'DATA'
                        ;
3094  CD 0431           VERDAT	CALL	PARSE1		;SKIP TO COMMAND
3097  EB                	EX	DE, HL	
3098  11 1735           	LD	DE,DATCMD	;POINT TO DATA COMMAND
309B  7B                VER1	LD	A,E		;GET LOW ADDRESS
309C  FE 1B             	CP	DATCMD+4	;ARE WE AT END
309E  C8                	RET Z
309F  1A                	LD	A, (DE)		;GET CHR FROM TABLE
30A0  13                	INC	DE		;ADVANCE TO NEXT
30A1  E6 7F             	AND	0x7F		;INSURE IT'S CORRECT
30A3  BE                	CP	(HL)		;DUZ IT MATCH?
30A4  23                	INC	HL		;NEXT IN DATA COMMAND
30A5  CA 9B30           	JP Z,	VER1		;OK, TEST NEXT
30A8  C9                	RET
                        ;
                        ; HE WANT'S TO KNOW HOW BIG IT IS... LETS FIGURE IT OUT AND LET HIM IN ON IT
                        ;
30A9  D5                SIZE	PUSH	DE		;SAVE PROGRAM POINTER
30AA  CD BB30           	CALL	GETEOF		;FIND THE END OF THE FILE
30AD  01 007A           	LD	BC,0-TEXT	;GET THE (NEGATIVE) FILE START ADDRESS
30B0  09                	ADD	HL,BC		;SUBTRACT FILE START FROM FILE END
30B1  CD B22E           	CALL	DECPRT		;DISPLAY VALUE IN DECIMAL
30B4  21 4436           	LD	HL,SIMSG	;GET ' BYTES' MESSAGE
30B7  D1                	POP	DE		;RESTORE PROGRAM POINTER
30B8  C3 5700           	JP	PRINTM		;TELL HIM WHAT IT IS
                        ; FINDS THE END OF THE FILE, HL=LAST BYTE OF PGM., A=FIRST FREE PAGE
30BB  21 0086           GETEOF	LD	HL,TEXT		;START AT THE BEGINING
30BE  3E FF             	LD	A,255		;LOOKING FOR AN FF
30C0  BE                GLPX	CP	(HL)		;IS THIS IT?
30C1  23                	INC	HL		;ADVANCE TO NEXT
30C2  C2 C030           	JP NZ,	GLPX		;IF NOT IT, KEEP LOOKING
30C5  2B                	DEC	HL		;POINT BACK TO 0xFF
30C6  7C                	LD	A,H		;GET HIGH VALUE
30C7  3C                	INC	A		;ADVANCE TO NEXT PAGE
30C8  C9                	RET
                        ;
                        ; HE'S TRYING TO 'LOAD' SOMETHING, I WONDER IF HE HAS SOMETHING SAVED..
                        ;
30C9                    LOAD	;CALL	TON		;TURN ON TAPE AND WAIT
30C9                    LOD1	;CALL	GETR		;GET A RECORD
                        	;JP C,	LOD1		;KEEP GOING TILL WE HAVE IT ALL
                        	;CALL	TOFF		;SHUT TAPE OFF
30C9  C3 1A2A           	JP	RESV		;CLEAR VARIABLES AND GET A NEW COMMAND
                        ;
                        ; HE'S TRYING TO 'SAVE' SOMETHING..
                        ;
30CC  D5                SAVE	PUSH	DE		;SAVE PROGRAM POINTER
30CD  11 0086           	LD	DE,TEXT		;GET ADDRESS OF TEXT
30D0  1A                	LD	A, (DE)		;GET FIRST BYTE
30D1  3C                	INC	A		;TEST FOR NO PROGRAM
30D2  CA EC2C           	JP Z,	RUN		;IF SO, RUN WILL ABORT WITH ERROR
30D5  CD BB30           	CALL	GETEOF		;GET ENDING ADDRESS
                        	;CALL	TDUMP		;DUMP PROGRAM AND RETURN
30D8  D1                	POP	DE		;RESTORE PROGRAM POINTER
30D9  C9                	RET
                        ;
                        ;****************************************************************
                        ;                 EXPRESSION EVALUATION CODE
                        ;****************************************************************
                        ;
                        ; EVALUATES 16 BIT DECIMAL NUMBERS
                        ;
30DA  01 0100           EVAL	LD	BC,1		;MULTIPLIER IS ONE
30DD  60                	LD	H,B		;INITIALIZE
30DE  68                	LD	L,B		;STARTING RESULT TO ZERO
30DF  1A                ETOP	LD	A, (DE)		;GET DIGIT FROM SOURCE
30E0  CD C62A           	CALL	NUM		;TEST FOR INVALID DIGIT
30E3  D8                	RET C			;IF SO, WE ARE FINISHED
30E4  E6 0F             	AND	0x0F		;CONVERT TO BINARY
                        ; ADD DIGIT TIMES MULTIPLIER IN B-C TO H-L
30E6  3D                ZLOOP	DEC	A		;REDUCE BY ONE
30E7  FA EE30           	JP M,	ESP1		;BEXIT WHEN EXAUSTED
30EA  09                	ADD	HL,BC		;ADD MULTIPLIER
30EB  C3 E630           	JP	ZLOOP		;CONTINUE TILL DONE
                        ; MULTIPLY MULTIPLIER (BC) BY 10
30EE  E5                ESP1	PUSH	HL		;SAVE H-L
30EF  60                	LD	H,B		;GET B-C INTO
30F0  69                	LD	L,C		;H-L SO WE CAN USE 'DAD'
30F1  09                	ADD	HL,BC		;BC=BC*2
30F2  29                	ADD	HL,HL		;BC=BC*4
30F3  09                	ADD	HL,BC		;BC=BC*5
30F4  29                	ADD	HL,HL		;BC=BC*10
30F5  44                	LD	B,H		;SAVE BACK INTO
30F6  4D                	LD	C,L		;B-C REGISTER PAIR
30F7  E1                	POP	HL		;RESTORE H-L
30F8  1B                	DEC	DE		;REDUCE POINTER IN SOURCE
30F9  C3 DF30           	JP	ETOP		;EVALUATE NEXT CHARACTER
                        ;
                        ; SUBROUTINE TESTS FOR VALID ASCII CHARACTERS
                        ;
30FC  FE 41             CHAR	CP	'A'		;TEST FOR < 'A'
30FE  D8                	RET C			;RETURN SAYING IT'S BAD
30FF  FE 5B             	CP	'Z'+1		;TEST FOR >'Z'
3101  3F                	CCF			;INVERT LOGIC
3102  C9                	RET
                        ;
                        ; PARSES FORWARD, SEARCHING FOR FIRST NON-BLANK CHARACTER
                        ;
3103  13                PARSE	INC	DE		;ADVANCE IN SOURCE
3104  1A                PARSE1	LD	A, (DE)		;GET CHARACTER FROM SOURCE
3105  FE 20             	CP	' '		;TEST FOR SPACE
3107  28 FA             	JR Z,	PARSE		;KEEP LOOKING
3109  FE 3A             	CP	':'		;TEST FOR END OF STATEMENT
310B  C8                	RET Z			;IF SO, RETURN WITH Z SET
310C  FE 0D             	CP	CR		;TEST FOR END OF LINE
310E  C9                	RET
                        ;
                        ; SKIPS TO NEXT EXPRESSION OR COMMAND
                        ;
310F  CD 0431           SKIP	CALL	PARSE1		;ADVANCE TO NEXT NON-BLANK
3112  1B                	DEC	DE		;BACK UP TO POSITION
3113  7B                	LD	A,E		;GET LOW ORDER ADDRESS
3114  32 3682           	LD	(P), A		;SAVE IN POSITION BYTE
                        ; LOOK FOR DELIMITER
3117  13                SKIP1	INC	DE		;ADVANCE TO NEXT
3118  1A                	LD	A, (DE)		;GET CHARACTER
3119  FE 3A             	CP	':'		;TEST FOR DELIMITER
311B  C8                	RET Z			;IF SO, RETURN
311C  FE 2C             	CP	','		;TEST FOR DELIMITER
311E  C8                	RET Z			;IF SO, RETURN
311F  FE 0D             	CP	CR		;TEST FOR DELIMITER
3121  C8                	RET Z			;IF SO, RETURN
3122  FE 22             	CP	'"'		;TEST FOR QUOTE
3124  CC 2931           	CALL Z,	SKPQUO		;IF SO, ADVANCE TO NEXT QUOTE
3127  18 EE             	JR	SKIP1		;KEEP LOOKING
                        ; FIND NEXT QUOTE IN SOURCE
3129  13                SKPQUO	INC	DE		;ADVANCE TO NEXT CHARACTER IN SOURCE
312A  1A                	LD	A, (DE)		;GET THE CHARACTER
312B  FE 22             	CP	'"'		;IS IT A QUOTE?
312D  C8                	RET Z			;IF SO, WE FOUND IT
312E  FE 0D             	CP	CR		;IF IT A CARRIAGE RETUEN
3130  20 F7             	JR NZ,	SKPQUO		;IF NOT, OK
3132  C3 7C2A           	JP	SYNT		;UNMATCHED QUOTES WHILE PARSING
                        ;
                        ; EVALUATES AN EXPRESSION POINTED TO BY D-E. RETURN WITH CARRY SET
                        ; INDICATES THAT EXPRESSION WAS A CHARACTER EXPRESSION
                        ;
3135  CD 0F31           EXPR	CALL	SKIP		;ADVANCE TO END OF EXPRESSION
3138  D5                	PUSH	DE		;SAVE POINTER TO END
3139  CD 3E31           	CALL	DOEXP		;EVALUATE
313C  D1                	POP	DE		;RESTORE POINTER TO END OF EXPRESSION
313D  C9                	RET
                        ; CALCULATES EXPRESSION BACKWARDS (LIKE APL)
313E  1B                DOEXP	DEC	DE		;BACK UP IN SOURCE
313F  CD A033           	CALL	FE		;GET CHARACTER FROM SOURCE
3142  FE 24             	CP	'$'		;TEST FOR CHARACTER VARIABLE
3144  CA CC33           	JP Z,	CEXP		;IF SO, ITS A CHARACTER EXPRESSION
3147  FE 22             	CP	'"'		;TEST FOR QUOTE
3149  CA CC33           	JP Z,	CEXP		;IF SO, IT'S A CHARACTER EXRESSION
314C  13                	INC	DE		;ADVANCE
314D  3E 3B             	LD	A,';'		;NULL OPERATOR TO START
314F  E5                EGO1	PUSH	HL		;SAVE OLD VALUE
3150  F5                	PUSH	AF
3151  1B                	DEC	DE		;BACK UP TO VALUE
3152  CD A033           	CALL	FE		;GET CHARACTER FROM SOURCE
3155  FE 29             	CP	')'		;TEST FOR BRACKET
3157  CA B931           	JP Z,	BRKTS		;IF SO, RECURSE
315A  FE 5D             	CP	']'		;TEST FOR ARRAY LOOKUP
315C  CA BF31           	JP Z,	ARYL		;IF SO, LOOK UP ARRAY VALUE
315F  CD FC30           	CALL	CHAR		;TEST FOR VARIABLE
3162  D2 C931           	JP NC,	LOOKU		;IF SO, LOOK IT UP
3165  FE 3F             	CP	'?'		;TEST FOR RANDOM NUMBER RETERIVAL
3167  CA AD33           	JP Z,	RANDR		;GET RANDOM VALUE
316A  FE 23             	CP	'#'		;TEST FOR HEX CONSTANT
316C  CA 7B31           	JP Z,	HEXVL		;IF SO, GET HEV VALUE
316F  CD C62A           	CALL	NUM		;TEST FOR A NUMBER
3172  DA 7C2A           	JP C,	SYNT		;IF NOT, I DON'T KNOW WHAT HE'S DOING
                        ; DECIMAL NUMBER
3175  CD DA30           CALN	CALL	EVAL		;EVALUATE DECIMAL NUMBER
3178  C3 CD31           	JP	OLOOK		;LOOK FOR OPERATOR
                        ; HEX. NUMBER
317B  1B                HEXVL	DEC	DE		;BACK UP IN SOURCE
317C  3A 3682           	LD	A, (P)		;GET ENDING POSITION
317F  BB                	CP	E		;TEST FOR PASSED THE LIMIT
3180  CA 9131           	JP Z,	HEXGO		;IF SO, THATS IT
3183  1A                	LD	A, (DE)		;GET CHARACTER FROM SOURCE
3184  CD C62A           	CALL	NUM		;TEST FOR VALID DIGIT
3187  D2 7B31           	JP NC,	HEXVL		;KEEP GOING TILL WE GET TO START OF STRING
318A  D6 41             	SUB	'A'		;TEST FOR VALID LETTER
318C  FE 06             	CP	6		;OF 'A' TO 'F'
318E  DA 7B31           	JP C,	HEXVL		;IF SO, KEEP LOOKING
3191  21 0000           HEXGO	LD	HL,0		;START WITH A ZERO
3194  44                	LD	B,H		;FLAG TO SEE IF ANY DIGITS
3195  D5                	PUSH	DE		;SAVE POSITION IN SOURCE
3196  13                GETHX	INC	DE		;ADVANCE TO NEXT DIGIT OF HEX NUMBER
3197  1A                	LD	A, (DE)		;GET DIGIT
3198  FE 23             	CP	'#'		;TEST FOR END OF STRING
319A  CA B031           	JP Z,	HGON		;IF SO, WE ARE DONE
319D  47                	LD	B,A		;SET FLAG SO WE KNOW WE GOT AT LEAST ONE DIGIT
319E  29                	ADD	HL,HL		;SHIFT H-L
319F  29                	ADD	HL,HL		;RIGHT IN ORDER
31A0  29                	ADD	HL,HL		;TO MAKE ROOM FOR
31A1  29                	ADD	HL,HL		;THE NEW DIGIT
31A2  D6 30             	SUB	'0'		;REDUCE TO BINARY
31A4  FE 0A             	CP	10		;TEST FOR FURTHER REDUCTION NEEDED
31A6  DA AB31           	JP C,	HISG		;IF NOT, PROCESS
31A9  D6 07             	SUB	7		;CONVERT LETTER TO BINARY
31AB  B5                HISG	OR	L		;ADD IN BOTTOM DIGIT OF RESULT
31AC  6F                	LD	L,A		;REPLACE IN RESULT
31AD  C3 9631           	JP	GETHX		;GET NEXT DIGIT
31B0  D1                HGON	POP	DE		;GET POSITION IN SOURCE BACK
31B1  78                	LD	A,B		;GET FLAG
31B2  A7                	AND	A		;TEST FOR DIGIT'S PROCESSED
31B3  C2 CD31           	JP NZ,	OLOOK		;NO PROBLEM
31B6  C3 7C2A           	JP	SYNT		;'#' WITH NO DIGITS... ERROR
                        ; A ')' HAS BEEN DETECTED
31B9  CD 3E31           BRKTS	CALL	DOEXP		;RECURSE ON OURSELVES
31BC  C3 CC31           	JP	DCLB		;CONTINUE WITH VALUE
                        ; LOOK UP AN ARRAY VALUE
31BF  F1                ARYL	POP	AF
31C0  F5                	PUSH	AF
31C1  FE 3D             	CP	'='		;TEST FOR ASSIGNMENT
31C3  C4 892F           	CALL NZ, ALOOK		;IF NOT, GET VALUE
31C6  C3 CC31           	JP	DCLB		;CONTINUE WITH VALUE
                        ; GET VARIABLE CONTENTS
31C9  CD F82F           LOOKU	CALL	LOOK		;LOOK UP VALUE OF VARIABLE
31CC  1B                DCLB	DEC	DE		;BACK UP IN SOURCE
31CD  F1                OLOOK	POP	AF
31CE  C1                	POP	BC		;GET OLD VALUE BACK
                        ; 16 BIT ADDITION
31CF  FE 2B             	CP	'+'		;TEST FOR ADDITION
31D1  CA E031           	JP Z,	ADD		;IF SO, PERFORM ADD
                        ; SIXTEEN BIT SUBTRACTION
31D4  FE 2D             	CP	'-'		;TEST FOR SUBTRACTION
31D6  C2 E431           	JP NZ,	MULT		;NO, TRY MULTIPLICATION
31D9  78                	LD	A,B		;GET B
31DA  2F                	CPL			;COMPLEMENT
31DB  47                	LD	B,A		;RESAVE
31DC  79                	LD	A,C		;GET C
31DD  2F                	CPL			;COMPLEMENT
31DE  4F                	LD	C,A		;RESAVE
31DF  03                	INC	BC		;ADD 1 GIVING TWO'S COMPLEMENT
31E0  09                ADD	ADD	HL,BC		;ADD TO NEW VALUE
31E1  C3 4333           	JP	EGO		;CONTINUE
                        ; 16 BIT MULTIPLICATION
31E4  FE 2A             MULT	CP	'*'		;TEST FOR MULTIPLY
31E6  C2 1332           	JP NZ,	DIV		;NO, TRY DIVIDE
31E9  78                	LD	A,B		;TEST OLD VALUE FOR ZERO
31EA  B1                	OR	C		;AS IT IS A
31EB  CA 4033           	JP Z,	EGZ		;SPECIAL CASE
31EE  CD F431           	CALL	DMULT		;PERFORM THE MULTIPLY
31F1  C3 4333           	JP	EGO		;AND CONTINUE
                        ; MULTIPLY SUBROUTINE (ALSO USED BY RANDOM NUMBER GENERATOR)
31F4  D5                DMULT	PUSH	DE		;SAVE POSITION IN SOURCE
31F5  11 0000           	LD	DE,0		;START OUT WITH A ZERO
31F8  A7                MUL1	AND	A		;INSURE CARRY CLEAR
31F9  78                	LD	A,B		;GET B
31FA  1F                	RRA			;ROTATE
31FB  47                	LD	B,A		;RESAVE
31FC  79                	LD	A,C		;GET C
31FD  1F                	RRA			;ROTATE WITH CARRY
31FE  4F                	LD	C,A		;REPLACE
31FF  F5                	PUSH	AF
3200  B0                	OR	B		;TEST FOR B-C = ZER0
3201  CA 0F32           	JP Z,	MEXIT		;IF SO, WE ARE DONE
3204  F1                	POP	AF
3205  D2 0B32           	JP NC,	NOMAD		;NO ONE BIT, DON'T ADD
3208  EB                	EX	DE, HL	
3209  19                	ADD	HL,DE		;ADD TO D-E
320A  EB                	EX	DE, HL	
320B  29                NOMAD	ADD	HL,HL		;SHIFT H-L RIGHT BY ONE BIT
320C  C3 F831           	JP	MUL1		;KEEP GOING
320F  19                MEXIT	ADD	HL,DE		;ADD RESULT
3210  F1                	POP	AF
3211  D1                	POP	DE		;RESTORE SOURCE POSITION
3212  C9                	RET
                        ; 16 BIT DIVISION
3213  FE 25             DIV	CP	'%'		;TEST FOR DIVIDE
3215  C2 6B32           	JP NZ,	FLOR		;NO, TRY FLOR
3218  78                	LD	A,B		;TEST FOR AN OLD
3219  B1                	OR	C		;VALUE OF ZERO,
321A  CA 5F32           	JP Z,	DIVZE		;BECAUSE THAT IS  A BAD THING
321D  D5                	PUSH	DE		;SAVE SOURCE POSITION
321E  CD 2932           	CALL	DODIV		;PERFORM DIVIDE OPERATION
3221  22 2282           	LD	(VARS+34), HL	;SET 'R' REMAINDER VARIABLE
3224  EB                	EX	DE, HL	
3225  D1                	POP	DE		;RESTORE SOURCE POSITION
3226  C3 4333           	JP	EGO		;AND CARRY ON
                        ;
                        ; PERFORMS 16 BIT(HL) BY 16 BIT(BC) DIVIDE, RESULT IN DE, REM IN HL
                        ;
3229  78                DODIV	LD	A,B		;GET CONTENTS OV B
322A  2F                	CPL			;INVERT
322B  47                	LD	B,A		;REPLECE
322C  79                	LD	A,C		;GET CONTENTS IN C
322D  2F                	CPL			;INVERT
322E  4F                	LD	C,A		;REPLACE
322F  03                	INC	BC		;COMPLETE TWO COMPLEMENT OPERATION
3230  EB                	EX	DE, HL	
3231  21 0000           	LD	HL,0		;ZERO HIGHER HALF
3234  CD 3732           	CALL	DIVBYT		;PERFORM FIRST HALF
3237  7A                DIVBYT	LD	A,D		;GET UPPER HALF
3238  53                	LD	D,E		;SAVE LOWER HALF
3239  1E 08             	LD	E,8		;GET LOOP COUNT
323B  29                DIVTOP	ADD	HL,HL		;SHIFT LEFT
323C  DA 5332           	JP C,	OVER1		;OVERFLOWED
323F  87                	ADD	A,A		;SHIFT  RESULT
3240  D2 4432           	JP NC,	SUBB		;IF NO CARRY, DON'T INC
3243  23                	INC	HL		;ADVANCE UPPER VALUE
3244  E5                SUBB	PUSH	HL		;SAVE VALUE
3245  09                	ADD	HL,BC		;SUBTRACT LOWER HALF OF FRACTION
3246  DA 4D32           	JP C,	OKKK		;IF WRAP PAST ZERO
3249  E1                	POP	HL		;RESTORE VALUE
324A  C3 5932           	JP	NXLP		;FINISH LOOP
324D  33                OKKK	INC	SP		;FIX UP
324E  33                	INC	SP		;STACK
324F  3C                	INC	A		;ADVANCE RESULT
3250  C3 5932           	JP	NXLP		;FINISH LOOP
3253  8F                OVER1	ADC	A,A		;SHIFT RESULT, +1 FOR CARRY
3254  D2 5832           	JP NC,	OVRSUB		;IF NO WRAP
3257  23                	INC	HL		;INC. VALUE
3258  09                OVRSUB	ADD	HL,BC		;SUBTRACT LOWER
3259  1D                NXLP	DEC	E		;REDUCE LOOP COUNTER
325A  C2 3B32           	JP NZ,	DIVTOP		;LOOP IF NOT FINISHED
325D  5F                	LD	E,A		;LOWER BYTE OF RESULT
325E  C9                	RET
                        ;
                        ; HE SHOULD KNOW THAT HE CAN'T DIVIDE BY ZERO, BUT JUST IN CASE...
                        ; WE WILL TELL HIM ANYWAY
                        ;
325F  21 9F35           DIVZE	LD	HL,DER		;ADDRESS OF 'DIVIDE BYE ZERO MESSAGE'
3262  C3 802A           	JP	ERR		;HANDLE LIKE ANY OTHER ERROR
                        ; COMPARES H-L TO B-C, Z=1 IF HL=BC, C=1 IF HL<BC
3265  7C                COMP	LD	A,H		;GET HIGH BYTE OF HL
3266  B8                	CP	B		;COMPARE WITH HIGH BYTE OF BC
3267  C0                	RET NZ			;IF NOT SAME, LOWER BYTE CAN BE IGNORED
3268  7D                	LD	A,L		;GET LOW BYTE OF HL
3269  B9                	CP	C		;COMPARE WITH LOW BYTE OF BC
326A  C9                	RET
                        ; FLOOR, RETURNS THE LESSER OF THE TWO NUMBERS
326B  FE 5C             FLOR	CP	'\\'		;IS IT FLOOR?
326D  C2 7B32           	JP NZ,	CEIL		;NO, TRY CEILING
3270  CD 6532           	CALL	COMP		;COMPARE NEW TO OLD
3273  DA 4333           	JP C,	EGO		;IF LESS, WE ARE OK (RESULT IS ALREADY IN HL)
3276  60                SWAP	LD	H,B		;MAKE OLD NUMBER..
3277  69                	LD	L,C		;INTO THE NEW NUMBER..
3278  C3 4333           	JP	EGO		;CONTINUE
                        ; CEILING, RETURNS THE GREATER OF THE TWO NUMBERS
327B  FE 2F             CEIL	CP	'/'		;IS IT CEILING?
327D  C2 8932           	JP NZ,	LAND		;NO, TRY LOGICAL AND
3280  CD 6532           	CALL	COMP		;COMPARE NEW AND OLD
3283  D2 4333           	JP NC,	EGO		;IF GREATER, WE ARE OK (RESULT ALREADY IN HL)
3286  C3 7632           	JP	SWAP		;MAKE OLD NEW AND CONTINUE
                        ; LOGICAL AND
3289  FE 26             LAND	CP	'&'		;IF IT LOGICAL AND ?
328B  C2 9632           	JP NZ,	LOR		;NO, TRY LOGICAL OR
328E  78                	LD	A,B		;GET HIGH BYTE OF OLD
328F  A4                	AND	H		;AND WITH HIGH BYTE OF NEW
3290  67                	LD	H,A		;AND REPLACE HIGH BYTE OF NEW
3291  7D                	LD	A,L		;GET LOW BYTE OF OLD
3292  A1                	AND	C		;AND WITH LOW BYTE OF NEW
3293  C3 A032           	JP	CPYL		;CONTINUE
                        ; LOGICAL OR
3296  FE 7C             LOR	CP	'|'		;TEST FOR LOGICAL OR
3298  C2 A432           	JP NZ,	GRTR		;NO, TRY GREATER THAN
329B  7C                	LD	A,H		;GET HIGH BYTE OF NEW
329C  B0                	OR	B		;OR WITH HIGH BYTE OF OLD
329D  67                	LD	H,A		;AND REPLACE HIGH BYTE OF NEW
329E  7D                	LD	A,L		;GET LOW BYTE OF NEW
329F  B1                	OR	C		;OR WITH LOW BYTE OF OLD
32A0  6F                CPYL	LD	L,A		;AND REPLACE LOW BYTE OF NEW
32A1  C3 4333           	JP	EGO		;CONTINUE
                        ; GREATER THAN, RETURNS ONE OR ZERO
32A4  FE 3E             GRTR	CP	'>'		;TEST FOR GREATER THAN
32A6  C2 B532           	JP NZ,	LETH		;IF NOT, TRY LESS THAN
32A9  CD 6532           	CALL	COMP		;COMPARE OLD AND NEW
32AC  CA 4033           	JP Z,	EGZ		;FALSE IF EQUAL
32AF  DA 4033           	JP C,	EGZ		;FALSE IF LESS THAN
32B2  C3 3A33           	JP	EG1		;TRUE IF NOT LESS OR EQUAL
                        ; LESS THAN, RETURNS ONE OR ZERO
32B5  FE 3C             LETH	CP	'<'		;IS IT LESS THAN?
32B7  C2 C332           	JP NZ,	ENOP		;NO, TRY NO-OP OPERATOR
32BA  CD 6532           	CALL	COMP		;COMPARE OLD AND NEW
32BD  DA 3A33           	JP C,	EG1		;TRUE IF LESS
32C0  C3 4033           	JP	EGZ		;FALSE IF NOT LESS
                        ; NO-OP OPERATOR, RETURNS NEW VALUE ONLY
32C3  FE 3B             ENOP	CP	';'		;IS IT NO-OP?
32C5  CA 4333           	JP Z,	EGO		;IF SO, DON'T DO ANYTHING
                        ; ASSIGNMENT, SET A VARIABLE'S VALUE
32C8  FE 3D             ASST	CP	'='		;TEST FOR ASSIGNMENT
32CA  C2 0533           	JP NZ,	EQUAL		;IF NOT, TRY EQUALITY
32CD  32 3782           	LD	(EFLAG), A	;SET ASSIGNMENT FLAG
32D0  13                	INC	DE		;BACK UP TO VARIABLE NAME
32D1  1A                	LD	A, (DE)		;GET VARIABLE CHARACTER
32D2  FE 5D             	CP	']'		;TEST FOR ARRAY STORAGE
32D4  CA EB32           	JP Z,	ASTOR		;IF SO, STORE INTO ARRAY
32D7  60                	LD	H,B		;GET OLD VALUE
32D8  69                	LD	L,C		;INTO H-L (WHERE STORE WANTS THEM)
32D9  FE 3F             	CP	'?'		;TEST FOR SETTING RANDOM SEED
32DB  CA E532           	JP Z,	SRSEED		;IF SO, SET THE SEED
32DE  CD E72F           	CALL	STOR		;STORE VALUE INTO VARIABLE
32E1  1B                STRT	DEC	DE		;STEP BACK FROM VARIABLE
32E2  C3 4333           	JP	EGO		;AND CONTINUE
                        ; SET THE RANDOM SEED
32E5  22 FE81           SRSEED	LD	(SEED), HL	;SO WE CAN STORE IN SEED
32E8  C3 E132           	JP	STRT		;AND CONTINUE
                        ; SET THE VALUE OF AN ARRAY ELEMENT
32EB  E5                ASTOR	PUSH	HL		;SAVE H-L
32EC  CD 3E31           	CALL	DOEXP		;CALCULATE INDEX VALUE
32EF  1B                	DEC	DE		;BACK UP PAST '['
32F0  1A                	LD	A, (DE)		;GET ARRAY NAME
32F1  CD 9E2F           	CALL	LOOKT		;LOOK UP IT'S ADDRESS IN THE TABLE
32F4  44                	LD	B,H		;GET ARRAY ADDRESS
32F5  4D                	LD	C,L		;INTO B-C
32F6  E1                	POP	HL		;RERSTORE H-L
32F7  1A                	LD	A, (DE)		;GET ARRAY NAME BACK
32F8  FE 40             	CP	'@'		;TEST FOR 'MAGIC', MEMORY REFERENCE
32FA  CA 0033           	JP Z,	STMEM		;IF SO, SET MEMORY LOCATION
32FD  7C                	LD	A,H		;GET HIGH BYTE OF VALUE
32FE  02                	LD	(BC), A		;STASH IN ARRAY
32FF  03                	INC	BC		;POINT TO NEXT
3300  7D                STMEM	LD	A,L		;GET LOW BYTE OF VALUE
3301  02                	LD	(BC), A		;STASH IN ARRAY
3302  C3 E132           	JP	STRT		;CONTINUE
                        ; TEST FOR EQUALITY.  ('==')
3305  D6 81             EQUAL	SUB	0x81		;IS A '=='?
3307  C2 1333           	JP NZ,	GEQL		;IF NOT, TRY GREATER OR EQUAL
330A  CD 6532           	CALL	COMP		;COMPARE OLD AND NEW
330D  CA 3A33           	JP Z,	EG1		;TRUE IF EQUAL
3310  C3 4033           	JP	EGZ		;FALSE IF NOT EQUAL
                        ; GREATER OR EQUAL.  ('>=')
3313  3D                GEQL	DEC	A		;TEST FOR '>='?
3314  C2 2033           	JP NZ,	LEQL		;NO, TRY LESS OR EQUAL
3317  CD 6532           	CALL	COMP		;COMPARE OLD AND NEW
331A  DA 4033           	JP C,	EGZ		;FALSE IF LESS THAN
331D  C3 3A33           	JP	EG1		;TRUE IF GREATER OR EQUAL
                        ; LESS OR EQUAL.  ('<=')
3320  3D                LEQL	DEC	A		;TEST FOR '<='?
3321  C2 3033           	JP NZ,	NEQL		;IF NOT, TRY NOT EQUAL
3324  CD 6532           	CALL	COMP		;COMPARE OLD AND NEW
3327  CA 3A33           	JP Z,	EG1		;TRUE IF SAME
332A  DA 3A33           	JP C,	EG1		;TRUE IF LESS THAN
332D  C3 4033           	JP	EGZ		;FALSE OTHERWISE
                        ; TEST FOR NOT EQUAL.  ('-=')
3330  3D                NEQL	DEC	A		;IS IT '-='?
3331  C2 7C2A           	JP NZ,	SYNT		;BEATS ME WHAT IT IS!
3334  CD 6532           	CALL	COMP		;COMPARE OLD AND NEW
3337  CA 4033           	JP Z,	EGZ		;IF SAME, FALSE
                        ; RETURN RESULT OF ONE
333A  21 0100           EG1	LD	HL,1		;SET RESULT TO ONE
333D  C3 4333           	JP	EGO		;PASS ON RESULT
                        ; RETURN RESULT OF ZERO
3340  21 0000           EGZ	LD	HL,0		;SET RESULT TO ZERO
                        ; END OF OPERATION, GET NEXT OPERATOR
3343  CD A033           EGO	CALL	FE		;GET NEXT CHARACTER
3346  C8                	RET Z			;IF WE PASS BEGINNING OF EXPRESSION, QUIT
3347  FE 28             	CP	'('		;ARE WE RETURNING FROM A NEST?
                        	;RET Z			;IF WE PASS BEGINNING OF EXPRESSION, QUIT	
3349  20 28             	JR  NZ,	EGOP1
                        				;CHECK FOR FUNCTION				
334B  3A 3682           	LD	A, (P)		;GET ADDRESS OF BEGINNING OF LINE
334E  1B                	DEC	DE
334F  BB                	CP	E		;ARE WE THERE??
3350  28 1B             	JR  Z,	EGOF1
3352  1B                	DEC	DE
3353  BB                	CP	E		;ARE WE THERE??
3354  28 16             	JR  Z,	EGOF2

3356  1A                	LD	A,(DE)
3357  FE 49             	CP	'I'
3359  20 11             	JR NZ,	EGOF2
335B  13                	INC	DE
335C  1A                	LD	A,(DE)					
335D  FE 4E             	CP	'N'
335F  20 0C             	JR NZ,	EGOF1
                        	
3361  1B                	DEC	DE
3362  C5                	PUSH	BC
3363  4D                	LD	C,L
3364  ED78              	IN	A,(C)
3366  C1                	POP	BC
3367  6F                	LD	L,A
3368  26 00             	LD	H,0
                        	
336A  18 02             	JR	EGOF0
                        	
336C  13                EGOF2	INC	DE
336D  13                EGOF1	INC	DE
336E  3E 28             EGOF0	LD	A,'('
3370  FE 28             	CP	'('
3372  C9                	RET			;IF SO, BACK UP ONE LEVEL
                        	
3373  FE 5B             EGOP1	CP	'['		;FINISHED AN ARRAY INDEX EVALUATION?
3375  C8                	RET Z			;RETURN TO MAIN EXPRESSION
3376  FE 3D             	CP	'='		;IF IT A MULTI-CHARACTER OPERATOR
3378  C2 4F31           	JP NZ,	EGO1		;IF NOT, DON'T PRE-EVALUATE
337B  1B                	DEC	DE		;BACK UP TO PRECEDING CHARACTER
337C  1A                	LD	A, (DE)		;GET PRECEDING CHARACTER
337D  FE 3D             	CP	'='		;IS IT '=='?
337F  06 81             	LD	B,0x81		;SET UNIQUE CODE
3381  CA 9C33           	JP Z,	EGO2		;IF '==' THEN WE HAVE IT
3384  03                	INC	BC		;NEXT UNIQUE CODE
3385  FE 3E             	CP	'>'		;IS IT '>='?
3387  CA 9C33           	JP Z,	EGO2		;IF SO, WE HAVE IT
338A  03                	INC	BC		;NEXT UNIQUE CODE
338B  FE 3C             	CP	'<'		;IS IT '<='?
338D  CA 9C33           	JP Z,	EGO2		;IF SO, WE HAVE IT
3390  03                	INC	BC		;NEXT UNIQUE CODE
3391  FE 2D             	CP	'-'		;IS IT '-='?
3393  CA 9C33           	JP Z,	EGO2		;IF SO, WE HAVE IT
3396  13                	INC	DE		;WASN'T A TWO CHARACTER OPERATOR. BACK UP
3397  3E 3D             	LD	A,'='		;MUST HAVE BEEN A SIMPLE '='
3399  C3 4F31           	JP	EGO1		;CONTINUE EVALUATING EXPRESSION
339C  78                EGO2	LD	A,B		;SET OPERATOR TO OUR UNIQUE CODE
339D  C3 4F31           	JP	EGO1		;AND CONTINUE EVALUATING EXPRESSION
                        ; FINDS NEXT CHARACTER IN EXPRESSION, SETS Z FLAG IF WE PASS THE BEGINNING
33A0  3A 3682           FE	LD	A, (P)		;GET ADDRESS OF BEGINNING OF LINE
33A3  BB                	CP	E		;ARE WE THERE??
33A4  C8                	RET Z			;IF SO, WE ARE FINISHED
33A5  1A                	LD	A, (DE)		;GET CHARACTER FROM SOURCE
33A6  FE 20             	CP	' '		;IS A (USELESS) BLANK?
33A8  C0                	RET NZ			;IF NOT, WE ARE FINISHED
33A9  1B                	DEC	DE		;BACK UP ANOTHER CHARACTER
33AA  C3 A033           	JP	FE		;AND TRY AGAIN
                        ; CALCULATE A PSEUDO-RANDOM VALUE
33AD  2A FE81           RANDR	LD	HL, (SEED)	;GET RANDOM SEED
33B0  7C                	LD	A,H		;GET HIGH BYTE OF SEED
33B1  E6 F7             	AND	0xF7		;AND WITH HIGH MASK
33B3  F5                	PUSH	AF
33B4  7D                	LD	A,L		;GET LOW BYTE OF SEED
33B5  E6 42             	AND	0x42		;AND WITH LOW BYTE OF MASK
33B7  F5                	PUSH	AF
33B8  C1                	POP	BC		;GET FLAGS IN C
33B9  79                	LD	A,C		;COPY TO A
33BA  C1                	POP	BC		;GET FIRST SET OF FLAGS IN C
33BB  A9                	XOR	C		;COMPUTE PARITY FOR ENTIRE WORD
33BC  0F                	RRCA			;MOVE COMPUTED
33BD  0F                	RRCA			;PARITY INTO
33BE  0F                	RRCA			;THE CARRY FLAG
33BF  3F                	CCF			;COMP, SO SHIFT IN 1 IF EVEN
33C0  7D                	LD	A,L		;GET LOW BYTE OF SEED
33C1  17                	RLA			;SHIFT IN CARRY, OUT HIGH BIT
33C2  6F                	LD	L,A		;RESAVE
33C3  7C                	LD	A,H		;GET HIGH BYTE OF SEED
33C4  17                	RLA			;SHIFT IN CARRY (HIGH BIT OF OLD LOWER)
33C5  67                	LD	H,A		;RESAVE
33C6  22 FE81           	LD	(SEED), HL	;RESULT IS NEW SEED
33C9  C3 CC31           	JP	DCLB		;KEEP GOING
                        ;
                        ; EVALUATES A CHARACTER EXPRESSION
                        ;
33CC  CD A334           CEXP	CALL	CLBF		;CLEAR EXTRA BUFFER
33CF  13                	INC	DE		;SKIP TO END OF EXPRESSION
33D0  3E 2B             	LD	A,'+'		;TO BEGIN, CONCATINATE A NULL STRING
33D2  F5                CG1	PUSH	AF
33D3  CD B034           	CALL	PUSHB		;COPY NEW BUFFER INTO OLD BUFFER
33D6  CD A334           	CALL	CLBF		;CLEAR THE NEW BUFFER
33D9  1B                	DEC	DE		;BACK UP IN SOURCE
33DA  CD A033           	CALL	FE		;GET CHARACTER AND TEST FOR END
33DD  FE 22             	CP	'"'		;TEST FOR QUOTE
33DF  CA F733           	JP Z,	CQ		;IF SO, HANDLE QUOTED STRING
33E2  FE 24             	CP	'$'		;TEST FOR CHARACTER VARIABLE
33E4  C2 7C2A           	JP NZ,	SYNT		;IF NOT, IT'S NOT ANYTHING I RECOGNISE
33E7  1B                CV	DEC	DE		;BACK UP PAST DOLLAR SIGN
33E8  1A                	LD	A, (DE)		;GET VARIABLE NAME
33E9  FE 5D             	CP	']'		;TEST FOR INDEX INTO CHARACTER VARIABLE
33EB  CA C334           	JP Z,	CINDX		;GET INDEX VALUE
33EE  CD B52F           	CALL	LTA		;GET ADDRESS OF VARIABLE
33F1  D5                	PUSH	DE		;SAVE SOURCE POSITION
33F2  EB                	EX	DE, HL	
33F3  1B                	DEC	DE		;BACK UP IN SOURCE
33F4  C3 0434           	JP	Q0		;SAVE VARIABLE IN NEW BUFFER
                        ; BACKUP TO PRECEDING QUOTE
33F7  1B                CQ	DEC	DE		;BACKUP IN SOURCE
33F8  1A                	LD	A, (DE)		;GET CHARACTER FROM SOURCE
33F9  FE 0D             	CP	CR		;TEST FOR END OF LINE
33FB  CA 7C2A           	JP Z,	SYNT		;IF SO, THERE IS NO CLOSEING QUOTE
33FE  FE 22             	CP	'"'		;TEST FOR CLOSEING QUOTE
3400  C2 F733           	JP NZ,	CQ		;IF NO, KEEP LOOKING
3403  D5                	PUSH	DE		;SAVE ENDING POSITION
3404  21 6480           Q0	LD	HL,XBF		;GET ADDRESS OF NEW (EXTRA) BUFFER
3407  13                Q1	INC	DE		;ADVANCE TO SOURCE OR VARIABLE CHARACTER
3408  1A                	LD	A, (DE)		;GET CHARACTER
3409  FE 22             	CP	'"'		;TEST FOR CLOSEING QUOTE
340B  CA 1834           	JP Z,	Q2		;IF SO, STOP COPYING
340E  FE FF             	CP	0xFF		;TEST FOR END OF VARIABLE
3410  CA 1834           	JP Z,	Q2		;IF SO, STOP COPYING
3413  77                	LD	(HL),A		;SAVE IN BUFFER
3414  23                	INC	HL		;ADVANCE IN BUFFER
3415  C3 0734           	JP	Q1		;KEEP COPYING
3418  D1                Q2	POP	DE		;GET POSITION BACK
3419  1B                Q3	DEC	DE		;BACK UP TO OPERATOR
341A  F1                	POP	AF
341B  FE 2B             	CP	'+'		;TEST FOR CONCATIONATION
341D  C2 3534           	JP NZ,	Q5		;NO, TRY ASSIGNMENT
                        ; CONCATONATION. XBF=XBF+TB
3420  01 3280           QPP	LD	BC,TB		;ADDRESS OF TEMPORARY BUFFER
3423  0A                Q4	LD	A, (BC)		;GET CHARACTER FROM BUFFER
3424  77                	LD	(HL),A		;MOVE TO BUFFER
3425  03                	INC	BC		;ADVANCE IN OLD
3426  23                	INC	HL		;ADVANCE IN NEW
3427  79                	LD	A,C		;GET ADDRESS IN OLD
3428  FE 55             	CP	TB+35		;TEST FOR OVER
342A  DA 2334           	JP C,	Q4		;IF SO, STOP
342D  2A 6480           	LD	HL, (XBF)	;GET CHARACTER FROM BUFFER
3430  26 00             	LD	H,0		;SET HIGH BYTE TO ZERO
3432  C3 7E34           	JP	Q9		;CONTINUE
                        ; ASSIGNMENT
3435  FE 3D             Q5	CP	'='		;TEST FOR ASSIGNMENT
3437  C2 4E34           	JP NZ,	Q6		;IF NOT, TRY EQUALITY
343A  13                	INC	DE		;SKIP TO VARIABLE NAME
343B  13                	INC	DE		;SKIP TO DOLLARSIGN
343C  1A                	LD	A, (DE)		;GET DOLLARSIGN
343D  1B                	DEC	DE		;BACK UP TO VARIABLE NAME
343E  FE 24             	CP	'$'		;TEST FOR DOLLAR SIGN
3440  C2 7C2A           	JP NZ,	SYNT		;IF NOT, THIS AIN'T NO CHARACTER VARIABLE
3443  32 3782           	LD	(EFLAG), A	;SET ASSIGNMENT FLAG
3446  1A                	LD	A, (DE)		;GET VARIABLE NAME
3447  1B                	DEC	DE		;BACK UP BAST NAME
3448  CD B52F           	CALL	LTA		;GET IT'S ADDRESS
344B  C3 2034           	JP	QPP		;COPY IT OVER
                        ; TEST FOR EQUALITY
344E  FE 81             Q6	CP	0x81		;TEST FOR '=='
3450  C2 7234           	JP NZ,	X0		;NO, TRY '=-'
3453  CD 5934           	CALL	COMSTR		;COMPARE STRINGS
3456  C3 7E34           	JP	Q9		;CONTINUE
                        ; COMPARES STRINGS. SETS H-L TO 1 OR 0 IF EQUAL OR NOT EQUAL
3459  01 3280           COMSTR	LD	BC,TB		;GET ADDRESS OF OLD STRING
345C  21 6480           	LD	HL,XBF		;ADDRESS OF NEW STRING
345F  0A                Q7	LD	A, (BC)		;GET CHARACTER FROM OLD
3460  BE                	CP	(HL)		;TEST AGAINST NEW
3461  C2 6E34           	JP NZ,	Q8		;IF NOT, THEY ARE UNEQUAL
3464  03                	INC	BC		;NEXT PLACE IN OLD
3465  23                	INC	HL		;NEXT PLACE IN NEW
3466  3C                	INC	A		;TEST FOR END OF STRING
3467  C2 5F34           	JP NZ,	Q7		;IF NOT, CONTINUE TESTING
346A  21 0100           	LD	HL,1		;INDICATE THEY ARE EQUAL
346D  C9                	RET
346E  21 0000           Q8	LD	HL,0		;INDICATE NOT EQUAL
3471  C9                	RET
                        ; NOT EQUAL .. '-='
3472  FE 82             X0	CP	0x82		;TEST FOR '-='
3474  C2 7C2A           	JP NZ,	SYNT		;BEATS ME, BUT IT ISN'T RIGHT
3477  CD 5934           	CALL	COMSTR		;TEST STRINGS
347A  7D                	LD	A,L		;GET RESULT
347B  EE 01             	XOR	1		;AND COMPLEMENT IT
347D  6F                	LD	L,A		;REPLACE IN RESULT
                        ; GET NEXT STRING
347E  CD A033           Q9	CALL	FE		;GET NEXT CHARACTER
3481  37                	SCF			;INDICATE CHARACTER EXPRESSION
3482  C8                	RET Z			;IF END OF LINE, QUIT
3483  FE 28             	CP	'('		;TEST FOR END OF NUMERIC SUBSTRING
3485  C8                	RET Z			;QUIT, INDICATING NUMBERIC RESULT
3486  FE 3D             	CP	'='		;TEST FOR EQUAL,ASSIGNMENT, OR NOT EQUALS
3488  C2 D233           	JP NZ,	CG1		;NO, NO NEED TO TEST FURTHER
348B  1B                QTST	DEC	DE		;BACK UP TO PREVIOUS CHARACTER
348C  1A                	LD	A, (DE)		;GET CHARACTER
348D  47                	LD	B,A		;SAVE FOR COMPARISON
348E  FE 3D             	CP	'='		;TEST FOR '=='
3490  3E 81             	LD	A,0x81		;INDICATE '=='
3492  CA D233           	JP Z,	CG1		;CONTINUE
3495  78                	LD	A,B		;GET CHARACTER BACK
3496  FE 2D             	CP	'-'		;TEST FOR '-='
3498  3E 82             	LD	A,0x82		;INDICATE '-='
349A  CA D233           	JP Z,	CG1		;CONTINUE
349D  13                	INC	DE		;ADVANCE BACK TO PREVIOUS CHARACTER
349E  3E 3D             	LD	A,'='		;INDICATE '='
34A0  C3 D233           	JP	CG1		;CONTINUE
                        ; CLEARS THE TEXT BUFFER
34A3  21 6480           CLBF	LD	HL,XBF		;GET ADDRESS OF BUFFER
34A6  3E 28             	LD	A,40		;CLEAR FOR LENGTH OF 40
34A8  36 FF             CL2	LD	(HL),0xFF	;CLEAR TO NULL CHARACTER
34AA  23                	INC	HL		;NEXT POSITION IN BUFFER
34AB  3D                	DEC	A		;REDUCE COUNT OF REMAINING
34AC  C2 A834           	JP NZ,	CL2		;KEEP GOING TILL WE ARE FINISHED
34AF  C9                	RET
                        ; COPY'S NEW BUFFER INTO OLD BUFFER
34B0  D5                PUSHB	PUSH	DE		;SAVE POSITION IS SOURCE
34B1  11 6480           	LD	DE,XBF		;GET ADDRESS OF NEW BUFFER
34B4  21 3280           	LD	HL,TB		;GET ADDRESS OF OLD BUFFER
34B7  06 28             	LD	B,40		;COPY 40 CHARACTERS
34B9  1A                PU1	LD	A, (DE)		;GET CHARACTER FROM NEW
34BA  77                	LD	(HL),A		;SAVE IN OLD
34BB  23                	INC	HL		;NEXT POSITION IN OLD
34BC  13                	INC	DE		;NEXT POSITION IN NEW
34BD  0B                	DEC	BC		;REDUCE COUNT
34BE  C2 B934           	JP NZ,	PU1		;KEEP GOING TILL 40 ARE MOVED
34C1  D1                	POP	DE		;RESTORE POSITION IN SOURCE
34C2  C9                	RET
                        ; INDEXED CHARACTER VARIABLE, EXTRACT A SINGLE CHARACTER
34C3  CD 3E31           CINDX	CALL	DOEXP		;EVALUATE INDEX EXPRESSION
34C6  7D                	LD	A,L		;GET INDEX VALUE
34C7  F5                	PUSH	AF
34C8  1B                	DEC	DE		;BACK UP TO VARIABLE NAME
34C9  1A                	LD	A, (DE)		;GET VARIABLE NAME
34CA  FE 40             	CP	'@'		;TEST FOR 'MAGIC' CHR0x VARIABLE
34CC  CA E334           	JP Z,	CHR		;IF SO, HANDLE SPECIAL CASE
34CF  CD B52F           	CALL	LTA		;GET TEXT VARIABLE ADDRESS
34D2  F1                	POP	AF
34D3  FE 23             	CP	35		;TEST FOR TOO BIG
34D5  D2 AF2F           	JP NC,	DIMERR		;IF SO, TELL HIM HE SCREWED UP
34D8  4F                	LD	C,A		;GET INTO A DOUBLE PAIR
34D9  09                	ADD	HL,BC		;SO WE CAN DAD IT TO THE ADDRESS
34DA  7E                	LD	A,(HL)		;AND GET THE CHARACTER
34DB  21 6480           FILBUF	LD	HL,XBF		;ADDRESS OF TEXT BUFFER
34DE  77                	LD	(HL),A		;PLACE CHARACTER THERE
34DF  23                	INC	HL		;BUMP TO NEXT POSITION
34E0  C3 1934           	JP	Q3		;AND FILL WITH NULLS
                        ;
                        ; 'MAGIC' CHARACTER ARRAY, RETURNS CHARACTER WITH VALUE OF IT'S INDEX
                        ;
34E3  F1                CHR	POP	AF
34E4  C3 DB34           	JP	FILBUF		;SAVE IN BUFFER AND PAD WITH NULLS
                        	
                        ;*********************************************************************
                        ;                          PATCH I/O ROUTINES TO Z80MC
                        	
34E7  CD 5100           CTRLC	CALL	BINCHR
34EA  FE 03             	CP	3
34EC  C9                	RET


34ED  CD 5100           BGETCHR CALL	BINCHR
34F0  38 FB             	JR C,	BGETCHR
34F2  C9                	RET


                        ; END OF BASIC INTERPRETER CODE SECTION
                        ;	PAGE
                        ;
                        ;*********************************************************************
                        ;                          COMMAND TABLE
                        ;
                        ;   FORMAT IS:
                        ;               COMMAND WORDS, HIGH BIT SET ON LAST CHARACTER
                        ;               ADDRESS OF COMMAND PROCESSOR FOLLOWES
                        ;               ENTRY OF HEX 00 INDICATES LAST ENTRY IN TABLE (DEFAULT)
                        ;
                        ;*********************************************************************
                        ;
                        ; COMMANDS ALLOWED ONLY FROM WITHING A PROGRAM..
34F3  4E4558            PTAB	DB	'NEX'
34F6  D4                	DB	'T'+0x80
34F7  E12D              	DW	NEXT
34F9  544845            	DB	'THE'
34FC  CE                	DB	'N'+0x80
34FD  322D              	DW	THEN
34FF  474F5355          	DB	'GOSU'
3503  C2                	DB	'B'+0x80
3504  3B2D              	DW	GOSUB
3506  52455455 52       	DB	'RETUR'
350B  CE                	DB	'N'+0x80
350C  6E2D              	DW	RETURN
350E  464F              	DB	'FO'
3510  D2                	DB	'R'+0x80
3511  7B2D              	DW	FOR
3513  49                	DB	'I'
3514  C6                	DB	'F'+0x80
3515  162E              	DW	IF
3517  444154            DATCMD	DB	'DAT'
351A  C1                	DB	'A'+0x80
351B  132D              	DW	RNEXT
351D  4C49              	DB	'LI'
351F  C6                	DB	'F'+0x80
3520  392E              	DW	LIF
                        ; COMMANDS ALLOWED FROM BOTH A PROGRAM, AND INTERACTIVE KEYBOARD ENTRY
3522  474F54            KTAB	DB	'GOT'
3525  CF                	DB	'O'+0x80
3526  432D              	DW	GOTO
3528  4F55              	DB	'OU'
352A  D4                	DB	'T'+0x80	
352B  672E              	DW	OUTP
352D  4C45              	DB	'LE'
352F  D4                	DB	'T'+0x80
3530  D22D              	DW	LET
3532  5052494E          	DB	'PRIN'
3536  D4                	DB	'T'+0x80
3537  8D2E              	DW	BPRINT
3539  5553              	DB	'US'
353B  D2                	DB	'R'+0x80
353C  C82F              	DW	USR
353E  524541            	DB	'REA'
3541  C4                	DB	'D'+0x80
3542  1F30              	DW	READ
3544  504C4F            	DB	'PLO'
3547  D4                	DB	'T'+0x80
3548  442E              	DW	PLOT
354A  5245              	DB	'RE'
354C  CD                	DB	'M'+0x80
354D  152E              	DW	REM
354F  4449              	DB	'DI'
3551  CD                	DB	'M'+0x80
3552  3E2F              	DW	DIM
3554  5255              	DB	'RU'
3556  CE                	DB	'N'+0x80
3557  EC2C              	DW	RUN
3559  4F524445          	DB	'ORDE'
355D  D2                	DB	'R'+0x80
355E  0430              	DW	ORDER
3560  494E5055          	DB	'INPU'
3564  D4                	DB	'T'+0x80
3565  CB2E              	DW	INPUT
3567  434C4541          	DB	'CLEA'
356B  D2                	DB	'R'+0x80
356C  AF2C              	DW	CLEAR
356E  53544F            	DB	'STO'
3571  D0                	DB	'P'+0x80
3572  2C2D              	DW	STOP
3574  454E              	DB	'EN'
3576  C4                	DB	'D'+0x80
3577  1D2A              	DW	INIT
3579  4C4953            	DB	'LIS'
357C  D4                	DB	'T'+0x80
357D  6B2C              	DW	LIST
357F  4E45              	DB	'NE'
3581  D7                	DB	'W'+0x80
3582  152A              	DW	NEW
3584  53495A            	DB	'SIZ'
3587  C5                	DB	'E'+0x80
3588  A930              	DW	SIZE
358A  4C4F41            	DB	'LOA'
358D  C4                	DB	'D'+0x80
358E  C930              	DW	LOAD
3590  534156            	DB	'SAV'
3593  C5                	DB	'E'+0x80
3594  CC30              	DW	SAVE
3596  455849            	DB	'EXI'
3599  D4                	DB	'T'+0x80
359A  4200              	DW	BEXIT
359C  00                	DB	0		;UNRECOGNIZED COMMAND, ASSUME 'LET'
359D  D22D              	DW	LET
                        ;
                        ;**************************************************************
                        ;                    STRINGS AND MESSAGES
                        ;**************************************************************
                        ;
                        ; ERROR MESSAGES..
                        ;
359F  44495649 44452042 DER	DB	'DIVIDE BY ZERO',0 ;DIVIDE BY ZERO
35A7  59205A45 524F00
35AE  42414420 44415441 IERMS	DB	'BAD DATA - RETRY',CR,LF,0 ;BAD RESPONSE TO INPUT STATEMENT
35B6  202D2052 45545259
35BE  0D0A00
35C1  4E455354 494E4700 CSTK	DB	'NESTING',0	;INVALID FOR/NEXT, GOSUB/RETURN NESTING
35C9  4C494E45 204E554D LIN	DB	'LINE NUMBER',0	;GOTO, GOSUB, OR ORDER TO UNKNOWN LINE
35D1  42455200
35D5  4E4F2050 524F4752 NP	DB	'NO PROGRAM',0	;RUN OR SAVE EMPTY PROGRAM
35DD  414D00
35E0  20494E20 4C494E45 INL	DB	' IN LINE ',0	;INDICATES LINE ERROR WAS IN
35E8  2000
35EA  53594E54 415800   SYN	DB	'SYNTAX',0	;DOES NOT FOLLOW SYNTAX RULES
35F1  44415441 00       DTXT	DB	'DATA',0	;BAD LINE OR DATA TYPE
35F6  44494D45 4E53494F OVM	DB	'DIMENSION',0	;TO MANY ARRAYS, ARGUMENT OUT OF RANGE
35FE  4E00
                        ;
                        ; INFORMATIONAL MESSAGES..
                        ;
3600  0C204D49 43524F2D INTRO	DB	0x0C,' MICRO-BASIC COPYRIGHT 1983 BY DAVE DUNFIELD',CR,LF,0
3608  42415349 4320434F
3610  50595249 47485420
3618  31393833 20425920
3620  44415645 2044554E
3628  4649454C 440D0A00
3630  52454144 590D0A00 RDY	DB	'READY',CR,LF,0	;RREADY PROMPT
3638  53544F50 00       STMSG	DB	'STOP',0	;INDICATES PROGRAM STOPPED
363D  20455252 4F5200   EM	DB	' ERROR',0	;INDICATES ERROR OCCURED
3644  20425954 45530D0A SIMSG	DB	' BYTES',CR,LF,0 ;DISPLAYED IN RESPONSE TO 'SIZE'
364C  00

      = 364D            ENDIT	EQU	$

                        ;	END	0
                        	





                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Appendix_B	Future Use
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;


                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Appendix_C	RAM. System Ram allocation
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;


                        ;                       ********      ***     **     **
                        ;                       *********    *****    ***   ***
                        ;                       **     **   *** ***   **** ****
                        ;                       **     **  ***   ***  *********
                        ;---------------------  ********   *********  ** *** **  ---------------------
                        ;---------------------  ********   *********  ** *** **  ---------------------
                        ;                       **  **     **     **  **     **
                        ;                       **   **    **     **  **     **
                        ;                       **    **   **     **  **     **
                        ;                       **     **  **     **  **     **

      = 8000            RAM_LDRT	equ	0x8000


FA00                    		ORG	0xFA00
FA00   (0080)           LINE_BUFF	DS	128
FA80   (0002)           LINE_BUFFEND	DS	2	;Room for CR,LF if needed
FA82   (0004)           LI_FILESIZE	DS	4	;LINE INPUT FILE SIZE, counts down the bytes in the file as Lines are fetched
FA86   (0002)           LI_SDBUFF_PTR	DS	2	;Pointer to Disk Buffer for next Line Read operation
FA88   (0002)           LI_SDLOG_SEC	DS	2	;Logical Sector last read in Buffer


                        				;Read Hex File Performance counter
FA8A   (0002)           RHF_LINES	DS	2	;Line counter


                        ;----------------------------------------------------------------------------------------------------; RAM SPACE
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;----------------------------------------------------------------------------------------------------; RAM SPACE
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;Reserve space from 0xFB00 to FB1F for Stack
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
FB00                    		ORG	0xFB00
      = FAFE            StackTop	equ	$-2	; Stack = 0xFB00

FB00   (0028)           STACKSPACE1	DS	40	;Stack space for ISR L1 calls  (Measured to only need 14 words, resv 20 words)
      = FB28            STACK_ISR1	EQU	$	;Points to top of stack
FB28   (0002)           SP_ISR_SAVE	DS	2	;Space to save SP, Happens on first ISR call


FB2A   (0029)           HRAM_CODE	DS	ROM_CODE_LEN	;Code for Returning from ISR (may need to switch to RAM, so it must be here in High RAM)

      = FB2A            ISR_DISPATCH	EQU	HRAM_CODE
      = FB3B            ISR_RET		EQU	ISR_RET_OFF+HRAM_CODE ;Assign address in the HIGH RAM
      = FB45            GET_MEM		EQU	GET_MEM_OFF+HRAM_CODE ;Assign address in the HIGH RAM	


FB53   (0008)           HR_EXE_GO	DS	HR_EXEC_GS_LEN	;Routine for Switching to RAM and Executing loaded program.

      = FB5B            HERE1		EQU	$

                        	IF HERE1 > 0xFB80
                        	ENDIF
                        	
                        	;FREE RAM 25 BYTES

FB80                    		ORG	0xFB80
                        ;SDFCB:
      = 0000            FSTAT		EQU	0	;DS  1	;+0  Status of FCB, 00=File Not Open, 01=File Opened, 80=EOF (Line_Input)
      = 0001            FNAME		EQU	1	;DS 11	;+1  File name
      = 000C            AFClus0		EQU	12	;DS  2	;+12 First Cluster of File as given by the Directory Entry.
      = 000E            CRFClus		EQU	14	;DS  2	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
      = 0010            CAFClus		EQU	16	;DS  2	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
      = 0012            RFSec		EQU	18	;DS  2	;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
      = 0014            SSOC		EQU	20	;DS  4	;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
      = 0018            ABS_SEC		EQU	24	;DS  4	;+24 Absolute Sector of Current Relative Sector
      = 001C            FSIZE		EQU	28	;DS  4	;+28 File Size of file (not used, just kept for completness)

                        ;Warning: FCB's must never cross page boundaries.
FB80   (0020)           SDISKA		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
FBA0   (0020)           SDISKB		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
FBC0   (0020)           SDISKC		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
FBE0   (0020)           SDISKD		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)

                        ;
                        ;  ********   **     **  *********  *********  *********  ********
                        ;  *********  **     **  *********  *********  *********  *********
                        ;  **     **  **     **  **         **         **         **     **
                        ;  **     **  **     **  **         **         **         **     **
                        ;  ********   **     **  *******    *******    *******    ********
                        ;  ********   **     **  *******    *******    *******    ********
                        ;  **     **  **     **  **         **         **         **  **
                        ;  **     **  **     **  **         **         **         **   **
                        ;  *********  *********  **         **         *********  **    **
                        ;  ********    *******   **         **         *********  **     **
                        ;
FC00                    		ORG	0xFC00
FC00   (0200)           SD_RAM_BUFFER	DS	512	;FC00-FDFF 512 bytes of SD Sector Buffer space

FE00   (0100)           RXBUFFER	DS	256	;FExx      256 bytes of RX Buffer space
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


FF00                    		ORG	0xFF00
FF00   (0008)           BIT_TABLE	DS	8

                        ;Warning: FCB's must never cross page boundaries.
FF08   (0002)           FCB_PTR		DS	2	;Pointer to Current FCB


      = FF0A            FAT_CLEAR	EQU	$	;Clear bytes of RAM after this point on FAT_INIT
FF0A   (0002)           GH_START	DS	2	;HEX File, start address
FF0C   (0001)           VIEW_FLAGS	DS	1	;View File Load;  File Open View
                        				;BIT .0=View HEX Load, display file while reading HEX file
                        				;    .1=GH_START Address has been set
                        				;    .6=View FILE SIZE during File Open
                        				;    .7=View File Name & Found or Not status durin File Open

FF0D   (0002)           LOGICAL_SEC	DS	2	;Logical Sector for next Read Operation (Input paramater for the File Read)

FF0F   (0001)           DIRTY_DATA	DS	1	;Indicates when data Read has been altered, ie. Requires flushing back to SD Card
FF10   (0001)           SD_CARD_TYPE	DS	1	;SD CARD TYPE
FF11   (0001)           SDC_STATUS	DS	1	;SD Status Code returned
FF12   (0004)           SD_PARAM	DS	4	;32 bit address parameter for SD Commands
FF16   (0001)           SD_PART_TYPE	DS	1	;SD PARTITION TYPE
FF17   (0004)           SD_PART_BASE	DS	4	;SD PARTITION STARTING RECORD
FF1B   (0004)           SD_PART_SIZE	DS	4	;SD PARTITION SIZE (Must follow SD_PART_BASE)
FF1F   (0002)           BYTE_P_SEC	DS	2	;0x0B Bytes per Sector (Almost always 512)
FF21   (0001)           SEC_PER_CLUS	DS	1	;0x0D
FF22   (0002)           RESERVED_SEC	DS	2	;0x0E - 0x0F
FF24   (0001)           FAT_COPIES	DS	1	;0x10
FF25   (0002)           ROOTDIR_SIZE	DS	2	;0x11 - 0x12
FF27   (0004)           FILESYS_SEC	DS	4	;0x13 - 0x14 or 0x20 - 0x23
FF2B   (0004)           HIDDEN_SEC	DS	4	;0x1C - 0x1F
FF2F   (0002)           SEC_PER_FAT	DS	2	;0x16 - 0x17
FF31   (0004)           FAT1START	DS	4	;Calculated Sector to FAT1
FF35   (0004)           DIR_SECTOR	DS	4	;Calculated Sector to Root Directory
FF39   (0004)           DATASTART	DS	4	;Calculated Sector to Data Area
FF3D   (0004)           SEC_PTR		DS	4	;Sector Pointer, general use variable that holds the last sector read
FF41   (0002)           ENT_COUNT	DS	2	;Directory Entry Counter, Counts down maximum directory entries in Find File
      = 0039            FAT_CLR_LEN	EQU	$ - FAT_CLEAR
FF43   (0008)           FILENAME	DS	8	;File Name
FF4B   (0003)           FILEEXT		DS	3	;File Extension
FF4E   (0004)           FILESIZE	DS	4	;File Size


FF52   (0002)           DIVIDE_FUNC	DS	2	;Pointer to the Divide Function
FF54   (0001)           DF_SHIFTCNT	DS	1	;Count of shifts required for Fast Divide
FF55   (0001)           MUL8		DS	1	;8 bit multiplier
FF56   (0002)           MOD_FUNC	DS	2	;Pointer to the Mod Function
FF58   (0001)           MODMASK		DS	1	;8 bit mask to get Relative Sector within a cluster from a Relative File sector

FF59   (0001)           IK_HEXL		DS	1	;IMON HEX INPUT
FF5A   (0001)           IK_HEXH		DS	1	;IMON HEX INPUT
FF5B   (0002)           HEX_SOURCE	DS	2	;Pointer to the HEX INPUT Source (FILE or Serial Port)

                        	IF $ >= 0xFF78
                        	ENDIF

                        ;*** BEGIN COLD_BOOT_INIT (RAM that is to be initialized upon COLD BOOT) ***
      = FF78            RAMSIGNATURE	equ	0xFF78	;RAM signature
                        				;Following bytes are cleared on COLD BOOT
      = FF80            RC_TYPE		equ	0xFF80	;(1) Type of Reset (WARNING, Next 7 RC counters must end with lsb bits = 001,010,011,100,101,110,111)
      = FF81            RC_SOFT		equ	0xFF81	;(1) Count of Resets by SOFT F-E SWITCH
      = FF82            RC_STEP		equ	0xFF82	;(1) Count of Resets by SINGLE STEP
      = FF83            RC_CC		equ	0xFF83	;(1) Count of Resets by CTRL-C
      = FF84            RC_HALT		equ	0xFF84	;(1) Count of Resets by HALT INSTRUCTION
      = FF85            RC_F0		equ	0xFF85	;(1) Count of Resets by pressing F & 0 keys
      = FF86            RC_RST0		equ	0xFF86	;(1) Count of Resets by RST 0 INSTRUCTION
      = FF87            RC_HARD		equ	0xFF87	;(1) Count of Resets by UNKNOWN RESET LINE

      = FF88            ABUSS		equ	0xFF88	;(2)
      = FF8A            RegPtr		equ	0xFF8A	;(1) Ptr to Registers
      = FF8B            IoPtr		equ	0xFF8B	;(1)  I/O Ptr
      = FF8C            RX_ERR_LDRT	equ	0xFF8C	;(1) Counts False Start Bits (Noise Flag)
      = FF8D            RX_ERR_STOP	equ	0xFF8D	;(1) Counts Missing Stop Bits (Framing Error)
      = FF8E            RX_ERR_OVR	equ	0xFF8E	;(1) Counts Overrun Errors

      = 000F            CS_CLR_LEN	equ	0xFF8F-RC_TYPE

      = FF8F            ACE_BAUD	equ	0xFF8F	;(1) Baudrate of ACE, 12=9600

                        				;PUTCHAR_EXE and INCHAR_EXE *must be consecutive in this order*
      = FF90            PUTCHAR_EXE	equ	0xFF90	;(2) PutChar Execution (Set for PC_LED, PC_BIT, PC_ACE or PC_BOTH)
      = FF92            INCHAR_EXE	equ	0xFF92	;(2) InChar Execution (Set for IN_KEY, IN_BIT, IN_ACE or IN_BOTH)
                        ;*** END COLD_BOOT_INIT (RAM that is to be initialized upon COLD BOOT) ***

      = FF94            HW_SETIO	equ	0xFF94	;Serial IO selected, 01=Bit, 02=ACE, 03=BIT & ACE
      = FF95            HW_LIST		equ	0xFF95	;Hardware List, 00=NO Boards, 01=FP Only, 02=SIO only, 03=FP & SIO

                        				;Saved Registers
      = FF96            RSSP		equ	0xFF96	;Value of SP upon REGISTER SAVE
      = FF98            RSAF		equ	0xFF98	;Value of AF upon REGISTER SAVE
      = FF9A            RSBC		equ	0xFF9A	;Value of BC upon REGISTER SAVE
      = FF9C            RSDE		equ	0xFF9C	;Value of DE upon REGISTER SAVE
      = FF9E            RSHL		equ	0xFF9E	;Value of HL upon REGISTER SAVE
      = FFA0            RPC		equ	0xFFA0	;Value of PC upon REGISTER SAVE
      = FFA2            RSIX		equ	0xFFA2	;Value of IX upon REGISTER SAVE
      = FFA4            RSIY		equ	0xFFA4	;Value of IY upon REGISTER SAVE
      = FFA6            RSIR		equ	0xFFA6	;Value of IR upon REGISTER SAVE
      = FFA8            RSAF2		equ	0xFFA8	;Value of AF' upon REGISTER SAVE
      = FFAA            RSBC2		equ	0xFFAA	;Value of BC' upon REGISTER SAVE
      = FFAC            RSDE2		equ	0xFFAC	;Value of DE' upon REGISTER SAVE
      = FFAE            RSHL2		equ	0xFFAE	;Value of HL' upon REGISTER SAVE

      = FFB0            UiVec		equ	0xFFB0	;(2) User Interrupt Vector


                        ;*** BEGIN WARM_BOOT_INIT (RAM that is to be initialized on every boot) ***
                        				;WARNING, Following 34 bytes must be consecutive in this order for Block Write
      = FFB2            BEEP_TO		equ	0xFFB2	;(1) Count down the beep (beep duration)
      = FFB3            ANBAR_DEF	equ	0xFFB3	;(1) Base setting for the Annunciator LED's (after current function times out)
      = FFB4            GET_REG		equ	0xFFB4	;(2) Get Reg Routine (in monitor mode, registers fetched from RAM)
      = FFB6            PUT_REG		equ	0xFFB6	;(2) Put Reg Routine
      = FFB8            CTRL_C_CHK	equ	0xFFB8	;(2) Vector for CTRL-C Checking
      = FFBA            LDISPMODE	equ	0xFFBA	;(2) Last Display Mode (Holds DISPMODE while in HEX Entry)
      = FFBC            DISPMODE	equ	0xFFBC	;(2) Display Routine
      = FFBE            KEY_EVENT	equ	0xFFBE	;(2) Routine to call upon Key Press (changes based on user actions, see KEY_EVENT_DISPATCH)
      = FFC0            IK_TIMER	equ	0xFFC0	;(1) IMON TIMEOUT
      = FFC1            KEYBFMODE	equ	0xFFC1	;(1) KEY INPUT MODE. 8F=HEX INPUT, 90=Shiftable
      = FFC2            DISPLABEL	equ	0xFFC2	;(1) Display Label Refresh
      = FFC3            IK_HEXST	equ	0xFFC3	;(1) IMON HEX Input State
      = FFC4            HEX_CURSOR	equ	0xFFC4	;(2) HEX Input Cursor location
      = FFC6            HEX_READY	equ	0xFFC6	;(2) HEX Input Ready
      = FFC8            LED_CURSOR	equ	0xFFC8	;(2) Cursor location for LED Put_Char
      = FFCA            RXBHEAD		equ	0xFFCA	;(2) RS-232 RX BUFFER HEAD
      = FFCC            RXBTAIL		equ	0xFFCC	;(2) RS-232 RX BUFFER TAIL
      = FFCE            INT_VEC		equ	0xFFCE	;(2) Vector to Interrupt ISR
      = FFD0            SCAN_PTR	equ	0xFFD0	;(2) SCAN_PTR points to next LED_DISPLAY byte to output (will always be 1 more
                        				;    than the current hardware column because hardware automatically advances)
      = FFD2            HALT_TEST	equ	0xFFD2	;(2) HALT_TEST
                        ;*** END WARM_BOOT_INIT (RAM BLOCK that is to be initialized on every boot) ***


      = FFD4            CLEARED_SPACE	equ	0xFFD4	;Bytes here and later are cleared upon init (some initialized seperately)
      = 002C            CLEARED_LEN	equ	0xFFFF - CLEARED_SPACE + 1

      = FFD4            SDISPMODE	equ	0xFFD4	;(2)
      = FFD6            POS_BIT		equ	0xFFD6	;(1) BIT Bang RS232 Character position
      = FFD7            POS_ACE		equ	0xFFD7	;(1) ACE RS232 Character position
      = FFD8            ISR_FLAGS	equ	0xFFD8	;(1) Indicates how many levels the ISR has nested
      = FFD9            RRSTATE		equ	0xFFD9	;(1) RAM/ROM SELECT STATE (FOR RETURN FROM ISR)	
      = FFDA            XTIMER_TIC	equ	0xFFDA	;(1) Counts Down tics until Extended Timer ISR_EXXTIMER
      = FFDB            READ_RAMROM	equ	0xFFDB	;(1) Selected RAMROM for Monitor READ Operations.  Bit0 for RAM/ROM, Bits1-4 for Bank

      = FFDC            NMI_VEC		equ	0xFFDC	;(2) NMI VEC.  Not used

      = FFDE            CTRL_C_TIMER	equ	0xFFDE	;Count down the CTRL-C condition
      = FFDF            SOFT_RST_FLAG	equ	0xFFDF	;Flag a Soft Reset (F-E Keys, Single Step)

                        				;Display/Serial Comms
      = FFE0            LED_DISPLAY	equ	0xFFE0	;8 Bytes of LED Output bytes to Scan to hardware
                        ;8 Bytes			;Warning, LED_DISPLAY must be nibble aligned at E0 (XXE0)
      = FFE7            LED_ANBAR	equ	0xFFE7	;LED Annunciator Bar (Part of LED_DISPLAY Buffer)
                        				;.0 = x7 = BEEPER
                        				;.1 = x6 = Run Mode
                        				;.2 = x5 = Monitor Mode (Default Mode upon Power up)
                        				;.3 = x4 = Send Data to Output Port
                        				;.4 = x3 = Alter Memory/Register
                        				;.5 = x2 = Enter Memory Location
                        				;.6 = x1 = Enter Register

      = FFE8            KBCOLSAMPLED	equ	0xFFE8	;Columns Sampled
      = FFE9            KBPORTSAMPLE	equ	0xFFE9	;Input Port sampled only once on each scan, saved here
      = FFEA            KBHEXSAMPLE	equ	0xFFEA	;KEY SAMPLER Input HEX format
      = FFEB            KEYBSCANPV	equ	0xFFEB	;KEY Input HEX format
      = FFEC            KEYBSCANTIMER	equ	0xFFEC	;KEY Input TIMER
      = FFED            KEY_PRES_EV	equ	0xFFED	;KEY INPUT LAST & Currently Processing
      = FFEE            KEY_PRES_RTN	equ	0xFFEE	;KEY LAST, for Return To Normal between strokes
      = FFEF            KEY_PRESSED	equ	0xFFEF	;(1) KEY PRESSED

      = FFF0            TicCounter	equ	0xFFF0	;Tic Counter
                        ;TicCounter	equ	0xFFF1	;
      = FFF2            ECHO_STATE	equ	0xFFF2	;Echo characters
      = FFF3            XMSEQ		equ	0xFFF3	;XMODEM SEQUENCE NUMBER
      = FFF4            XMTYPE		equ	0xFFF4	;XMODEM BLOCK TYPE (CRC/CS)
      = FFF5            SCAN_LED	equ	0xFFF5	;Holds the next LED output
      = FFF6            LED_DISPLAY_SB	equ	0xFFF6	;10 Bytes FFF6=Start BIT, 7,8,9,A,B,C,D,E=Data bits, F=Stop BIT
                        ;10 bytes	equ	0xFFFF	;Warning, LED_DISPLAY_TBL must be at this address (XXF6) Roll over to xx00 tested



                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Appendix_D	HOOK LOCATIONS
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;

0042                    		org	0x0042
0042  C3 E203           VMAIN_MENU	JP	MAIN_MENU	;MONITOR
0045  C3 E813           VPUT_CHAR	JP	PUT_CHAR	;PUT_CHAR
0048  C3 C913           VGET_POS	JP	GET_POS		;Return the Position of the cursor on the line
004B  C3 DC13           VGET_CHAR	JP	GET_CHAR
004E  C3 0414           VRX_COUNT	JP	RX_COUNT	;Count of Characters waiting in the RX Buffer
0051  C3 1D14           VIN_CHAR	JP	IN_CHAR		;Returns a char or C=1 if none.
0054  C3 4714           VTIMED_GETCHAR	JP	TIMED_GETCHAR
0057  C3 BD0D           VPRINT		JP	PRINT
005A  C3 CC27           VBEEP		JP	BEEP

005D  C3 D027           VSET_ECHO	JP	SET_ECHO
0060  C3 2C0E           VDELAY_C	JP	DELAY_C		;Loop based on C, 100mSEC
0063  C3 3A0E           VDELAY_A	JP	DELAY_A		;Milli seconds based on A, requires FP board

006B                    		org	0x006B
006B  C3 9B08           VPUT_VERSION	JP	PUT_VERSION
006E  C3 090E           VPUT_HEX	JP	PUT_HEX
0071  C3 F60D           VPUT_BYTE	JP	PUT_BYTE
0074  C3 D80D           VPUT_BC		JP	PUT_BC
0077  C3 E10D           VPUT_DE		JP	PUT_DE
007A  C3 EA0D           VPUT_HL		JP	PUT_HL
007D  C3 190E           VPUT_SPACE	JP	PUT_SPACE
0080  C3 1F0E           VPUT_NEW_LINE	JP	PUT_NEW_LINE

0083  C3 4C0D           VGET_BYTE	JP	GET_BYTE
0086  C3 790D           VGET_WORD	JP	GET_WORD	;DE
0089  C3 950D           VGET_HEX	JP	GET_HEX

008C  C3 100C           VCLEAR_BLOCK	JP	CLEAR_BLOCK	;CLEAR_BLOCK
008F  C3 4A0E           VLD_HL_HL	JP	LD_HL_HL
0092  C3 450E           VADD_HL_A	JP	ADD_HL_A
0095  C3 3927           VMOV_32_HL	JP	MOV_32_HL	;Move (HL) to 32 bit register BCDE
0098  C3 4427           VMOV_HL_32	JP	MOV_HL_32	;Move 32 bit register BCDE to (HL)
009B  C3 4F27           VADD_32_HL	JP	ADD_32_HL	;ADD (HL) to 32 bit register BCDE - (returns with HL changed to last byte)
009E  C3 7327           VCMP_HL_32	JP	CMP_HL_32	;Compare BCDE with 32bit word at HL
00A1  C3 6027           VINC_32		JP	INC_32		;INC BCDE
00A4  C3 6627           VDEC_32		JP	DEC_32		;DEC BCDE
00A7  C3 6E27           VTSTZ_32	JP	TSTZ_32		;TEST_ZERO BCDE

00AA  C3 BD27           VASC2BIN	JP	ASC2BIN
00AD  C3 980D           VASC2HEX	JP	ASC2HEX
00B0  C3 0F0E           VHEX2ASC	JP	HEX2ASC		
00B3  C3 AD27           VTO_UPPER	JP	TO_UPPER

00B6  C3 8213           VSET_IO		JP	SET_IO
00B9  C3 B614           VIC_KEY		JP	IC_KEY
00BC  C3 D427           VLED_UPDATE	JP	LED_UPDATE	;Turn ON/OFF LED UPDATE & KEY MON

00BF  C3 E427           VLED_GET_POS	JP	LED_GET_POS
00C2  C3 EA27           VLED_SET_POS	JP	LED_SET_POS
00C5  C3 7314           VLED_HOME	JP	LED_HOME
00C8  C3 8614           VLED_PUT_CHAR	JP	PC_LED		;C = CHAR
00CB  C3 741C           VLED_PRINT	JP	LED_PRINT
00CE  C3 5C1C           VLED_PUT_BYTE	JP	LED_PUT_BYTE
00D1  C3 681C           VLED_PUT_HEX	JP	LED_PUT_HEX
00D4  C3 7C14           VLED_CLEAR	JP	LED_CLEAR
00D7  C3 F227           VLED_RIGHT	JP	LED_RIGHT
00DA  C3 0728           VLED_LEFT	JP	LED_LEFT

00DD  C3 0021           VPRINT_FNAME	JP	PRINT_FILENAME
00E0  C3 2521           VINPUT_FNAME	JP	INPUT_FILENAME
00E3  C3 B11D           VSD_OPEN	JP	SD_OPEN			;Copy FCB to filename then search & open
00E6  C3 A41D           VSD_OPEN_FILENAME JP	SD_OPEN_FILENAME	;Copy Filename to FCB then search & open
00E9  C3 5A1D           VPRINT_DIR	JP	PRINT_DIR
00EC  C3 8321           VDISK_READ	JP	DISK_READ
00EF  C3 9124           VSD_READ_SEC	JP	SD_READ_SEC
00F2  C3 231E           VLINE_INPUT	JP	LINE_INPUT

00F5   (0000)           		END	0

                        ;                       *********   *******    *********
                        ;                       *********  *********   *********
                        ;                       **         **     **   **
                        ;                       **         **     **   **
                        ;---------------------  *******    **     **   *******    ---------------------
                        ;---------------------  *******    **     **   *******    ---------------------
                        ;                       **         **     **   **
                        ;                       **         **     **   **
                        ;                       *********  *********   **
                        ;                       *********   *******    **

                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                        ;	Appendix_E	Z80 Instruction Reference
                        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;

                        ;===================================================
                        ;Mnemonic	Cyc	Opcodes		Bytes
                        ;ADC A,(HL)	7	8E		1
                        ;ADC A,(IX+o)	19	DD 8E oo	3
                        ;ADC A,(IY+o)	19	FD 8E oo	3
                        ;ADC A,n	7      	CE nn        	2
                        ;ADC A,r	4	88+r		1
                        ;ADC A,IXp	8	DD 88+P		2
                        ;ADC A,IYp	8	FD 88+P		2
                        ;ADC HL,BC	15	ED 4A		2
                        ;ADC HL,DE	15	ED 5A		2
                        ;ADC HL,HL	15	ED 6A		2
                        ;ADC HL,sp	15	ED 7A		2
                        ;ADD A,(HL)	7	86		1
                        ;ADD A,(IX+o)	19	DD 86 oo	3
                        ;ADD A,(IY+o)	19	FD 86 oo	3
                        ;ADD A,n	7      	C6 nn		2
                        ;ADD A,r	4	80+r		1
                        ;ADD A,IXp      8      	DD 80+P		2
                        ;ADD A,IYp      8      	FD 80+P		2
                        ;ADD HL,BC	11	09		1
                        ;ADD HL,DE	11	19		1
                        ;ADD HL,HL	11	29		1
                        ;ADD HL,sp	11	39		1
                        ;ADD IX,BC	15	DD 09		2
                        ;ADD IX,DE	15	DD 19		2
                        ;ADD IX,IX	15	DD 29		2
                        ;ADD IX,sp	15	DD 39		2
                        ;ADD IY,BC	15	FD 09		2
                        ;ADD IY,DE	15	FD 19		2
                        ;ADD IY,IY	15	FD 29		2
                        ;ADD IY,sp	15	FD 39		2
                        ;AND (HL)	7	A6		1
                        ;AND (IX+o)	19	DD A6 oo	3
                        ;AND (IY+o)	19	FD A6 oo	3
                        ;AND n       	7      	E6 nn		2
                        ;AND r		4	A0+r		1
                        ;AND IXp        8      	DD A0+P		2
                        ;AND IYp        8      	FD A0+P		2
                        ;BIT B,(HL)	12	CB 46+8*B	2	Test BIT B (AND the BIT, but do not save), Z=1 if BIT tested is 0
                        ;BIT B,(IX+o)	20	DD CB oo 46+8*B	4	Test BIT B (AND the BIT, but do not save), Z=1 if BIT tested is 0
                        ;BIT B,(IY+o)	20	FD CB oo 46+8*B	4	Test BIT B (AND the BIT, but do not save), Z=1 if BIT tested is 0
                        ;BIT B,r	8	CB 40+8*B+r	2	Test BIT B (AND the BIT, but do not save), Z=1 if BIT tested is 0
                        ;CALL nn	17	CD nn nn	3
                        ;CALL C,nn	17/10	DC nn nn	3
                        ;CALL M,nn	17/10	FC nn nn	3
                        ;CALL NC,nn	17/10	D4 nn nn	3
                        ;CALL NZ,nn	17/10	C4 nn nn	3
                        ;CALL P,nn	17/10	F4 nn nn	3
                        ;CALL PE,nn	17/10	EC nn nn	3
                        ;CALL PO,nn	17/10	E4 nn nn	3
                        ;CALL Z,nn	17/10	CALL C, nn nn	3
                        ;CCF		4	3F		1
                        ;CP (HL)	7	BE		1
                        ;CP (IX+o)	19	DD BE oo	3
                        ;CP (IY+o)	19	FD BE oo	3
                        ;CP n        	7      	FE nn		2
                        ;CP r		4	B8+r		1
                        ;CP IXp        	8      	DD B8+P		2
                        ;CP IYp        	8      	FD B8+P        	2
                        ;CPD		16	ED A9		2
                        ;CPDR		21/16	ED B9		2
                        ;CP		16	ED A1		2
                        ;CPIR		21/16	ED B1		2
                        ;CPL		4	2F		1
                        ;DAA		4	27		1
                        ;DEC (HL)	11	35		1
                        ;DEC (IX+o)	23	DD 35 oo	3
                        ;DEC (IY+o)	23	FD 35 oo	3
                        ;DEC A		4	3D		1
                        ;DEC B		4	05		1
                        ;DEC BC		6	0B		1
                        ;DEC C		4	0D		1
                        ;DEC D		4	15		1
                        ;DEC DE		6	1B		1
                        ;DEC E		4	1D		1
                        ;DEC H		4	25		1
                        ;DEC HL		6	2B		1
                        ;DEC IX		10	DD 2B		2
                        ;DEC IY		10	FD 2B		2
                        ;DEC IXp        8      	DD 05+8*P	2
                        ;DEC IYp        8      	FD 05+8*q      	2
                        ;DEC L		4	2D		2
                        ;DEC sp		6	3B		1
                        ;DI		4	F3		1
                        ;DJNZ o		13/8	10 oo		2
                        ;EI		4	FB		1
                        ;EX (sp),HL	19	E3		1
                        ;EX (sp),IX	23	DD E3		2
                        ;EX (sp),IY	23	FD E3		2
                        ;EX AF,AF'	4	08		1
                        ;EX	DE,HL	4	EB		1
                        ;EXX		4	D9		1
                        ;HALT		4	76		1
                        ;IM 0		8	ED 46		2
                        ;IM 1		8	ED 56		2
                        ;IM 2		8	ED 5E		2
                        ;IN A,(C)	12	ED 78		2
                        ;IN A,(n)	11	db nn		2
                        ;IN B,(C)	12	ED 40		2
                        ;IN C,(C)	12	ED 48		2
                        ;IN D,(C)	12	ED 50		2
                        ;IN E,(C)	12	ED 58		2
                        ;IN H,(C)	12	ED 60		2
                        ;IN L,(C)	12	ED 68		2
                        ;IN F,(C)	12	ED 70		3
                        ;INC (HL)	11	34		1
                        ;INC (IX+o)	23	DD 34 oo	3
                        ;INC (IY+o)	23	FD 34 oo	3
                        ;INC A		4	3C		1
                        ;INC B		4	04		1
                        ;INC BC		6	03		1
                        ;INC C		4	0C		1
                        ;INC D		4	14		1
                        ;INC DE		6	13		1
                        ;INC E		4	1C		1
                        ;INC H		4	24		1
                        ;INC HL		6	23		1
                        ;INC IX		10	DD 23		2
                        ;INC IY		10	FD 23		2
                        ;INC IXp        8      	DD 04+8*P	2
                        ;INC IYp       	8      	FD 04+8*q      	2
                        ;INC L		4	2C		1
                        ;INC sp		6	33		1
                        ;IND		16	ED AA		2
                        ;INDR		21/16	ED BA		2
                        ;INI		16	ED A2		2
                        ;INIR		21/16	ED B2		2
                        ;JP nn		10	C3 nn nn	3	Jump Absolute
                        ;JP (HL)	4	E9		1
                        ;JP (IX)	8	DD E9		2
                        ;JP (IY)	8	FD E9		2
                        ;JP C,nn	10	DA nn nn	3
                        ;JP M,nn	10	FA nn nn	3
                        ;JP NC,nn	10	D2 nn nn	3
                        ;JP NZ,nn	10	C2 nn nn	3
                        ;JP P,nn	10	F2 nn nn	3
                        ;JP PE,nn	10	EA nn nn	3
                        ;JP PO,nn	10	E2 nn nn	3
                        ;JP Z,nn	10	CA nn nn	3
                        ;JR o		12	18 oo		2	Jump Relative
                        ;JR C,o		12/7	38 oo		2
                        ;JR NC,o	12/7	30 oo		2
                        ;JR NZ,o	12/7	20 oo		2
                        ;JR Z,o		12/7	28 oo		2
                        ;LD (BC),A	7	02		1
                        ;LD (DE),A	7	12		1
                        ;LD (HL),n      10     	36 nn		2
                        ;LD (HL),r	7	70+r		1
                        ;LD (IX+o),n    19     	DD 36 oo nn	4
                        ;LD (IX+o),r	19	DD 70+r oo	3
                        ;LD (IY+o),n    19     	FD 36 oo nn	4
                        ;LD (IY+o),r	19	FD 70+r oo	3
                        ;LD (nn),A	13	32 nn nn	3
                        ;LD (nn),BC	20	ED 43 nn nn	4
                        ;LD (nn),DE	20	ED 53 nn nn	4
                        ;LD (nn),HL	16	22 nn nn	3
                        ;LD (nn),IX	20	DD 22 nn nn	4
                        ;LD (nn),IY	20	FD 22 nn nn	4
                        ;LD (nn),sp	20	ED 73 nn nn	4
                        ;LD A,(BC)	7	0A		1
                        ;LD A,(DE)	7	1A		1
                        ;LD A,(HL)	7	7E		1
                        ;LD A,(IX+o)	19	DD 7E oo	3
                        ;LD A,(IY+o)	19	FD 7E oo	3
                        ;LD A,(nn)	13	3A nn nn	3
                        ;LD A,n        	7     	3E nn		2
                        ;LD A,r		4	78+r		1
                        ;LD A,IXp       8      	DD 78+P        	2
                        ;LD A,IYp       8      	FD 78+P        	2
                        ;LD A,I		9	ED 57		2
                        ;LD A,R		9	ED 5F		2
                        ;LD B,(HL)	7	46		1
                        ;LD B,(IX+o)	19	DD 46 oo	3
                        ;LD B,(IY+o)	19	FD 46 oo	3
                        ;LD B,n        	7      	06 nn		2
                        ;LD B,r		4	40+r		1
                        ;LD B,IXp       8      	DD 40+P		2
                        ;LD B,IYp       8     	FD 40+P        	2
                        ;LD BC,(nn)	20	ED 4B nn nn	4
                        ;LD BC,nn	10	01 nn nn	3
                        ;LD C,(HL)	7	4E		1
                        ;LD C,(IX+o)	19	DD 4E oo	3
                        ;LD C,(IY+o)	19	FD 4E oo	3
                        ;LD C,n        	7      	0E nn        	2
                        ;LD C,r		4	48+r		1
                        ;LD C,IXp       8      	DD 48+P        	2
                        ;LD C,IYp       8      	FD 48+P		2
                        ;LD D,(HL)	7	56		1
                        ;LD D,(IX+o)	19	DD 56 oo	3
                        ;LD D,(IY+o)	19	FD 56 oo	3
                        ;LD D,n        	7      	16 nn		2
                        ;LD D,r		4	50+r		1
                        ;LD D,IXp       8      	DD 50+P        	2
                        ;LD D,IYp       8      	FD 50+P        	2
                        ;LD DE,(nn)	20	ED 5B nn nn	4
                        ;LD DE,nn	10	11 nn nn	3
                        ;LD E,(HL)	7	5E		1
                        ;LD E,(IX+o)	19	DD 5E oo	3
                        ;LD E,(IY+o)	19	FD 5E oo	3
                        ;LD E,n        	7      	1E nn        	2
                        ;LD E,r		4	58+r		1
                        ;LD E,IXp       8      	DD 58+P        	2
                        ;LD E,IYp       8      	FD 58+P        	2
                        ;LD H,(HL)	7	66		1
                        ;LD H,(IX+o)	19	DD 66 oo	3
                        ;LD H,(IY+o)	19	FD 66 oo	3
                        ;LD H,n        	7      	26 nn		2
                        ;LD H,r		4	60+r		1
                        ;LD HL,(nn)	16	2A nn nn	5
                        ;LD HL,nn	10	21 nn nn	3
                        ;LD I,A		9	ED 47		2
                        ;LD IX,(nn)	20	DD 2A nn nn	4
                        ;LD IX,nn	14	DD 21 nn nn	4
                        ;LD IXh,n       11     	DD 26 nn 	2
                        ;LD IXh,P       8     	DD 60+P		2
                        ;LD IXl,n       11     	DD 2E nn 	2
                        ;LD IXl,P       8     	DD 68+P		2
                        ;LD IY,(nn)	20	FD 2A nn nn	4
                        ;LD IY,nn	14	FD 21 nn nn	4
                        ;LD IYh,n       11     	FD 26 nn 	2
                        ;LD IYh,q       8     	FD 60+P		2
                        ;LD IYl,n       11     	FD 2E nn 	2
                        ;LD IYl,q       8     	FD 68+P		2
                        ;LD L,(HL)	7	6E		1
                        ;LD L,(IX+o)	19	DD 6E oo	3
                        ;LD L,(IY+o)	19	FD 6E oo	3
                        ;LD L,n       	7     	2E nn		2
                        ;LD L,r		4	68+r		1
                        ;LD R,A		9	ED 4F		2
                        ;LD sp,(nn)	20	ED 7B nn nn	4
                        ;LD sp,HL	6	F9		1
                        ;LD sp,IX	10	DD F9		2
                        ;LD sp,IY	10	FD F9		2
                        ;LD sp,nn	10	31 nn nn	3
                        ;LDD		16	ED A8		2
                        ;LDDR		21/16	ED B8		2
                        ;LDI		16	ED A0		2
                        ;LDIR		21/16	ED B0		2
                        ;MULUB A,r 		ED C1+8*r 	2
                        ;MULUW HL,BC		ED C3 		2
                        ;MULUW HL,sp		ED F3 		2
                        ;NEG		8	ED 44		2
                        ;NOP		4	00		1
                        ;OR (HL)	7	B6		1
                        ;OR (IX+o)	19	DD B6 oo	3
                        ;OR (IY+o)	19	FD B6 oo	3
                        ;OR n       	7     	F6 nn		2
                        ;OR r		4	B0+r		1
                        ;OR IXp       	8     	DD B0+P		2
                        ;OR IYp       	8     	FD B0+P		2
                        ;OTDR		21/16	ED BB		2
                        ;OTIR		21/16	ED B3		2
                        ;OUT (C),A	12	ED 79		2
                        ;OUT (C),B	12	ED 41		2
                        ;OUT (C),C	12	ED 49		2
                        ;OUT (C),D	12	ED 51		2
                        ;OUT (C),E	12	ED 59		2
                        ;OUT (C),H	12	ED 61		2
                        ;OUT (C),L	12	ED 69		2
                        ;OUT (n),A	11	D3 nn		2
                        ;OUTD		16	ED AB		2
                        ;OUTI		16	ED A3		2
                        ;POP AF		10	F1		1
                        ;POP BC		10	C1		1
                        ;POP DE		10	D1		1
                        ;POP HL		10	E1		1
                        ;POP IX		14	DD E1		2
                        ;POP IY		14	FD E1		2
                        ;PUSH AF	11	F5		1
                        ;PUSH BC	11	C5		1
                        ;PUSH DE	11	D5		1
                        ;PUSH HL	11	E5		1
                        ;PUSH IX	15	DD E5		2
                        ;PUSH IY	15	FD E5		2
                        ;RES B,(HL)	15	CB 86+8*B	2	Reset BIT B (clear BIT)
                        ;RES B,(IX+o)	23	DD CB oo 86+8*B	4	Reset BIT B (clear BIT)
                        ;RES B,(IY+o)	23	FD CB oo 86+8*B	4	Reset BIT B (clear BIT)
                        ;RES B,r	8	CB 80+8*B+r	2	Reset BIT B (clear BIT)
                        ;RET		10	C9		1
                        ;RET C		11/5	D8		1
                        ;RET M		11/5	F8		1
                        ;RET NC		11/5	D0		1
                        ;RET NZ		11/5	C0		1
                        ;RET P		11/5	F0		1
                        ;RET PE		11/5	E8		1
                        ;RET PO		11/5	E0		1
                        ;RET Z		11/5	C8		1
                        ;RETI		14	ED 4D		2
                        ;RETN		14	ED 45		2
                        ;RL (HL)	15	CB 16		2  	9 BIT rotate left through Carry
                        ;RL (IX+o)	23	DD CB oo 16	4	9 BIT rotate left through Carry
                        ;RL (IY+o)	23	FD CB oo 16	4	9 BIT rotate left through Carry
                        ;RL r       	8     	CB 10+r		2	9 BIT rotate left through Carry
                        ;RLA		4	17		1	9 BIT rotate left through Carry
                        ;RLC (HL)	15	CB 06		2	8 BIT rotate left, C=msb
                        ;RLC (IX+o)	23	DD CB oo 06	4	8 BIT rotate left, C=msb
                        ;RLC (IY+o)	23	FD CB oo 06	4	8 BIT rotate left, C=msb
                        ;RLC r		8	CB 00+r		2	8 BIT rotate left, C=msb
                        ;RLCA		4	07		1	8 BIT rotate left, C=msb
                        ;RLD		18	ED 6F		2	3 nibble rotate, A3-0 to (HL)3-0, (HL)3-0 to (HL)7-4, (HL)7-4 to A3-0
                        ;RR (HL)	15	CB 1E		2	9 BIT rotate right through Carry
                        ;RR (IX+o)	23	DD CB oo 1E	4	9 BIT rotate right through Carry
                        ;RR (IY+o)	23	FD CB oo 1E	4	9 BIT rotate right through Carry
                        ;RR r       	8     	CB 18+r		2	9 BIT rotate right through Carry
                        ;RRA		4	1F		1	9 BIT rotate right through Carry
                        ;RRCA (HL)	15	CB 0E		2	8 BIT rotate right, C=lsb
                        ;RRCA (IX+o)	23	DD CB oo 0E	4	8 BIT rotate right, C=lsb
                        ;RRCA (IY+o)	23	FD CB oo 0E	4	8 BIT rotate right, C=lsb
                        ;RRCA r		8	CB 08+r		2	8 BIT rotate right, C=lsb
                        ;RRCAA		4	0F		1	8 BIT rotate right, C=lsb
                        ;RRD		18	ED 67		2	3 nibble rotate, A3-0 to (HL)7-4, (HL)7-4 to (HL)3-0, (HL)3-0 to A3-0
                        ;RST 0		11	C7		1
                        ;RST 8H		11	CF		1
                        ;RST 10H	11	D7		1
                        ;RST 18H	11	DF		1
                        ;RST 20H	11	E7		1
                        ;RST 28H	11	EF		1
                        ;RST 30H	11	F7		1
                        ;RST 38H	11	FF		1
                        ;SBC A,(HL)	7	9E		1
                        ;SBC A,(IX+o)	19	DD 9E oo	3
                        ;SBC A,(IY+o)	19	FD 9E oo	3
                        ;SBC A,n	7	DE nn		2
                        ;SBC A,r	4	98+r		1
                        ;SBC A,IXp      8     	DD 98+P		2
                        ;SBC A,IYp      8     	FD 98+P		2
                        ;SBC HL,BC	15	ED 42		2
                        ;SBC HL,DE	15	ED 52		2
                        ;SBC HL,HL	15	ED 62		2
                        ;SBC HL,sp	15	ED 72		2
                        ;SCF		4	37		1	Set Carry
                        ;SET B,(HL)	15	CB C6+8*B	2	Set BIT B (0-7)
                        ;SET B,(IX+o)	23	DD CB oo C6+8*B	4	Set BIT B (0-7)
                        ;SET B,(IY+o)	23	FD CB oo C6+8*B	4	Set BIT B (0-7)
                        ;SET B,r	8	CB C0+8*B+r	2	Set BIT B (0-7)
                        ;SLA (HL)	15	CB 26		2	9 BIT shift left, C=msb, lsb=0
                        ;SLA (IX+o)	23	DD CB oo 26	4	9 BIT shift left, C=msb, lsb=0
                        ;SLA (IY+o)	23	FD CB oo 26	4	9 BIT shift left, C=msb, lsb=0
                        ;SLA r		8	CB 20+r		2	9 BIT shift left, C=msb, lsb=0
                        ;SRA (HL)	15	CB 2E		2	8 BIT shift right, C=lsb, msb=msb (msb does not change)
                        ;SRA (IX+o)	23	DD CB oo 2E	4	8 BIT shift right, C=lsb, msb=msb (msb does not change)
                        ;SRA (IY+o)	23	FD CB oo 2E	4	8 BIT shift right, C=lsb, msb=msb (msb does not change)
                        ;SRA r		8	CB 28+r		2	8 BIT shift right, C=lsb, msb=msb (msb does not change)
                        ;SRL (HL)	15	CB 3E		2	8 BIT shift right, C=lsb, msb=0
                        ;SRL (IX+o)	23	DD CB oo 3E	4	8 BIT shift right, C=lsb, msb=0
                        ;SRL (IY+o)	23	FD CB oo 3E	4	8 BIT shift right, C=lsb, msb=0
                        ;SRL r		8	CB 38+r		2	8 BIT shift right, C=lsb, msb=0
                        ;SUB (HL)	7	96		1
                        ;SUB (IX+o)	19	DD 96 oo	3
                        ;SUB (IY+o)	19	FD 96 oo	3
                        ;SUB n       	7     	D6 nn		2
                        ;SUB r		4	90+r		1
                        ;SUB IXp       	8     	DD 90+P		2
                        ;SUB IYp       	8     	FD 90+P		2
                        ;XOR (HL)	7	AE		1
                        ;XOR (IX+o)	19	DD AE oo	3
                        ;XOR (IY+o)	19	FD AE oo	3
                        ;XOR n       	7     	EE nn		2
                        ;XOR r       	4     	A8+r		1
                        ;XOR IXp       	8     	DD A8+P		2
                        ;XOR IYp       	8     	FD A8+P		2
                        ;
                        ;variables used:
                        ;
                        ; B = 3-BIT value
                        ; n = 8-BIT value
                        ; nn= 16-BIT value
                        ; o = 8-BIT offset (2-complement)
                        ; r = Register. This can be A, B, C, D, E, H, L OR (HL). Add to the last byte of the opcode:
                        ;
                        ;		Register	Register bits value
                        ;		A		7
                        ;		B		0
                        ;		C		1
                        ;		D		2
                        ;		E		3
                        ;		H		4
                        ;		L		5
                        ;		(HL)		6
                        ;
                        ; P = The high OR low part of the IX OR IY register: (IXh, IXl, IYh, IYl). Add to the last byte of the opcode:
                        ;
                        ;		Register	Register bits value
                        ;		A		7
                        ;		B		0
                        ;		C		1
                        ;		D		2
                        ;		E		3
                        ;		IXh (IYh)	4
                        ;		IXl (IYl)	5

                        				

00000 Total Error(s)

ABF1               27C1    ABFND              2B86    ABF_GOODHEX        27C6
ABORT_CHECK        136C    ABS_SEC            0018 E  ABUSS              FF88 E
ACE_BAUD           FF8F E  ACE_BAUD0          00C8 E  ACE_BAUD1          00C9 E
ACE_DATA           00C8 E  ACE_LCR            00CB E  ACE_MSR            00CE E
ACE_OUT            00CC E  ACE_RESET          00C7 E  ACE_SCRATCH        00CF E
ACE_SET_BAUD       14F2    ACE_STATUS         00CD E  ACK                0006 E
ADD                31E0    ADD_32_HL          274F    ADD_HL_A           0E45
AFCLUS0            000C E  ALOOK              2F89    ANBAR_DEF          FFB3 E
ARYL               31BF    ARYLOC             81FD E  ASC2BIN            27BD
ASC2HEX            0D98    ASST               32C8    ASTOR              32EB
AUTO_BOOT_DO       039B    AUTO_BOOT_GO       03C1    AUTO_BOOT_LP       03B6
AUTO_BOOT_MENU     0391    BADLIN             2D68    BADLN              2ACD
BASIC              2A00    BEEP               27CC    BEEP_TO            FFB2 E
BEXIT              0042 E  BGETCHR            34ED    BINCHR             0051 E
BITS_Q2            00C2 E  BITS_Q3            00C3 E  BIT_MARCH          1244
BIT_TABLE          FF00    BOOT_SDVIEW        1D37    BPRINT             2E8D
BPUTCHR            0045 E  BPUTNL             0080 E  BPUTSP             007D E
BRKTS              31B9    BUFF               8000 E  BYTEMARCH2         11D7
BYTE_P_SEC         FF1F    CAFCLUS            0010 E  CALN               3175
CALS               2CDA    CAN                0018 E  CDAT               3037
CEIL               327B    CEXP               33CC    CG1                33D2
CH3_R1             2788    CH3_R2             2789    CH3_R3             278A
CHAR               30FC    CHK_RESET          0194    CHR                34E3
CINDX              34C3    CL2                34A8    CLBF               34A3
CLEAR              2CAF    CLEARED_LEN        002C E  CLEARED_SPACE      FFD4 E
CLEAR_BLOCK        0C10    CLEAR_LINE_BUFF    1EB5    CLRARY             2CCD
CMD                2A4E    CMD1               2A65    CMDL               2A52
CMPF_RETFAIL       2178    CMP_DE_HL          278C    CMP_FILENAME       215E
CMP_HL_32          2773    CMP_STRING         217B    COLD_START         01A5
COMA               308B    COMP               3265    COMSTR             3459
CPYL               32A0    CP_HL_DE           0B0B    CQ                 33F7
CR                 000D E  CRC_UPC            10F7    CRC_UPDATE         10D2
CRFCLUS            000E E  CS                 81FA E  CSAV               2FDA
CSP                81FB E  CSTK               35C1    CS_CLR_LEN         000F E
CTRLC              34E7    CTRL_C_CHK         FFB8 E  CTRL_C_CHK_OFF     1831
CTRL_C_CHK_ON      182A    CTRL_C_IN_Q        1821    CTRL_C_RET         17AE
CTRL_C_TEST        1813    CTRL_C_TIMER       FFDE E  CURSOR             80FB E
CV                 33E7    CVL1               2CC6    CVLP               2CB9
DAT1               307E    DATA               8238 E  DATASTART          FF39
DATCMD             3517    DBS_LP             272B    DC1                0011 E
DC3                0013 E  DCLB               31CC    DD_NEXT            1D9F
DD_TAB_LP          1D92    DECP1              2EB7    DECPRT             2EB2
DEC_32             2766    DEC_32NB           276C    DEL                2BB6
DELAY_100MS        0E2A    DELAY_A            0E3A    DELAY_C            0E2C
DELAY_LP           0E2F    DELETE             007F E  DELLP              2BBF
DELNX              2BBA    DER                359F    DERR               3019
DF_SHIFTCNT        FF54    DGC_DOT            143C    DGC_RET            1443
DIM                2F3E    DIM0               2F42    DIMERR             2FAF
DIRTY_DATA         FF0F    DIR_SECTOR         FF35    DISK_READ          2183
DISPLABEL          FFC2 E  DISPMODE           FFBC E  DISP_RRBANK        087A
DIV                3213    DIV16BY8           2712    DIV16BY8SPC        270F
DIV16BY8_LP        2718    DIV16BY8_SK        2721    DIVBYSHIFT         2727
DIVBYT             3237    DIVIDE_FUNC        FF52    DIVTOP             323B
DIVZE              325F    DLE                0010 E  DLOOP              2F5C
DLYLP              0E3F    DL_P1E             0AD4    DL_P1L             0AC1
DL_P2              0ADC    DL_P2K1            0AF8    DL_P2K2            0AFE
DL_P2L             0AEF    DL_PSE2            0AED    DL_PSL2            0AE3
DMULT              31F4    DODIV              3229    DOEXP              313E
DOT_GETCHAR        142E    DO_DIR             1D46    DO_HALT_TEST       16E8
DRR_ROM            0892    DRSS_LP            2283    DRSS_SHIFT         228B
DRS_0              224A    DR_1               21AE    DR_BIGGER_CLUS     21F4
DR_DIFF_CLUS       21EB    DR_NEW_SEC         21CB    DR_READ_IT         22D0
DR_SAME_CLUS       22AD    DR_SEEK_1          2236    DR_SEEK_DONE       2264
DR_SEEK_FAT        21FC    DR_SEEK_LP         21FF    DTXT               35F1
DUMP_LINE          0AAA    ECHO_STATE         FFF2 E  EDBUF              8100 E
EDIT               2BAF    EFLAG              8237 E  EG1                333A
EGO                3343    EGO1               314F    EGO2               339C
EGOF0              336E    EGOF1              336D    EGOF2              336C
EGOP1              3373    EGZ                3340    ELOOP              2B9E
EM                 363D    ENDAT              306B    ENDIT              364D E
ENOP               32C3    ENT_COUNT          FF41    EOF                2C4E
EOS                0000 E  EOT                0004 E  EQUAL              3305
ERR                2A80    ESP1               30EE    ETOP               30DF
EVAL               30DA    EXEC_RAM_2F8       0185    EXPR               3135
FAT1START          FF31    FAT_CLEAR          FF0A E  FAT_CLR_LEN        0039 E
FAT_COPIES         FF24    FB_LP              0C17    FCB_PTR            FF08
FE                 33A0    FILBUF             34DB    FILEEXT            FF4B
FILENAME           FF43    FILESIZE           FF4E    FILESYS_SEC        FF27
FILL_BLOCK         0C16    FILL_BT            0146    FINTO              2D84
FIXIT              2AB4    FLOR               326B    FNAME              0001 E
FNDLIN             2C19    FOR                2D7B    FSIZE              001C E
FSOL               2AA2    FSTAT              0000 E  FTHEN              2E1B
GADV               2B49    GB_1               0D57    GB_2               0D6B
GB_RET             0D73    GB_RET1            0D6E    GCHR               2F0C
GDEND              308C    GEQL               3313    GETDAT             305D
GETEOF             30BB    GETHEXFILE         0E4F    GETHX              3196
GETLN              2B9B    GET_BYTE           0D4C    GET_CHAR           13DC
GET_CHAR_LP        13E2    GET_CHAR_NE        13D6    GET_CONTINUE       0A82
GET_DISPMODE       1AA5    GET_HEX            0D95    GET_MEM            FB45 E
GET_MEM_OFF        001B E  GET_POS            13C9    GET_REG            FFB4 E
GET_REGISTER       0C6D    GET_REGNAME        0C2E    GET_REG_MON        0C71
GET_REG_RUN        0C7C    GET_STRING         2792    GET_WORD           0D79
GE_STACKFAIL       0BDB    GF0                2B6D    GF1                2B6C
GF2                2B79    GF3                2B7A    GFIND              2B67
GHC_ARET           0DB8    GHC_NOT_RET        0DB6    GHC_NRET           0DBA
GHENDTO            0EA8    GH_EXEC            202D    GH_EXEC_GO         2054
GH_EXEC_GO2        2057    GH_START           FF0A    GIN1               2B95
GINST              2B8A    GLINE              2AD0    GLPD               2D53
GLPO               2D4B    GLPX               30C0    GO                 2C89
GOSUB              2D3B    GOTCMD             2A6F    GOTDEF             2A6E
GOTO               2D43    GO_BASIC           2A00    GO_EXEC            0B71
GO_EXEC_T          0B60    GO_SD_CARD         1C8F    GO_SINGLE          1A3C
GREEN_LED          00C6 E  GRR_SUB            0CC1    GRR_SUB_AF         0CC7
GRR_SUB_AFA        0CF3    GRR_SUB_BC         0CCF    GRR_SUB_BCA        0CF8
GRR_SUB_DE         0CD2    GRR_SUB_DEA        0CFD    GRR_SUB_HL         0CD5
GRR_SUB_HLA        0D02    GRR_SUB_IR         0CEC    GRR_SUB_IX         0CE4
GRR_SUB_IY         0CE8    GRR_SUB_PC         0CDD    GRR_TBL            0CA1
GRTR               32A4    GRUB               2B58    GSC_INIT           1C90
GS_ESC             10C1    GS_OK              1A6A    GS_SEQ             10C4
GW_LP              0D87    HALT_TEST          FFD2 E  HERE1              FB5B E
HEX2ABUSS          191C    HEX2ASC            0E0F    HEX2IN_PTR         1974
HEX2MEM            1980    HEX2OUT_PORT       198B    HEX2OUT_PTR        197A
HEX2REG            1925    HEXGO              3191    HEXVL              317B
HEX_CURSOR         FFC4 E  HEX_READY          FFC6 E  HEX_SOURCE         FF5B
HGON               31B0    HIDDEN_SEC         FF2B    HISG               31AB
HPOUT              2C57    HRAM_CODE          FB2A    HR_EXEC_GO_SUB     207E
HR_EXEC_GS_LEN     0008 E  HR_EXE_GO          FB53    HW_LIST            FF95 E
HW_SETIO           FF94 E  ICMA_IO            1ACB    ICMA_REG           1AC4
ICMB_IO            1AF6    ICMB_REG           1AE5    ICMD0              1893
ICMD0_R            1AE8    ICMD1              1997    ICMD2              1997
ICMD3              1997    ICMD4              1997    ICMD4_EXEC         184B
ICMD5              1997    ICMD6              19B4    ICMD7              1A2C
ICMDA              1AB1    ICMDB              1AD2    ICMDD              1AFD
ICMDE              18A9    ICMD_AMEM          1B06    ICMD_BREAK         17FC
ICMD_BREAK_RET     17FE    ICMD_BYTE          1934    ICMD_BYTE2         1965
ICMD_IO            1B41    ICMD_IO_OUT        1B46    ICMD_REG           1B25
ICMD_SET_REG       1AEB    ICMD_SR_OK         1AF0    ICMD_WORD          18C6
ICMD_WORD1         18FD    ICMD_WORD2         1904    ICMD_WORDN1        18F0
ICMD_WORD_RET      190B    IC_ACE             14CB    IC_BIT             1513
IC_BOTH            1466    IC_KEY             14B6    IDDR_DISP          19E8
IDISP_DELAY        1C3C    IDISP_IN           1BCC    IDISP_IN_DATA      1BE3
IDISP_MEM          1B98    IDISP_MEM_DATA     1BB0    IDISP_OFF          1C28
IDISP_OUT          1C01    IDISP_OUT_DATA     1C18    IDISP_REG          1B63
IDISP_REG_DATA     1B75    IDISP_RET          17DF    IDO_LP             1C30
IDRRC_2ROM         1A26    IDRRC_RET          1A27    IDRRC_ROM          1A22
IDRR_ROM           1A01    IERMS              35AE    IF                 2E16
IFLAG              8235 E  IKC_REFRESH        17CB    IKC_RESET_CMD      17BA
IKEY0_UP           172B    IKEY1_UP           1734    IKEYF_UP           1747
IKEYP_EVENT        176F    IKEYP_EVENT_DN     1775    IKEYP_NCOS         1759
IKEY_DEBOUNCE      1750    IKEY_DONE          17DB    IKEY_NO_BEEP       17EC
IKEY_SCAN_END      17F2    IKR_QREFRESH       17D1    IK_HEXH            FF5A
IK_HEXL            FF59    IK_HEXST           FFC3 E  IK_KEYDN_EVENT     1792
IK_KEYUP_EVENT     1784    IK_NOKEY_EVENT     17AA    IK_RTN             179C
IK_TIMER           FFC0 E  IL01               2BEA    IL02               2C0A
ILP                2BD0    IMON_CMD           183E    IMON_TBL           1853
INCHAR_EXE         FF92 E  INC_32             2760    IND                2B18
INERR              2F31    INIT               2A1D    INITFAT_C1_DONE    237D
INITFAT_C2_DONE    239C    INITFAT_C2_LP      238B    INITFAT_C3_0       23D5
INITFAT_C3_1       23F8    INITFAT_C3_ERR     23BE    INITFAT_C3_LP      23A8
INITFAT_C3_LP2     23D7    INITFAT_C3_LP3     23E7    INITFAT_C4_1       240D
INITFAT_C4_2       2423    INITFAT_C4_3       2428    INITFAT_C4_LP      2408
INITFAT_FAIL       2466    INITFAT_FAIL1      2450    INITFAT_PGOOD      2316
INITFAT_TFS_DONE   235C    INITFAT_TFS_OK     2355    INIT_FAIL          25C5
INIT_FAT           22D7    INIT_SDCARD        2596    INIT_SYSTEM        0210
INL                35E0    INLF               2ABD    INLN               2BDF
INOK               2B2C    INP1               2EDF    INPUT              2ECB
INPUT_FILENAME     2125    INS                2BC7    INTRO              3600
INT_VEC            FFCE E  IN_CHAR            141D    IOCON              80FF E
IOD_TABLE          13B9    IOPTR              FF8B E  IO_MSG             07CD
IRAMROMBANK        19D9    IRAMROMBANK_CHG    1A0F    IRXD_BAD           1681
IRXD_INC           167C    IRXD_NB            1648    IRXD_NI            1650
IRXD_RESET         1687    IRXD_SAVE          1664    IRXD_STP           1657
IRXD_TINC          1684    IRXD_VS            1639    IRXD_WS            16A0
ISD_0              259B    ISD_1              25D6    ISD_2              25F7
ISD_3              2611    ISD_4              263A    ISD_5              266A
ISD_6              2673    ISD_LP1            25BA    ISD_LP2            2624
ISET_PRESSED       1838    ISINGLE            1A71    ISINGLE_DONE       1A98
ISINGLE_LP         1A91    ISR_DISPATCH       FB2A E  ISR_EXTIMER        16B5
ISR_EXTIMER_RET    16FC    ISR_EXXTIMER       1710    ISR_FLAGS          FFD8 E
ISR_RET            FB3B E  ISR_RET_OFF        0011 E  ISR_RXD            1637
ISR_TIMER          16A8    IS_CRLF            2027    IS_LETTER          27B6
KBCOLSAMPLED       FFE8 E  KBHEXSAMPLE        FFEA E  KBPORTSAMPLE       FFE9 E
KEYBFMODE          FFC1 E  KEYBSCANPV         FFEB E  KEYBSCANTIMER      FFEC E
KEY_EVENT          FFBE E  KEY_PRESSED        FFEF E  KEY_PRES_EV        FFED E
KEY_PRES_RTN       FFEE E  KTAB               3522    LAND               3289
LAST               823A E  LB_0               09F2    LB_1               09F8
LB_2               0A03    LB_OUT             0A06    LB_RET             0A0F
LDISPMODE          FFBA E  LD_HL_HL           0E4A    LEDL_LP            2813
LEDR_LP            27FE    LED_ANBAR          FFE7 E  LED_CLEAR          147C
LED_CURSOR         FFC8 E  LED_DISPLAY        FFE0 E  LED_DISPLAY_SB     FFF6 E
LED_FONT           2920    LED_GET_POS        27E4    LED_HEX            2900
LED_HOME           1473    LED_HOME_PRINTI    1C86    LED_LEFT           2807
LED_PRINT          1C74    LED_PRINTI         1C89    LED_PRINT_LP       1C76
LED_PRINT_RET      1C83    LED_PUT_BYTE       1C5C    LED_PUT_BYTE_HL    1C46
LED_PUT_HEX        1C68    LED_PUT_HEX_HL     1C4F    LED_RIGHT          27F2
LED_SET_POS        27EA    LED_SPLASH_TBL     027C    LED_UPDATE         27D4
LEQL               3320    LET                2DD2    LETH               32B5
LF                 000A E  LIF                2E39    LIN                35C9
LINEF              2C1F    LINE_BUFF          FA00    LINE_BUFFEND       FA80
LINE_INPUT         1E23    LIRET              2CAD    LIST               2C6B
LI_1               1E61    LI_1B              1E78    LI_2               1E7C
LI_3               1E88    LI_4               1E8C    LI_EOL             1E91
LI_FILESIZE        FA82    LI_GETDATA         1E9D    LI_LP              1E5E
LI_SDBUFF_PTR      FA86    LI_SDLOG_SEC       FA88    LI_TP              1E51
LNXT               2E3C    LOAD               30C9    LOAD_HIGH_RAM      281C
LOD1               30C9    LOGICAL_SEC        FF0D    LOOK               2FF8
LOOKT              2F9E    LOOKU              31C9    LOOP1              2AD7
LOOP_BACK_LP       09E7    LOOP_BACK_TEST     09B7    LOR                3296
LSPLASH_CNT        0278    LSTCHR             80F9 E  LTA                2FB5
MAIN_MENU          03E2    MEM_DUMP           0A5F    MEM_DUMP_0         0A61
MEM_DUMP_LP        0A68    MEM_DUMP_PAGED     0A7E    MEM_EDIT           0B1D
MEM_ENTER          0A15    MEM_ENTER_NEXTL    0A18    MEM_EXEC           0B43
MEN_1              0A37    MEN_CHK            0A2F    MEN_LP             0A1F
MEN_RET            0A29    MEXIT              320F    ME_1               0B5D
ME_LP              0B21    MODBYMASK          2734    MODMASK            FF58
MOD_FUNC           FF56    MORDAT             3051    MOVL               2B3D
MOV_32_HL          2739    MOV_HL_32          2744    MUL1               31F8
MUL8               FF55    MULT               31E4    NAK                0015 E
NEQL               3330    NEW                2A15    NEXT               2DE1
NEXTL              2C39    NMI_VEC            FFDC E  NOMAD              320B
NOMORE             2E11    NOON               2D5E    NOTFND             2C46
NOT_COLD           02F1    NP                 35D5    NSTERR             2D75
NUM                2AC6    NXLP               3259    OKKK               324D
OKPRT              2B07    OLOOK              31CD    ORDER              3004
OUTP               2E67    OUTPR              2E8B    OVER1              3253
OVM                35F6    OVRSUB             3258    P                  8236 E
PARSE              3103    PARSE1             3104    PCA_LP             14E2
PCLC_1             14AA    PCLC_LP            14A4    PCL_CTRL           1499
PCL_RET2           14B0    PCL_RETC           14AD    PC_0               1574
PC_1               1576    PC_10              15BD    PC_11              15C0
PC_12              15CA    PC_13              15CF    PC_14              15D4
PC_15              15E1    PC_16              15E2    PC_17              15EF
PC_18              15F4    PC_19              15F9    PC_2               157B
PC_20              1605    PC_3               1583    PC_4               158C
PC_5               159B    PC_6               15A2    PC_7               15A7
PC_8               15B1    PC_9               15B4    PC_ACE             14DC
PC_BIT             1534    PC_BOTH            146C    PC_LED             1486
PC_LP0             1549    PC_NCR             13FF    PC_NOFP            1556
PC_POS_UPDATE      13F8    PC_REDO            153D    PC_RET             161E
PC_RET1            1635    PERR               2A92    PLOT               2E44
PNUM               2C51    POPD               2DC7    POPS               2DB4
PORT40             0040 E  PORT_INP           0BFC    PORT_OUT           0C06
PORT_SPEED         080B    POS_ACE            FFD7 E  POS_BIT            FFD6 E
POUT               2C62    PRINS              2C92    PRINT              0DBD
PRINTB             0DD0    PRINTI             0DCA    PRINTM             0057 E
PRINT_BS           2118    PRINT_DIR          1D5A    PRINT_FILENAME     2100
PRINT_LP           0DBE    PRINT_MENU         0479    PRINT_RET          0DC8
PSH1               2DAE    PSH2               2DAF    PTAB               34F3
PU1                34B9    PURGE              1426    PURRS_RET          0C8D
PURR_SUB_AF        0D08    PURR_SUB_AFA       0D35    PURR_SUB_BC        0D0F
PURR_SUB_BCA       0D3A    PURR_SUB_DE        0D12    PURR_SUB_DEA       0D3F
PURR_SUB_HL        0D19    PURR_SUB_HLA       0D44    PURR_SUB_IR        0D2E
PURR_SUB_IX        0D26    PURR_SUB_IY        0D2A    PURR_SUB_PC        0D20
PURR_SUB_SP        0D07    PURR_TBL           0CB1    PUSHB              34B0
PUSHD              2DBD    PUSHS              2DA9    PUTCHAR_EXE        FF90 E
PUT_3C_SPACES      0B11    PUT_3C_SPACES_L    0B12    PUT_BC             0DD8
PUT_BYTE           0DF6    PUT_CHAR           13E8    PUT_DE             0DE1
PUT_HEX            0E09    PUT_HL             0DEA    PUT_IOMSG          07BA
PUT_NEW_LINE       0E1F    PUT_REG            FFB6 E  PUT_REGISTER       0C82
PUT_REG_MON        0C86    PUT_REG_RUN        0C91    PUT_SPACE          0E19
PUT_VERSION        089B    PV1                2EA5    PVH_0              08F8
PVH_1              0906    PZ                 2EA8    Q0                 3404
Q1                 3407    Q2                 3418    Q3                 3419
Q4                 3423    Q5                 3435    Q6                 344E
Q7                 345F    Q8                 346E    Q9                 347E
QPP                3420    QTST               348B    RAMROM             00C1 E
RAMSIGNATURE       FF78 E  RAMSIGN_LP         02EA    RAMSIG_LP          019B
RAM_LDRT           8000 E  RAM_TEST           1100    RANDR              33AD
RC_CC              FF83 E  RC_F0              FF85 E  RC_HALT            FF84 E
RC_HARD            FF87 E  RC_RST0            FF86 E  RC_SOFT            FF81 E
RC_STEP            FF82 E  RC_TYPE            FF80 E  RDY                3630
READ               301F    READ_HEX_EXEC      1EBE    READ_HEX_FILE      1EEF
READ_RAMROM        FFDB E  READ_SERIAL        0EC3    RECT               2B0E
REGNAMES           0C39    REGORDER           0942    REGPTR             FF8A E
REG_DISP_ALL       091F    REG_MENU           0915    REM                2E15
RESERVED_SEC       FF22    RESET              2CDF    RESETLDRT          0100
RESV               2A1A    RETRY              2EF2    RETURN             2D6E
RFLAG              8234 E  RFSEC              0012 E  RGON               2CFC
RHF_BYTE_LP        1F48    RHF_BYTE_LP2       1F46    RHF_DO             1F24
RHF_DO_NEXTL       2024    RHF_ERR_ON_LINE    1F89    RHF_LINE           1F2B
RHF_LINES          FA8A    RHF_LOOP           1EFC    RHF_NOT_HEX        1F5B
RHF_OK1            1F42    RHF_OK2            1F74    RHF_OK3            1FA7
RHF_OK4            1FC3    RHF_OK5            1FD7    RHF_OK6            2007
RHF_OK7            201F    RLOOP              2D04    RM_2               0966
RM_3               0971    RM_4               0976    RM_5               098C
RM_6               099A    RM_DUMP_REG        09AB    RM_DUMP_REG_C      09AA
RM_ERR             0986    RM_LP              0921    RM_NOTALL          094F
RNEWL              2D01    RNEXT              2D13    ROM_CODE           2828
ROM_CODE_LEN       0029 E  ROOTDIR_SIZE       FF25    RPC                FFA0 E
RRSTATE            FFD9 E  RS232_SPLASH       0316    RSAF               FF98 E
RSAF2              FFA8 E  RSBC               FF9A E  RSBC2              FFAA E
RSDE               FF9C E  RSDE2              FFAC E  RSHL               FF9E E
RSHL2              FFAE E  RSIR               FFA6 E  RSIS_LP            0136
RSIS_OK            0141    RSIX               FFA2 E  RSIY               FFA4 E
RSSP               FF96 E  RST38_LEN          0006 E  RS_CLP             0EC9
RS_COK             0EDC    RS_LP              0ECB    RS_TIMEOUT         0EEB
RT1_LP0            112B    RT1_LP1            112E    RT1_LP2            1130
RT1_LP3            113A    RT1_LP4            1140    RT1_LP5            1145
RT1_LP6            114B    RT1_LP7            115A    RT2_LP0            1183
RT2_LP1            1184    RT2_LP2            118D    RT2_LP3            1193
RT2_LP4            1199    RT2_NX1            11A8    RT3_LP1            1246
RT3_LP2            124E    RT3_LP3            124F    RT3_LP4            1259
RT3_LP5            125A    RT3_NX1            1273    RT4_LP0            11D9
RT4_LP1            11DE    RT4_LP2            11E0    RT4_LP3            11E9
RT4_LP4            11F0    RT4_LP5            11F8    RT4_LP6            11FD
RT4_LP7            120A    RT4_LP8            1219    RT4_NX             1214
RT5_LP1            1293    RT5_LP2            129C    RT5_LP3            12AB
RT5_NX1            12A0    RT5_NX2            12AF    RTHW_ADV           0160
RTHW_EXIT          0167    RTHW_LP            0150    RTHW_OK            015D
RTHW_SIOT_LP       0170    RTHW_SIO_EXIT      017E    RT_FAIL1           12DE
RT_FAIL2           1301    RT_FAIL3           1324    RT_FAIL5           1346
RT_GO              1118    RUN                2CEC    RXBHEAD            FFCA E
RXBTAIL            FFCC E  RXBUFFER           FE00    RXC_ACE            14C0
RXC_BIT            1505    RXC_BOTH           145D    RXC_DO             140A
RX_COUNT           1404    RX_ERR_LDRT        FF8C E  RX_ERR_OVR         FF8E E
RX_ERR_STOP        FF8D E  R_CC               0345    R_COLD             0326
R_F0               0357    R_HALT             034E    R_HARD             0369
R_RST0             0361    R_SOFT             0333    R_STEP             0340
SAVE               30CC    SCAN_LED           FFF5 E  SCAN_PTR           FFD0 E
SDCLK              00C0 E  SDCS               00C4 E  SDC_1              26A0
SDC_2              26A7    SDC_LP             26CA    SDC_MENU           1CE4
SDC_RET            26D7    SDC_STATUS         FF11    SDFF_LP            20BB
SDISKA             FB80    SDISKB             FBA0    SDISKC             FBC0
SDISKD             FBE0    SDISPMODE          FFD4 E  SDLF_LP            1D6F
SDO_DO             1DC3    SDO_RET            1E1D    SDTX               00C5 E
SDV_FIND_FILE      2086    SDV_FOUND          20AA    SD_CARD_TYPE       FF10
SD_CLEAR_ARG       2588    SD_CMD             2690    SD_DELAY           268B
SD_DELAY100        2689    SD_DESELECT        2678    SD_FETCH           20D2
SD_FIND_FILE       20B8    SD_LDIR1           20C6    SD_LDIRN           20DB
SD_OPEN            1DB1    SD_OPEN_FILENAME   1DA4    SD_PARAM           FF12
SD_PART_BASE       FF17    SD_PART_SIZE       FF1B    SD_PART_TYPE       FF16
SD_RAM_BUFFER      FC00    SD_READ_SEC        2491    SD_RS_0            24C8
SD_RS_1            24D7    SD_RS_FORCED       24AF    SD_RS_LP0          24BA
SD_RS_LP1          24CA    SD_RS_LP2          24DA    SD_SELECT          2683
SD_TEST            20D8    SD_WRITE_SEC       24EF    SD_WR_FAIL         2552
SD_WR_LP           2507    SEC_PER_CLUS       FF21    SEC_PER_FAT        FF2F
SEC_PTR            FF3D    SEED               81FE E  SET_BANK           0871
SET_ECHO           27D0    SET_IO             1382    SET_PARAM          256D
SHORTNWAY          0C94    SIGT               823C E  SIMSG              3644
SIO_OK             139E    SIO_RET            13B5    SIO_ZERO           139C
SIZE               30A9    SKIP               310F    SKIP1              3117
SKIP_HALT_TEST     16F5    SKIP_TABLE1        02BC    SKIP_TABLE2        0377
SKPQUO             3129    SL1                3048    SOFT_RST_FLAG      FFDF E
SOH                0001 E  SPACE_GET_BYTE     0D49    SPACE_GET_WORD     0D76
SPACE_PUT_BYTE     0DF3    SPI_RX             26D9    SPI_TX             26DB
SPI_TX_LP          26DF    SPLASH_VERSION     0374    SP_ISR_SAVE        FB28
SP_RET             257E    SRSEED             32E5    SSOC               0014 E
STACK              80F7 E  STACKSPACE1        FB00    STACKTOP           FAFE E
STACK_ISR1         FB28 E  STLIN              2AAF    STMEM              3300
STMSG              3638    STOP               2D2C    STOR               2FE7
STRT               32E1    SUBB               3244    SW2_ACE            07AC
SW2_BIT            07A4    SW2_BOTH           07B4    SWAP               3276
SYN                35EA    SYNT               2A7C    TABENT             2F7D
TB                 8032 E  TEMP               823E E  TEST_SIGNATURE     247E
TEXT               8600 E  TGC_LP1            144A    TGC_LP2            144C
TGC_RET            145A    THEN               2D32    TICCOUNTER         FFF0 E
TIMED1_GETCHAR     1445    TIMED_GETCHAR      1447    TINC               0E26
TLP0               2A51    TOP                2A2C    TO_UPPER           27AD
TRY                2C26    TSTZ_32            276E    UIVEC              FFB0 E
UIVEC_RET          17FB    URET               2FDD    UR_NOTRAM          0865
UR_RET             086B    UR_RET1            086E    USE_RAM            0831
USR                2FC8    USROUT             80FD E  V1                 2FC2
VADD_32_HL         009B    VADD_HL_A          0092    VARS               8200 E
VASC2BIN           00AA    VASC2HEX           00AD    VBEEP              005A
VCALL_HL           0CA0    VCHAR              2A78    VCLEAR_BLOCK       008C
VCMP_HL_32         009E    VDEC_32            00A4    VDELAY_A           0063
VDELAY_C           0060    VDISK_READ         00EC    VER1               309B
VERDAT             3094    VGET_BYTE          0083    VGET_CHAR          004B
VGET_HEX           0089    VGET_POS           0048    VGET_WORD          0086
VHEX2ASC           00B0    VIC_KEY            00B9    VIEW_FLAGS         FF0C
VINC_32            00A1    VINPUT_FNAME       00E0    VIN_CHAR           0051
VLD_HL_HL          008F    VLED_CLEAR         00D4    VLED_GET_POS       00BF
VLED_HOME          00C5    VLED_LEFT          00DA    VLED_PRINT         00CB
VLED_PUT_BYTE      00CE    VLED_PUT_CHAR      00C8    VLED_PUT_HEX       00D1
VLED_RIGHT         00D7    VLED_SET_POS       00C2    VLED_UPDATE        00BC
VLINE_INPUT        00F2    VMAIN_MENU         0042    VMOV_32_HL         0095
VMOV_HL_32         0098    VPRINT             0057    VPRINT_DIR         00E9
VPRINT_FNAME       00DD    VPUT_BC            0074    VPUT_BYTE          0071
VPUT_CHAR          0045    VPUT_DE            0077    VPUT_HEX           006E
VPUT_HL            007A    VPUT_NEW_LINE      0080    VPUT_SPACE         007D
VPUT_VERSION       006B    VRX_COUNT          004E    VSD_OPEN           00E3
VSD_OPEN_FILENAME  00E6    VSD_READ_SEC       00EF    VSET_ECHO          005D
VSET_IO            00B6    VTIMED_GETCHAR     0054    VTO_UPPER          00B3
VTSTZ_32           00A7    WAIT_NOT_BUSY      26EF    WARM_START         01CF
WB_NOT_STEP        0387    WHICH_PORT         07DA    WNB_0              2705
WNB_LP             26F3    WNB_LP2            26F5    WP_NOACE           0806
WP_NOBIT           07F6    WRITE_BLOCK        0C1D    WS_NOFP            01F8
WS_SET             0204    X0                 3472    XBF                8064 E
XMDN               0F04    XMDN_LP            0F11    XMGET_HDR          10AF
XMODEM             0EEE    XMR_ACK            1099    XMR_BLK_LP         1067
XMR_CCS            1090    XMR_CRC            1003    XMR_CS             101A
XMR_INIT           0FFC    XMR_LP             1036    XMR_NAK            10A3
XMR_RECV           1031    XMR_SEQ_OK         105F    XMR_TSEQ           104B
XMSEQ              FFF3 E  XMS_BLP            0F69    XMS_CS             0F86
XMS_DO             0F4A    XMS_EOT            0FA6    XMS_INIT           0F2E
XMS_INIT_LP        0F35    XMS_INIT_RT        0F45    XMS_RESEND         0F4E
XMS_SEND           0F52    XMTYPE             FFF4 E  XMUP               0F1F
XMUP_LP            0F26    XM_CANCEL          0FD8    XM_DONE            0FBA
XTIMER_TIC         FFDA E  Z1                 2F18    Z2                 2F28
Z3                 2F29    ZLOOP              30E6
